/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6c0235b5-e3cb-464a-a672-49e4d7578e5d
-/

/-
We formalized and proved the first part of Polya-Szego Problem 147.
The theorem `problem_147_part1` establishes the summation formula:
$$ \sum_{r_n \le r} f(r_n) = N(r)f(r) - \int_0^r N(t)f'(t) dt $$
under the assumptions that $f$ is differentiable with integrable derivative on $(0, \infty)$, and $\{r_n\}$ is a strictly increasing sequence of positive reals tending to infinity.
The proof utilizes the Fundamental Theorem of Calculus and properties of the counting function $N(r)$.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
If f(t) is differentiable and f'(t) properly integrable, t>0, then sum_{r_n <= r} f(r_n) = N(r)f(r) - int_0^r N(t)f'(t) dt
-/
open Set Filter Topology MeasureTheory

theorem problem_147_part1 {f : ℝ → ℝ} {r_seq : ℕ → ℝ}
    (h_seq_strict_mono : StrictMono r_seq) (h_seq_tends_to_infty : Tendsto r_seq atTop atTop)
    (h_pos : ∀ n, 0 < r_seq n) (hf_diff : ∀ t > 0, DifferentiableAt ℝ f t)
    (hf_int : ∀ r > 0, IntegrableOn (deriv f) (Icc 0 r)) :
    ∀ r > 0,
    let N := λ t => Set.ncard {n | r_seq n ≤ t}
    (∑ᶠ n, if r_seq n ≤ r then f (r_seq n) else 0) =
       (N r : ℝ) * f r - ∫ t in (0)..r, (N t : ℝ) * deriv f t := by
  -- Let's choose any $r > 0$.
  intro r hr_pos
  have h_finite : Set.Finite {n : ℕ | r_seq n ≤ r} := by
    exact Set.finite_iff_bddAbove.2 <| Filter.eventually_atTop.1 ( h_seq_tends_to_infty.eventually_gt_atTop r ) |> fun ⟨ n, hn ⟩ => ⟨ n, fun m hm => not_lt.1 fun contra => not_le_of_gt ( hn m contra.le ) hm ⟩;
  -- Let $r_1 < r_2 < \ldots < r_n \leq r$ be the elements of the set $\{n : ℕ | r_seq n ≤ r\}$.
  obtain ⟨s, hs⟩ : ∃ s : Finset ℕ, {n : ℕ | r_seq n ≤ r} = s := by
    exact ⟨ h_finite.toFinset, h_finite.coe_toFinset.symm ⟩;
  -- Using the fundamental theorem of calculus, we can rewrite the integral as $\int_0^r N(t) f'(t) dt = \sum_{i=1}^n \int_{r_i}^r f'(t) dt$.
  have h_ftc : ∫ t in (0:ℝ)..r, (s.filter (fun n => t ≥ r_seq n)).card * deriv f t = ∑ i ∈ s, ∫ t in (r_seq i)..r, deriv f t := by
    have h_ftc : ∫ t in (0:ℝ)..r, (s.filter (fun n => t ≥ r_seq n)).card * deriv f t = ∑ i ∈ s, ∫ t in (Set.Icc (r_seq i) r), deriv f t := by
      have h_ftc : ∫ t in (0:ℝ)..r, (s.filter (fun n => t ≥ r_seq n)).card * deriv f t = ∫ t in (Set.Icc 0 r), ∑ i ∈ s, (if t ≥ r_seq i then deriv f t else 0) := by
        rw [ intervalIntegral.integral_of_le hr_pos.le, MeasureTheory.integral_Icc_eq_integral_Ioc ];
        simp +decide [ Finset.sum_ite ];
      rw [ h_ftc, MeasureTheory.integral_finset_sum ];
      · rw [ Finset.sum_congr rfl ] ; intros ; rw [ ← MeasureTheory.integral_indicator, ← MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
        grind;
      · intro i hi;
        refine' MeasureTheory.Integrable.indicator _ _;
        · exact hf_int r hr_pos;
        · exact measurableSet_Ici;
    exact h_ftc.trans ( Finset.sum_congr rfl fun i hi => by rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, intervalIntegral.integral_of_le ( show r_seq i ≤ r from hs.symm.subset hi ) ] );
  -- Using the fundamental theorem of calculus, we can rewrite the integral as $\int_{r_i}^r f'(t) dt = f(r) - f(r_i)$.
  have h_ftc_eval : ∀ i ∈ s, ∫ t in (r_seq i)..r, deriv f t = f r - f (r_seq i) := by
    intro i hi; rw [ intervalIntegral.integral_eq_sub_of_hasDeriv_right ];
    · exact continuousOn_of_forall_continuousAt fun x hx => DifferentiableAt.continuousAt ( hf_diff x <| by cases Set.mem_uIcc.mp hx <;> linarith [ h_pos i, h_pos ( i + 1 ), h_seq_strict_mono i.lt_succ_self ] );
    · exact fun x hx => DifferentiableAt.hasDerivAt ( hf_diff x <| lt_of_le_of_lt ( le_min ( le_of_lt ( h_pos i ) ) hr_pos.le ) hx.1 ) |> HasDerivAt.hasDerivWithinAt;
    · rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le ];
      · exact MeasureTheory.IntegrableOn.mono_set ( hf_int r hr_pos ) ( Set.Ioc_subset_Icc_self.trans ( Set.Icc_subset_Icc ( le_of_lt ( h_pos i ) ) le_rfl ) );
      · exact hs.symm.subset hi;
  -- Substitute the definition of $N(t)$ into the expression.
  have h_N_def : ∀ t ∈ Set.Icc 0 r, (Set.ncard {n | r_seq n ≤ t}) = (s.filter (fun n => t ≥ r_seq n)).card := by
    intro t ht; rw [ ← Set.ncard_coe_finset ] ; congr; ext; simp_all +decide [ Set.ext_iff ] ;
    exact fun h => hs _ |>.1 ( le_trans h ht.2 );
  -- Substitute the definition of $N(t)$ into the integral.
  have h_integral_def : ∫ t in (0:ℝ)..r, (Set.ncard {n | r_seq n ≤ t}) * deriv f t = ∫ t in (0:ℝ)..r, (s.filter (fun n => t ≥ r_seq n)).card * deriv f t := by
    refine' intervalIntegral.integral_congr fun t ht => _;
    rw [ h_N_def t ( by rwa [ Set.uIcc_of_le hr_pos.le ] at ht ) ];
  rw [ show ( ∑ᶠ n : ℕ, if r_seq n ≤ r then f ( r_seq n ) else 0 ) = ∑ i ∈ s, f ( r_seq i ) from ?_ ];
  · aesop;
  · rw [ ← finsum_mem_coe_finset ];
    rw [ ← hs, finsum_mem_def ];
    exact?