/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d63ab057-7e43-44f2-a3a9-96feb292b78b

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Complex.Gamma
#check Complex.log
#check Complex.arctan

/-
The integrand for Binet's formula: arctan(t/z) / (e^(2πt) - 1).
-/
noncomputable def binet_integrand (z : ℂ) (t : ℝ) : ℂ :=
  Complex.arctan (t / z) / (Real.exp (2 * Real.pi * t) - 1)

/-
The derivative of the integrand with respect to z: -t / (z^2 + t^2) / (e^(2πt) - 1).
-/
noncomputable def binet_deriv_integrand (z : ℂ) (t : ℝ) : ℂ :=
  - (t : ℂ) / (z ^ 2 + t ^ 2) / (Real.exp (2 * Real.pi * t) - 1)

/-
The derivative of the integrand with respect to z is as defined.
-/
lemma binet_integrand_deriv (z : ℂ) (hz : 0 < z.re) (t : ℝ) (ht : 0 < t) :
  HasDerivAt (fun w => binet_integrand w t) (binet_deriv_integrand z t) z := by
  -- We'll use the fact that if the denominator is nonzero, we can apply the quotient rule.
  have h_quotient : HasDerivAt (fun w => Complex.arctan (t / w)) (-(t : ℂ) / (z ^ 2 + t ^ 2)) z := by
    -- The derivative of $\arctan(u)$ with respect to $u$ is $\frac{1}{1+u^2}$.
    have h_arctan_deriv : HasDerivAt (fun u : ℂ => Complex.arctan u) (1 / (1 + (t / z) ^ 2)) (t / z) := by
      have h_arctan : HasDerivAt (fun u : ℂ => Complex.log ((1 + Complex.I * u) / (1 - Complex.I * u))) ((2 * Complex.I) / (1 + (t / z) ^ 2)) (t / z) := by
        convert HasDerivAt.clog ( HasDerivAt.div ( HasDerivAt.add ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( hasDerivAt_const _ _ ) ( hasDerivAt_id _ ) ) ) ( HasDerivAt.sub ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( hasDerivAt_const _ _ ) ( hasDerivAt_id _ ) ) ) _ ) _ using 1 <;> norm_num;
        · field_simp;
          ring ; norm_num [ Complex.ext_iff, sq ];
        · norm_num [ Complex.ext_iff ];
          norm_num [ Complex.normSq, Complex.div_re, Complex.div_im ] ; aesop;
        · norm_num [ Complex.slitPlane, Complex.ext_iff ];
          norm_num [ Complex.normSq, Complex.div_re, Complex.div_im ];
          field_simp;
          exact Or.inr ( by nlinarith [ mul_pos ht hz, mul_pos ht ( sq_pos_of_pos hz ), mul_pos ht ( sq_pos_of_pos ht ), mul_pos hz ( sq_pos_of_pos hz ), mul_pos hz ( sq_pos_of_pos ht ) ] );
      convert h_arctan.div_const ( 2 * Complex.I ) using 1 <;> norm_num [ Complex.arctan ];
      · ext; ring ; norm_num ; ring;
      · rw [ eq_div_iff ( by norm_num [ Complex.ext_iff ] ) ] ; ring;
    convert h_arctan_deriv.comp z ( HasDerivAt.const_mul ( t : ℂ ) ( hasDerivAt_inv ( show z ≠ 0 by rintro rfl; norm_num at hz ) ) ) using 1 ; ring;
    field_simp;
    rw [ mul_add, mul_div_cancel₀ _ ( pow_ne_zero 2 <| by rintro rfl; norm_num at hz ) ] ; ring;
  convert h_quotient.div_const ( Real.exp ( 2 * Real.pi * t ) - 1 ) using 1

/-
The integrand is integrable on (0, 1].
-/
lemma binet_deriv_integrand_integrable_Ioc (z : ℂ) (hz : 0 < z.re) :
  MeasureTheory.IntegrableOn (binet_deriv_integrand z) (Set.Ioc 0 1) := by
  unfold binet_deriv_integrand;
  refine' MeasureTheory.Integrable.mono' _ _ _;
  refine' fun t => |t| / ( z.re ^ 2 ) / ( Real.exp ( 2 * Real.pi * t ) - 1 );
  · -- The integral of $|t| / (z.re^2) / (e^{2\pi t} - 1)$ over $(0, 1]$ is finite because $|t|$ is bounded and $e^{2\pi t} - 1$ grows exponentially.
    have h_integrable : MeasureTheory.IntegrableOn (fun t : ℝ => |t| / (Real.exp (2 * Real.pi * t) - 1)) (Set.Ioc 0 1) := by
      -- We'll use the fact that if the denominator grows faster than the numerator, the integral converges. Notice that $e^{2\pi t} - 1 \geq 2\pi t$ for $t \geq 0$.
      have h_bound : ∀ t : ℝ, 0 < t → |t| / (Real.exp (2 * Real.pi * t) - 1) ≤ 1 / (2 * Real.pi) := by
        intro t ht; rw [ abs_of_pos ht ] ; rw [ div_le_div_iff₀ ] <;> nlinarith [ Real.pi_pos, Real.add_one_le_exp ( 2 * Real.pi * t ), mul_pos Real.pi_pos ht ] ;
      refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun t => 1 / ( 2 * Real.pi );
      · fun_prop (disch := norm_num);
      · exact ContinuousOn.aestronglyMeasurable ( fun t ht => ContinuousAt.continuousWithinAt ( by exact ContinuousAt.div ( continuousAt_id.abs ) ( ContinuousAt.sub ( Real.continuous_exp.continuousAt.comp ( continuousAt_const.mul continuousAt_id ) ) continuousAt_const ) ( ne_of_gt ( by norm_num; nlinarith [ Real.pi_pos, ht.1 ] ) ) ) ) measurableSet_Ioc;
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using by rw [ Real.norm_of_nonneg ( div_nonneg ( abs_nonneg _ ) ( sub_nonneg.2 ( Real.one_le_exp ( by nlinarith [ Real.pi_pos, ht.1 ] ) ) ) ) ] ; exact h_bound t ht.1;
    convert h_integrable.div_const ( z.re ^ 2 ) using 2 ; ring;
  · refine' Measurable.aestronglyMeasurable _;
    fun_prop;
  · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht;
    norm_num [ Complex.normSq, Complex.norm_def ];
    gcongr <;> norm_cast <;> norm_num [ sq ];
    · nlinarith [ Real.pi_pos, ht.1 ];
    · exact Real.le_sqrt_of_sq_le ( by nlinarith [ sq_nonneg ( z.re * z.im + z.im * z.re ), sq_nonneg ( z.re * z.re - z.im * z.im + t * t - z.re * z.re ), sq_nonneg ( z.re * z.re - z.im * z.im + t * t + z.re * z.re ) ] );
    · norm_num [ Complex.exp_re, Complex.exp_im ];
      rw [ Real.sqrt_mul_self ] <;> linarith [ Real.add_one_le_exp ( 2 * Real.pi * t ), Real.pi_pos, mul_pos Real.pi_pos ht.1 ]

/-
The integrand is bounded by an exponential decay on (1, ∞).
-/
lemma binet_deriv_integrand_bound_Ioi (z : ℂ) (hz : 0 < z.re) :
  ∃ C, ∀ t ∈ Set.Ioi 1, ‖binet_deriv_integrand z t‖ ≤ C * Real.exp (-Real.pi * t) := by
  unfold binet_deriv_integrand;
  -- We'll use the fact that if the denominator grows exponentially, the integrand is bounded.
  have h_bound : ∃ C : ℝ, ∀ t ∈ Set.Ioi (1 : ℝ), ‖-(t : ℂ) / (z ^ 2 + t ^ 2)‖ ≤ C := by
    norm_num [ Complex.norm_def, Complex.normSq ];
    norm_cast ; norm_num [ sq ];
    use 1 / z.re;
    field_simp;
    exact fun t ht => div_le_one_of_le₀ ( Real.le_sqrt_of_sq_le ( by rw [ abs_of_pos ( by positivity ) ] ; nlinarith [ sq_nonneg ( z.re ^ 2 - z.im ^ 2 + t ^ 2 - z.re ^ 2 ), sq_nonneg ( z.re ^ 2 - z.im ^ 2 + t ^ 2 + z.re ^ 2 ) ] ) ) ( Real.sqrt_nonneg _ );
  -- We'll use the fact that if the denominator grows exponentially, the integrand is bounded. Hence, we can find a constant $C$ such that $|1 / (e^{2\pi t} - 1)| \leq C e^{-\pi t}$.
  have h_exp_bound : ∃ C : ℝ, ∀ t ∈ Set.Ioi (1 : ℝ), ‖(Real.exp (2 * Real.pi * t) - 1 : ℂ)‖⁻¹ ≤ C * Real.exp (-Real.pi * t) := by
    norm_num [ Complex.norm_def, Complex.normSq ];
    norm_num [ Complex.exp_re, Complex.exp_im ];
    refine' ⟨ 2, fun t ht => _ ⟩ ; rw [ Real.sqrt_mul_self ( sub_nonneg.mpr <| Real.one_le_exp <| by positivity ) ] ; rw [ inv_eq_one_div, div_le_iff₀ ] <;> ring_nf <;> norm_num [ Real.exp_pos, Real.pi_pos ];
    · norm_num [ ← Real.exp_add ] ; ring_nf;
      nlinarith [ Real.pi_gt_three, Real.add_one_le_exp ( Real.pi * t ), Real.exp_pos ( - ( Real.pi * t ) ), Real.exp_lt_one_iff.mpr ( show - ( Real.pi * t ) < 0 by nlinarith [ Real.pi_gt_three ] ) ];
    · linarith;
  simp_all +decide [ div_eq_mul_inv, mul_assoc, norm_mul ];
  exact ⟨ h_bound.choose * h_exp_bound.choose, fun t ht => by rw [ ← mul_assoc ] ; exact le_trans ( mul_le_mul_of_nonneg_right ( h_bound.choose_spec t ht ) ( by positivity ) ) ( by nlinarith [ h_exp_bound.choose_spec t ht, show 0 ≤ h_bound.choose by exact le_trans ( by positivity ) ( h_bound.choose_spec 2 ( by norm_num ) ) ] ) ⟩

/-
The integrand is integrable on (1, ∞).
-/
lemma binet_deriv_integrand_integrable_Ioi (z : ℂ) (hz : 0 < z.re) :
  MeasureTheory.IntegrableOn (binet_deriv_integrand z) (Set.Ioi 1) := by
    -- By the bound from `binet_deriv_integrand_bound_Ioi`, the integrand is integrable on $(1, \infty)$.
    obtain ⟨C, hC⟩ := binet_deriv_integrand_bound_Ioi z hz;
    have h_integrable_Ioi : MeasureTheory.IntegrableOn (fun t : ℝ => C * Real.exp (-Real.pi * t)) (Set.Ioi 1) := by
      have h_integrable_Ioi : MeasureTheory.IntegrableOn (fun t : ℝ => Real.exp (-Real.pi * t)) (Set.Ioi 0) := by
        have := ( exp_neg_integrableOn_Ioi 0 ( by positivity : 0 < Real.pi ) );
        exact this;
      exact MeasureTheory.Integrable.const_mul ( h_integrable_Ioi.mono_set <| Set.Ioi_subset_Ioi zero_le_one ) _;
    refine' h_integrable_Ioi.mono' _ _;
    · refine' Measurable.aestronglyMeasurable _;
      apply_rules [ Measurable.div, Measurable.mul, measurable_const, measurable_id ];
      · exact Measurable.neg ( Complex.measurable_ofReal );
      · exact Measurable.add measurable_const ( by exact Measurable.pow_const ( Complex.measurable_ofReal ) _ );
      · exact Measurable.sub ( Complex.continuous_ofReal.measurable.comp ( Real.continuous_exp.measurable.comp ( measurable_const.mul measurable_id' ) ) ) measurable_const;
    · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with t ht using hC t ht

/-
The integrand is integrable on (1, ∞).
-/
lemma binet_deriv_integrand_integrable_Ioi_aux (z : ℂ) (hz : 0 < z.re) :
  MeasureTheory.IntegrableOn (binet_deriv_integrand z) (Set.Ioi 1) := by
    exact?

/-
Helper lemma: z^2 + t^2 is not zero for Re(z) > 0 and real t.
-/
lemma binet_denominator_ne_zero (z : ℂ) (hz : 0 < z.re) (t : ℝ) : z ^ 2 + (t : ℂ) ^ 2 ≠ 0 := by
  norm_num [ Complex.ext_iff, sq ];
  intro h; nlinarith [ sq_pos_of_pos hz ] ;

/-
The integrand is integrable on (1, ∞).
-/
lemma binet_deriv_integrand_integrable_Ioi_v2 (z : ℂ) (hz : 0 < z.re) :
  MeasureTheory.IntegrableOn (binet_deriv_integrand z) (Set.Ioi 1) := by
    exact?

/-
The integrand is integrable on (1, ∞).
-/
lemma binet_deriv_integrand_integrable_Ioi_corrected (z : ℂ) (hz : 0 < z.re) :
  MeasureTheory.IntegrableOn (binet_deriv_integrand z) (Set.Ioi 1) := by
    exact?

/-
The integrand is integrable on (1, ∞).
-/
lemma binet_deriv_integrand_integrable_Ioi_v3 (z : ℂ) (hz : 0 < z.re) :
  MeasureTheory.IntegrableOn (binet_deriv_integrand z) (Set.Ioi 1) := by
    exact?

/-
The integrand is integrable on (1, ∞).
-/
lemma binet_deriv_integrand_integrable_Ioi_v4 (z : ℂ) (hz : 0 < z.re) :
  MeasureTheory.IntegrableOn (binet_deriv_integrand z) (Set.Ioi 1) := by
    -- Apply the lemma with the hypothesis that $0 < z.re$.
    apply binet_deriv_integrand_integrable_Ioi_v2 z hz

/-
Helper lemma: z^2 + t^2 is not zero for Re(z) > 0 and real t.
-/
lemma binet_denominator_ne_zero_v2 (z : ℂ) (hz : 0 < z.re) (t : ℝ) : z ^ 2 + (t : ℂ) ^ 2 ≠ 0 := by
  exact?

/-
Helper lemma: z^2 + t^2 is not zero for Re(z) > 0 and real t.
-/
lemma binet_denominator_ne_zero_v3 (z : ℂ) (hz : 0 < z.re) (t : ℝ) : z ^ 2 + (t : ℂ) ^ 2 ≠ 0 := by
  exact?

/-
Helper lemma: z^2 + t^2 is not zero for Re(z) > 0 and real t.
-/
lemma binet_denominator_ne_zero_v4 (z : ℂ) (hz : 0 < z.re) (t : ℝ) : z ^ 2 + (t : ℂ) ^ 2 ≠ 0 := by
  exact?

#check pow_two
#check Complex.mul_re
#check Complex.mul_im

/-
Helper lemma: z^2 + t^2 is not zero for Re(z) > 0 and real t.
-/
lemma binet_denominator_ne_zero_v5 (z : ℂ) (hz : 0 < z.re) (t : ℝ) : z ^ 2 + (t : ℂ) ^ 2 ≠ 0 := by
  exact?

/-
Helper lemma: z^2 + t^2 is not zero for Re(z) > 0 and real t.
-/
lemma binet_denominator_ne_zero_v6 (z : ℂ) (hz : 0 < z.re) (t : ℝ) : z ^ 2 + (t : ℂ) ^ 2 ≠ 0 := by
  exact?

/-
Helper lemma: z^2 + t^2 is not zero for Re(z) > 0 and real t.
-/
lemma binet_denominator_ne_zero_v7 (z : ℂ) (hz : 0 < z.re) (t : ℝ) : z ^ 2 + (t : ℂ) ^ 2 ≠ 0 := by
  exact?

/-
Helper lemma: z^2 + t^2 is not zero for Re(z) > 0 and real t.
-/
lemma binet_denominator_ne_zero_v8 (z : ℂ) (hz : 0 < z.re) (t : ℝ) : z ^ 2 + (t : ℂ) ^ 2 ≠ 0 := by
  exact?

/-
Helper lemma: z^2 + t^2 is not zero for Re(z) > 0 and real t.
-/
lemma binet_denominator_ne_zero_v9 (z : ℂ) (hz : 0 < z.re) (t : ℝ) : z ^ 2 + (t : ℂ) ^ 2 ≠ 0 := by
  exact?

/-
The integrand is integrable on (0, ∞) by combining the results for (0, 1] and (1, ∞).
-/
lemma binet_deriv_integrand_integrable (z : ℂ) (hz : 0 < z.re) :
  MeasureTheory.IntegrableOn (binet_deriv_integrand z) (Set.Ioi 0) := by
  rw [← Set.Ioc_union_Ioi_eq_Ioi (zero_le_one : (0 : ℝ) ≤ 1), MeasureTheory.integrableOn_union]
  constructor
  · exact binet_deriv_integrand_integrable_Ioc z hz
  · exact binet_deriv_integrand_integrable_Ioi_v4 z hz

/-
For w in a neighborhood of z, |w^2 + t^2| is bounded below by c(1+t^2).
-/
lemma complex_sq_add_sq_lower_bound (z : ℂ) (hz : 0 < z.re) :
    ∃ ε > 0, ∃ c > 0, ∀ w ∈ Metric.ball z ε, ∀ t : ℝ, c * (1 + t ^ 2) ≤ ‖w ^ 2 + (t : ℂ) ^ 2‖ := by
      -- If $z \neq 0$, we can consider two cases: $z.re > 0$ or $z.re \leq 0$. First, we handle the case where $z.re > 0$.
      have h_case1 : ∃ c > 0, ∀ t : ℝ, c * (1 + t ^ 2) ≤ ‖z ^ 2 + t ^ 2‖ := by
        norm_num [ Complex.normSq, Complex.norm_def ];
        norm_cast ; norm_num [ sq ];
        refine' ⟨ z.re ^ 2 / ( z.re ^ 2 + z.im ^ 2 + 1 ), by positivity, fun t => Real.le_sqrt_of_sq_le _ ⟩;
        rw [ div_mul_eq_mul_div, div_pow, div_le_iff₀ ] <;> ring <;> try positivity;
        nlinarith [ sq_nonneg ( z.re ^ 2 - z.im ^ 2 ), sq_nonneg ( z.re ^ 2 - t ^ 2 ), sq_nonneg ( z.im ^ 2 - t ^ 2 ), pow_two_nonneg ( z.re * z.im ), pow_two_nonneg ( z.re * t ), pow_two_nonneg ( z.im * t ), pow_nonneg hz.le 4, pow_nonneg hz.le 6, pow_nonneg hz.le 8, pow_nonneg ( sq_nonneg z.im ) 2, pow_nonneg ( sq_nonneg z.im ) 3, pow_nonneg ( sq_nonneg z.im ) 4, pow_nonneg ( sq_nonneg t ) 2, pow_nonneg ( sq_nonneg t ) 3, pow_nonneg ( sq_nonneg t ) 4 ];
      choose c hc using h_case1;
      -- Choose $\epsilon$ small enough such that for all $w$ with $|w - z| < \epsilon$, we have $|w^2 - z^2| < \frac{c}{2}(1 + t^2)$ for all $t$.
      obtain ⟨ε, hε⟩ : ∃ ε > 0, ∀ w ∈ Metric.ball z ε, ∀ t : ℝ, ‖w^2 - z^2‖ < c / 2 * (1 + t^2) := by
        have h_eps : ∃ ε > 0, ∀ w ∈ Metric.ball z ε, ‖w^2 - z^2‖ < c / 2 := by
          have := Metric.continuous_iff.mp ( show Continuous fun w : ℂ => ‖w ^ 2 - z ^ 2‖ from Continuous.norm ( by continuity ) ) z ( c / 2 ) ( half_pos hc.1 ) ; aesop;
        exact ⟨ h_eps.choose, h_eps.choose_spec.1, fun w hw t => lt_of_lt_of_le ( h_eps.choose_spec.2 w hw ) ( le_mul_of_one_le_right ( by linarith ) ( by nlinarith ) ) ⟩;
      use ε, hε.left, c / 2, half_pos hc.left; intro w hw t; have := hε.right w hw t; have := hc.right t; norm_num at *; (
      have := norm_sub_le ( w ^ 2 + t ^ 2 ) ( w ^ 2 - z ^ 2 ) ; ( ring_nf at *; norm_num at *; linarith; ));

#check binet_denominator_ne_zero
#check Complex.abs_re_le_norm
#check ProperSpace.isCompact_closedBall
#check Complex.normSq_eq_norm_sq

#check Set.Nonempty.prod

/-
For large t, |w^2 + t^2| is bounded below by (1+t^2)/2.
-/
lemma complex_sq_add_sq_lower_bound_large_t (M : ℝ) :
    ∃ T : ℝ, ∀ w : ℂ, ‖w‖ ≤ M → ∀ t : ℝ, T ≤ |t| → 1 / 2 * (1 + t ^ 2) ≤ ‖w ^ 2 + (t : ℂ) ^ 2‖ := by
      -- Choose $N$ such that $(\text{Re}(w) + \text{Im}(w))^2 + N^2 - M^2 \leq 0$, then $|w^2 + t^2| \geq t^2 - M^2 \geq 1/2 * (1 + t^2)$ for $|t| > N$.
      obtain ⟨N, hN⟩ : ∃ N : ℝ, ∀ t : ℝ, |t| > N → (1 / 2) * (1 + t ^ 2) ≤ t ^ 2 - M ^ 2 := by
        exact ⟨ 2 * |M| + 1, fun t ht => by cases abs_cases M <;> cases abs_cases t <;> nlinarith ⟩;
      refine' ⟨ N + 1, fun w hw t ht => le_trans ( hN t ( by linarith ) ) _ ⟩;
      have := norm_sub_le ( w ^ 2 + ( t : ℂ ) ^ 2 ) ( w ^ 2 ) ; norm_num at *;
      exact le_trans this ( add_le_add_left ( pow_le_pow_left₀ ( norm_nonneg _ ) hw 2 ) _ )

/-
On a compact set, |w^2 + t^2| is bounded below by c(1+t^2).
-/
lemma complex_sq_add_sq_lower_bound_compact (z : ℂ) (hz : 0 < z.re) (T : ℝ) (hT : 0 ≤ T) :
    ∃ c > 0, ∀ w ∈ Metric.ball z (z.re / 2), ∀ t ∈ Set.Icc (-T) T, c * (1 + t ^ 2) ≤ ‖w ^ 2 + (t : ℂ) ^ 2‖ := by
      -- The set $K = \overline{B(z, \epsilon)}$ is compact.
      set K := Metric.closedBall z (z.re / 2) with hK_def
      have hK_compact : IsCompact K := by
        exact ProperSpace.isCompact_closedBall _ _;
      -- The function $f(w, t) = |w^2 + t^2| / (1 + t^2)$ is continuous on $S$.
      set f : ℂ × ℝ → ℝ := fun p => ‖p.1 ^ 2 + p.2 ^ 2‖ / (1 + p.2 ^ 2) with hf_def
      have hf_cont : ContinuousOn f (K ×ˢ Set.Icc (-T) T) := by
        exact ContinuousOn.div ( ContinuousOn.norm <| ContinuousOn.add ( continuousOn_fst.pow 2 ) <| ContinuousOn.pow ( Complex.continuous_ofReal.comp_continuousOn continuousOn_snd ) 2 ) ( ContinuousOn.add continuousOn_const <| continuousOn_snd.pow 2 ) fun p hp => by positivity;
      -- The denominator is always $\ge 1$.
      have h_denom_pos : ∀ w ∈ K, ∀ t ∈ Set.Icc (-T) T, 0 < ‖w ^ 2 + t ^ 2‖ := by
        -- For any $w \in K$, we have $\Re(w) \geq \Re(z) / 2 > 0$.
        have h_re_pos : ∀ w ∈ K, 0 < w.re := by
          intro w hw
          have h_re_pos : w.re ≥ z.re / 2 := by
            simp +zetaDelta at *;
            rw [ dist_eq_norm ] at hw ; rw [ Complex.norm_def ] at hw ; simp_all +decide [ Complex.normSq ];
            rw [ Real.sqrt_le_left ] at hw <;> nlinarith [ sq_nonneg ( w.re - z.re ), sq_nonneg ( w.im - z.im ) ]
          linarith [hz];
        intro w hw t ht; specialize h_re_pos w hw; simp_all +decide [ Complex.ext_iff, sq ] ;
        intro h; nlinarith [ sq_pos_of_pos h_re_pos ] ;
      -- Since $S$ is compact, $f$ attains a minimum $c > 0$.
      obtain ⟨c, hc⟩ : ∃ c ∈ Set.image f (K ×ˢ Set.Icc (-T) T), ∀ y ∈ Set.image f (K ×ˢ Set.Icc (-T) T), c ≤ y := by
        apply_rules [ IsCompact.exists_isLeast, hK_compact.prod ];
        · exact IsCompact.image_of_continuousOn ( hK_compact.prod ( CompactIccSpace.isCompact_Icc ) ) hf_cont;
        · exact ⟨ _, ⟨ ( z, 0 ), ⟨ Metric.mem_closedBall_self ( by linarith ), ⟨ by linarith, by linarith ⟩ ⟩, rfl ⟩ ⟩;
      simp +zetaDelta at *;
      exact ⟨ c, by obtain ⟨ a, b, ⟨ ha, hb₁, hb₂ ⟩, rfl ⟩ := hc.1; exact div_pos ( norm_pos_iff.mpr ( h_denom_pos a ha b hb₁ hb₂ ) ) ( by positivity ), fun w hw t ht₁ ht₂ => by have := hc.2 _ w t ( by simpa using hw.le ) ht₁ ht₂ rfl; rw [ le_div_iff₀ ( by positivity ) ] at this; linarith ⟩

/-
z^2 + t^2 is not zero for Re(z) > 0 and real t.
-/
lemma binet_denominator_ne_zero' (z : ℂ) (hz : 0 < z.re) (t : ℝ) : z ^ 2 + (t : ℂ) ^ 2 ≠ 0 := by
  exact?

/-
On a compact set K, |w^2 + t^2| is bounded below by c(1+t^2) for t in [-T, T].
-/
lemma complex_sq_add_sq_lower_bound_on_compact (K : Set ℂ) (hK : IsCompact K)
    (h_avoid : ∀ w ∈ K, ∀ t : ℝ, w ^ 2 + (t : ℂ) ^ 2 ≠ 0) (T : ℝ) :
    ∃ c > 0, ∀ w ∈ K, ∀ t ∈ Set.Icc (-T) T, c * (1 + t ^ 2) ≤ ‖w ^ 2 + (t : ℂ) ^ 2‖ := by
      -- The function $(w, t) \mapsto \|w^2 + t^2\|$ is continuous on the compact set $K \times [-T, T]$.
      have h_cont : ContinuousOn (fun p : ℂ × ℝ => ‖p.1 ^ 2 + p.2 ^ 2‖) (K ×ˢ Set.Icc (-T) T) := by
        fun_prop;
      -- Since $(w, t) \mapsto \|w^2 + t^2\|$ is continuous on the compact set $K \times [-T, T]$, it attains a minimum value $c > 0$ on this set.
      obtain ⟨c, hc_pos, hc_min⟩ : ∃ c > 0, ∀ p ∈ K ×ˢ Set.Icc (-T) T, c ≤ ‖p.1 ^ 2 + p.2 ^ 2‖ := by
        by_cases h_empty : K ×ˢ Set.Icc (-T) T = ∅;
        · exact ⟨ 1, zero_lt_one, fun p hp => False.elim <| h_empty.subset hp ⟩;
        · -- Since the set is compact, the continuous function must attain its minimum value. Let's call that minimum value c.
          obtain ⟨p, hp⟩ : ∃ p ∈ K ×ˢ Set.Icc (-T) T, ∀ q ∈ K ×ˢ Set.Icc (-T) T, ‖q.1 ^ 2 + q.2 ^ 2‖ ≥ ‖p.1 ^ 2 + p.2 ^ 2‖ := by
            exact ( IsCompact.exists_isMinOn ( hK.prod ( CompactIccSpace.isCompact_Icc ) ) ⟨ Classical.choose ( Set.nonempty_iff_ne_empty.mpr h_empty ), Classical.choose_spec ( Set.nonempty_iff_ne_empty.mpr h_empty ) ⟩ h_cont );
          exact ⟨ ‖p.1 ^ 2 + p.2 ^ 2‖, norm_pos_iff.mpr ( h_avoid p.1 hp.1.1 p.2 ), hp.2 ⟩;
      exact ⟨ c / ( 1 + T ^ 2 ), div_pos hc_pos ( by positivity ), fun w hw t ht => by rw [ div_mul_eq_mul_div, div_le_iff₀ ] <;> nlinarith [ hc_min ( w, t ) ⟨ hw, ht ⟩, ht.1, ht.2, show ( 1 + t ^ 2 ) ≤ 1 + T ^ 2 by nlinarith [ ht.1, ht.2 ] ] ⟩

/-
The function t / (e^(2πt) - 1) is bounded on (0, ∞).
-/
lemma t_div_exp_sub_one_bound : ∃ K > 0, ∀ t ∈ Set.Ioi 0, t / (Real.exp (2 * Real.pi * t) - 1) ≤ K := by
  refine' ⟨ 1 / ( 2 * Real.pi ), _, fun t ht => _ ⟩;
  · positivity;
  · rw [ div_le_div_iff₀ ] <;> nlinarith [ Real.pi_gt_three, ht.out, Real.add_one_le_exp ( 2 * Real.pi * t ), mul_pos Real.pi_pos ht.out ]

/-
The function t / (e^(2πt) - 1) is bounded by 1/(2π) on (0, ∞).
-/
lemma t_div_exp_sub_one_bound_explicit : ∀ t ∈ Set.Ioi 0, t / (Real.exp (2 * Real.pi * t) - 1) ≤ 1 / (2 * Real.pi) := by
  norm_num +zetaDelta at *;
  exact fun t ht => by rw [ div_le_iff₀ ] <;> nlinarith [ Real.pi_gt_three, mul_pos ht Real.pi_pos, Real.add_one_le_exp ( 2 * Real.pi * t ), mul_inv_cancel₀ Real.pi_ne_zero ] ;

/-
The constructed bound function is integrable on (0, ∞).
-/
lemma binet_bound_integrable (c : ℝ) (hc : 0 < c) :
  MeasureTheory.IntegrableOn (fun t : ℝ => (t / (c * (1 + t ^ 2))) * (1 / (Real.exp (2 * Real.pi * t) - 1))) (Set.Ioi 0) := by
    have h_integrable : MeasureTheory.IntegrableOn (fun t : ℝ => t / (1 + t ^ 2) * (1 / (Real.exp (2 * Real.pi * t) - 1))) (Set.Ioi 0) := by
      have h_integrable : MeasureTheory.IntegrableOn (fun t : ℝ => t / (1 + t ^ 2) * (1 / (Real.exp (2 * Real.pi * t) - 1))) (Set.Ioi 1) := by
        have h_integrable : MeasureTheory.IntegrableOn (fun t : ℝ => (1 / (Real.exp (2 * Real.pi * t) - 1))) (Set.Ioi 1) := by
          have h_integrable : MeasureTheory.IntegrableOn (fun t : ℝ => Real.exp (-2 * Real.pi * t)) (Set.Ioi 1) := by
            have := ( exp_neg_integrableOn_Ioi 0 ( by positivity : ( 0 : ℝ ) < 2 * Real.pi ) );
            simpa only [ neg_mul ] using this.mono_set ( Set.Ioi_subset_Ioi zero_le_one );
          refine' h_integrable.const_mul 2 |> fun h => h.mono' _ _;
          · exact Measurable.aestronglyMeasurable ( by exact Measurable.div measurable_const ( by exact Measurable.sub ( Real.continuous_exp.measurable.comp ( measurable_const.mul measurable_id' ) ) measurable_const ) );
          · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with t ht;
            norm_num [ Real.exp_neg ];
            rw [ abs_of_nonneg ( sub_nonneg_of_le ( Real.one_le_exp ( by nlinarith [ Real.pi_pos, ht.out ] ) ) ) ] ; rw [ inv_le_comm₀ ] <;> norm_num <;> nlinarith [ Real.pi_gt_three, ht.out, Real.add_one_le_exp ( 2 * Real.pi * t ), mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos ( 2 * Real.pi * t ) ) ) ];
        refine' h_integrable.mono' _ _;
        · exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( continuous_id.div ( by continuity ) fun x => by positivity ) ) h_integrable.aestronglyMeasurable;
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with x hx using by rw [ Real.norm_of_nonneg ( mul_nonneg ( div_nonneg ( by linarith [ hx.out ] ) ( by positivity ) ) ( one_div_nonneg.mpr ( sub_nonneg.mpr ( Real.one_le_exp ( by nlinarith [ hx.out, Real.pi_pos ] ) ) ) ) ) ] ; exact mul_le_of_le_one_left ( one_div_nonneg.mpr ( sub_nonneg.mpr ( Real.one_le_exp ( by nlinarith [ hx.out, Real.pi_pos ] ) ) ) ) ( div_le_one_of_le₀ ( by nlinarith [ hx.out ] ) ( by positivity ) ) ;
      have h_integrable : MeasureTheory.IntegrableOn (fun t : ℝ => t / (1 + t ^ 2) * (1 / (Real.exp (2 * Real.pi * t) - 1))) (Set.Ioc 0 1) := by
        -- We'll use the fact that $t / (1 + t^2) * (1 / (e^(2πt) - 1))$ is bounded on $(0, 1]$.
        have h_bound : ∀ t ∈ Set.Ioc 0 1, t / (1 + t ^ 2) * (1 / (Real.exp (2 * Real.pi * t) - 1)) ≤ 1 / (2 * Real.pi) := by
          field_simp;
          intro t ht; rw [ div_le_iff₀ ] <;> nlinarith [ ht.1, ht.2, Real.pi_gt_three, Real.add_one_le_exp ( t * 2 * Real.pi ), mul_pos ht.1 Real.pi_pos ] ;
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun t => 1 / ( 2 * Real.pi );
        · fun_prop;
        · exact Measurable.aestronglyMeasurable ( by exact Measurable.mul ( measurable_id.div ( measurable_const.add ( measurable_id.pow_const 2 ) ) ) ( measurable_const.div ( by exact Measurable.sub ( Real.continuous_exp.measurable.comp ( measurable_const.mul measurable_id ) ) measurable_const ) ) );
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using by rw [ Real.norm_of_nonneg ( mul_nonneg ( div_nonneg ht.1.le ( by positivity ) ) ( one_div_nonneg.mpr ( sub_nonneg.mpr ( Real.one_le_exp ( by nlinarith [ Real.pi_pos, ht.1 ] ) ) ) ) ) ] ; exact h_bound t ht;
      convert h_integrable.union ‹MeasureTheory.IntegrableOn ( fun t : ℝ => t / ( 1 + t ^ 2 ) * ( 1 / ( Real.exp ( 2 * Real.pi * t ) - 1 ) ) ) ( Set.Ioi 1 ) MeasureTheory.MeasureSpace.volume› using 1 ; ext ; aesop;
    simpa [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ] using h_integrable.const_mul c⁻¹

/-
There exists a local integrable bound for the derivative of the integrand.
-/
lemma binet_deriv_bound (z : ℂ) (hz : 0 < z.re) :
  ∃ ε > 0, ∃ (bound : ℝ → ℝ), MeasureTheory.IntegrableOn bound (Set.Ioi 0) ∧
  ∀ w ∈ Metric.ball z ε, ∀ t ∈ Set.Ioi 0, ‖binet_deriv_integrand w t‖ ≤ bound t := by
    -- Let's choose any $c > 0$ such that $c * (1 + t^2) \leq \|w^2 + t^2\|$ for all $w$ in a neighborhood of $z$ and $t \in \mathbb{R}$.
    obtain ⟨ε, hε_pos, c, hc_pos, h_bound⟩ : ∃ ε > 0, ∃ c > 0, ∀ w ∈ Metric.ball z ε, ∀ t : ℝ, c * (1 + t ^ 2) ≤ ‖w ^ 2 + (t : ℂ) ^ 2‖ := by
      exact?;
    refine' ⟨ ε, hε_pos, fun t => t / ( c * ( 1 + t ^ 2 ) ) * ( 1 / ( Real.exp ( 2 * Real.pi * t ) - 1 ) ), _, _ ⟩;
    · convert binet_bound_integrable c hc_pos using 1;
    · intro w hw t ht
      simp [binet_deriv_integrand];
      rw [ abs_of_nonneg ht.out.le, div_mul_eq_mul_div ];
      rw [ div_right_comm ];
      gcongr;
      · exact mul_nonneg ht.out.le ( inv_nonneg.2 ( sub_nonneg.2 ( Real.one_le_exp ( by nlinarith [ Real.pi_pos, ht.out ] ) ) ) );
      · norm_num [ Complex.norm_def, Complex.normSq, Complex.exp_re, Complex.exp_im ];
        rw [ Real.sqrt_mul_self ( sub_nonneg.2 <| Real.one_le_exp <| by nlinarith [ Real.pi_pos, ht.out ] ), div_eq_mul_inv ];
      · exact h_bound w hw t

/-
There exists a local integrable bound for the derivative of the integrand.
-/
lemma binet_deriv_bound' (z : ℂ) (hz : 0 < z.re) :
  ∃ ε > 0, ∃ (bound : ℝ → ℝ), MeasureTheory.IntegrableOn bound (Set.Ioi 0) ∧
  ∀ w ∈ Metric.ball z ε, ∀ t ∈ Set.Ioi 0, ‖binet_deriv_integrand w t‖ ≤ bound t := by
    exact?

/-
Pointwise bound for the derivative of the integrand.
-/
lemma binet_deriv_integrand_bound_pointwise {z : ℂ} {c ε : ℝ}
    (hc : 0 < c)
    (h_lower : ∀ w ∈ Metric.ball z ε, ∀ t : ℝ, c * (1 + t ^ 2) ≤ ‖w ^ 2 + (t : ℂ) ^ 2‖)
    {w : ℂ} (hw : w ∈ Metric.ball z ε) {t : ℝ} (ht : 0 < t) :
    ‖binet_deriv_integrand w t‖ ≤ (t / (c * (1 + t ^ 2))) * (1 / (Real.exp (2 * Real.pi * t) - 1)) := by
      -- By definition of the derivative integrand, we have:
      have h_deriv_integrand : ‖binet_deriv_integrand w t‖ = t / ‖w ^ 2 + (t : ℂ) ^ 2‖ / (Real.exp (2 * Real.pi * t) - 1) := by
        unfold binet_deriv_integrand;
        norm_num [ abs_of_pos ht, abs_of_pos ( show 0 < Real.exp ( 2 * Real.pi * t ) - 1 from by norm_num; positivity ) ];
        norm_num [ Complex.norm_def, Complex.normSq, Complex.exp_re, Complex.exp_im ];
        rw [ Real.sqrt_mul_self ( sub_nonneg_of_le ( Real.one_le_exp ( by positivity ) ) ) ];
      rw [ h_deriv_integrand, div_mul_div_comm ];
      field_simp;
      rw [ div_le_div_iff₀ ] <;> nlinarith [ h_lower w hw t, show 0 < Real.exp ( t * 2 * Real.pi ) - 1 from by norm_num; positivity, show 0 < c * ( 1 + t ^ 2 ) from by positivity ]

/-
The Binet integral definition.
-/
noncomputable def binetIntegral (z : ℂ) : ℂ :=
  2 * ∫ t in Set.Ioi (0 : ℝ), binet_integrand z t

/-
Inequality for the derivative bound.
-/
lemma binet_deriv_bound_ineq (z : ℂ) (c : ℝ) (hc : 0 < c) (w : ℂ) (t : ℝ) (ht : 0 < t)
    (h_lower : c * (1 + t ^ 2) ≤ ‖w ^ 2 + (t : ℂ) ^ 2‖) :
    ‖binet_deriv_integrand w t‖ ≤ (t / (c * (1 + t ^ 2))) * (1 / (Real.exp (2 * Real.pi * t) - 1)) := by
      unfold binet_deriv_integrand;
      norm_num [ div_eq_mul_inv ];
      rw [ abs_of_pos ht ] ; gcongr;
      · rw [ ← mul_inv, inv_le_inv₀ ] <;> nlinarith;
      · exact sub_pos_of_lt ( by norm_num; positivity );
      · norm_num [ Complex.norm_def, Complex.normSq, Complex.exp_re, Complex.exp_im ];
        rw [ Real.sqrt_mul_self ] <;> linarith [ Real.add_one_le_exp ( 2 * Real.pi * t ), Real.pi_pos, mul_pos Real.pi_pos ht ]