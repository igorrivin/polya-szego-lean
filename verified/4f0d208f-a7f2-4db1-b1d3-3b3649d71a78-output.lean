/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 4f0d208f-a7f2-4db1-b1d3-3b3649d71a78
-/

/-
We formalized Polya-Szego Problem 122.1 as `problem_122_1`. The problem asks for the most general function $f$ such that the mean value of $f$ on any interval $[u, v] \subseteq [a, b]$ is the arithmetic mean of the values at the endpoints. We proved that this condition holds if and only if $f$ is a linear function $f(x) = \alpha x + \beta$. The formalization assumes $f$ is integrable on every subinterval and bounded.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

theorem problem_122_1 {a b : ℝ} (hab : a ≤ b) {f : ℝ → ℝ}
    (hf_int : ∀ u v, a ≤ u → v ≤ b → IntervalIntegrable f MeasureTheory.volume u v)
    (hf_bdd : BddAbove (Set.range f) ∧ BddBelow (Set.range f)) :
    (∀ u v, a ≤ u → v ≤ b → u < v →
        (1 / (v - u)) * ∫ x in u..v, f x = ((f u) + (f v)) / 2) ↔
    ∃ (α β : ℝ), ∀ x, a ≤ x → x ≤ b → f x = α * x + β := by
  -- Let's first show that if the given condition holds, then $f$ is a linear function.
  apply Iff.intro
  intro h_cond
  obtain ⟨α, β, h_linear⟩ : ∃ α β : ℝ, ∀ x ∈ Set.Icc a b, f x = α * x + β := by
    -- To show that $f$ is linear, we can use the fact that the integral of $f$ over $[u, v]$ is equal to $\frac{f(u) + f(v)}{2}$ for any $u < v$.
    have h_linear : ∀ u v w : ℝ, a ≤ u → u < v → v < w → w ≤ b → (f u - f v) / (u - v) = (f v - f w) / (v - w) := by
      intros u v w hu hv hw hb
      have h_eq : ∫ x in u..v, f x = ((f u + f v) / 2) * (v - u) ∧ ∫ x in v..w, f x = ((f v + f w) / 2) * (w - v) ∧ ∫ x in u..w, f x = ((f u + f w) / 2) * (w - u) := by
        exact ⟨ by rw [ ← h_cond u v hu ( by linarith ) hv, one_div, inv_mul_eq_div, div_mul_cancel₀ _ ( by linarith ) ], by rw [ ← h_cond v w ( by linarith ) hb hw, one_div, inv_mul_eq_div, div_mul_cancel₀ _ ( by linarith ) ], by rw [ ← h_cond u w hu hb ( by linarith ), one_div, inv_mul_eq_div, div_mul_cancel₀ _ ( by linarith ) ] ⟩;
      have h_eq_integral : ∫ x in u..w, f x = (∫ x in u..v, f x) + (∫ x in v..w, f x) := by
        rw [ intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ hf_int ] <;> linarith;
      rw [ div_eq_div_iff ] <;> nlinarith;
    -- Let's choose any two points $u$ and $v$ in $[a, b]$ such that $u < v$.
    obtain ⟨α, hα⟩ : ∃ α : ℝ, ∀ u v : ℝ, a ≤ u → u < v → v ≤ b → f v - f u = α * (v - u) := by
      -- By choosing any two initial points, say $u$ and $v$, and using $h_linear$, we can show that the ratio $(f u - f v) / (u - v)$ is constant for all $u$ and $v$ in $[a, b]$.
      obtain ⟨α, hα⟩ : ∃ α : ℝ, ∀ u v : ℝ, a ≤ u → u < v → v ≤ b → (f u - f v) / (u - v) = α := by
        use ( f a - f b ) / ( a - b ) ; intro u v hu hv hb; rcases eq_or_lt_of_le hu with rfl | hu' <;> rcases eq_or_lt_of_le hb with rfl | hb' <;> norm_num at *;
        · have := h_linear a v b ( by linarith ) ( by linarith ) ( by linarith ) ( by linarith ) ; rw [ div_eq_div_iff ] at * <;> nlinarith;
        · have := h_linear a u v ( by linarith ) hu' hv ( by linarith ) ; rw [ div_eq_div_iff ] at * <;> nlinarith;
        · have := h_linear a u v ( by linarith ) hu' hv ( by linarith ) ; have := h_linear u v b ( by linarith ) hv hb' ( by linarith ) ; rw [ div_eq_div_iff ] at * <;> nlinarith;
      exact ⟨ α, fun u v hu hv hb => by have := hα u v hu hv hb; rw [ div_eq_iff ( by linarith ) ] at this; linarith ⟩;
    exact ⟨ α, f a - α * a, fun x hx => by obtain hx' | rfl | hx' := lt_trichotomy x a <;> first | linarith | have := hα _ _ ( by linarith [ hx.1 ] ) hx' ( by linarith [ hx.2 ] ) ; linarith ⟩
  use α, β
  intro x hx
  aesop;
  -- Assume there exist α and β such that f(x) = αx + β for all x in [a, b].
  intro h
  obtain ⟨α, β, h_eq⟩ := h;
  intro u v hu hv huv; rw [ intervalIntegral.integral_congr fun x hx => h_eq x ( by linarith [ Set.mem_Icc.mp ( by simpa [ huv.le ] using hx ) ] ) ( by linarith [ Set.mem_Icc.mp ( by simpa [ huv.le ] using hx ) ] ) ] ; norm_num [ mul_comm α ] ; ring;
  rw [ h_eq u hu ( by linarith ), h_eq v ( by linarith ) hv ] ; nlinarith [ inv_mul_cancel_left₀ ( by linarith : ( v - u ) ≠ 0 ) β, inv_mul_cancel_left₀ ( by linarith : ( v - u ) ≠ 0 ) α ]