/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 45ab805a-06fb-463a-b2b4-33d8ef10c65e
-/

/-
We formalized Polya-Szego Problem 16, which states that a polynomial of the form z^n - p_1 z^{n-1} - ... - p_n with non-negative coefficients p_i and positive sum has exactly one positive zero. We defined the polynomial `poly_problem_16` and proved the theorem `problem_16` showing the existence and uniqueness of a positive root.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of the polynomial P(z) = z^n - p_1 z^{n-1} - ... - p_n.
-/
noncomputable def poly_problem_16 (n : ℕ) (p : ℕ → ℝ) : Polynomial ℝ :=
  Polynomial.monomial n 1 - ∑ i ∈ Finset.Icc 1 n, Polynomial.monomial (n - i) (p i)

/-
Polya-Szego Problem 16: A polynomial of the form z^n - p_1 z^{n-1} - ... - p_n with non-negative coefficients and positive sum has exactly one positive zero.
-/
theorem problem_16 (n : ℕ) (p : ℕ → ℝ) (hp_nonneg : ∀ i, 1 ≤ i → i ≤ n → p i ≥ 0)
    (hp_sum_pos : ∑ i ∈ Finset.Icc 1 n, p i > 0) :
    ∃! (ζ : ℝ), ζ > 0 ∧ (poly_problem_16 n p).eval ζ = 0 := by
  -- Let's define the polynomial in a more convenient form.
  have h_poly_def : poly_problem_16 n p = Polynomial.X^n - ∑ i ∈ Finset.Icc 1 n, Polynomial.monomial (n - i) (p i) := by
    unfold poly_problem_16; norm_num [ ← Polynomial.C_mul_X_pow_eq_monomial ] ;
  -- We want to show that the polynomial has exactly one positive root. Let's first prove that there is at least one positive root.
  have h_exists_pos_root : ∃ ζ : ℝ, ζ > 0 ∧ (ζ ^ n - ∑ i ∈ Finset.Icc 1 n, p i * ζ ^ (n - i)) = 0 := by
    -- We can divide both sides by $\zeta^n$ to get $1 = \sum_{i=1}^n \frac{p_i}{\zeta^i}$.
    suffices h_div : ∃ ζ : ℝ, ζ > 0 ∧ 1 = ∑ i ∈ Finset.Icc 1 n, p i / ζ^i by
      obtain ⟨ ζ, hζ_pos, hζ ⟩ := h_div; use ζ; refine' ( And.intro hζ_pos <| _ ) ; simp_all +decide [ sub_eq_zero, Finset.sum_div _ _ _ ] ;
      convert congr_arg ( fun x : ℝ => ζ ^ n * x ) hζ.symm using 1;
      · rw [ ← hζ, mul_one ];
      · rw [ hζ, Finset.mul_sum _ _ _ ];
        exact Finset.sum_congr rfl fun i hi => by rw [ mul_div, eq_div_iff ( pow_ne_zero _ hζ_pos.ne' ) ] ; rw [ mul_assoc, ← pow_add, Nat.sub_add_cancel ( Finset.mem_Icc.mp hi |>.2 ) ] ; ring;
    -- Define $f(x) = \sum_{i=1}^n \frac{p_i}{x^i}$. We need to show that $f(x) = 1$ has a solution for $x > 0$.
    set f : ℝ → ℝ := fun x => ∑ i ∈ Finset.Icc 1 n, p i / x^i;
    have hf_cont : ContinuousOn f (Set.Ioi 0) := by
      exact continuousOn_of_forall_continuousAt fun x hx => tendsto_finset_sum _ fun i hi => ContinuousAt.div continuousAt_const ( continuousAt_id.pow i ) ( pow_ne_zero _ hx.out.ne' );
    have hf_lim_zero : Filter.Tendsto f (nhdsWithin 0 (Set.Ioi 0)) Filter.atTop := by
      -- Since $p_i \geq 0$ and $\sum_{i=1}^n p_i > 0$, there exists some $i$ such that $p_i > 0$.
      obtain ⟨i, hi⟩ : ∃ i ∈ Finset.Icc 1 n, p i > 0 := by
        exact Exists.elim ( Finset.exists_ne_zero_of_sum_ne_zero hp_sum_pos.ne' ) fun i hi => ⟨ i, hi.1, lt_of_le_of_ne ( hp_nonneg i ( Finset.mem_Icc.mp hi.1 |>.1 ) ( Finset.mem_Icc.mp hi.1 |>.2 ) ) ( Ne.symm hi.2 ) ⟩;
      have hf_lim_zero : Filter.Tendsto (fun x : ℝ => p i / x^i) (nhdsWithin 0 (Set.Ioi 0)) Filter.atTop := by
        exact Filter.Tendsto.const_mul_atTop hi.2 ( by exact Filter.Tendsto.inv_tendsto_nhdsGT_zero <| by exact Filter.Tendsto.inf ( Continuous.tendsto' ( by continuity ) _ _ <| by aesop ) <| Filter.tendsto_principal_principal.mpr <| by aesop );
      refine' Filter.tendsto_atTop_mono' _ _ hf_lim_zero;
      filter_upwards [ self_mem_nhdsWithin ] with x hx using Finset.single_le_sum ( fun i _ => div_nonneg ( hp_nonneg i ( Finset.mem_Icc.mp ‹_› |>.1 ) ( Finset.mem_Icc.mp ‹_› |>.2 ) ) ( pow_nonneg hx.out.le _ ) ) hi.1 |> le_trans ( by aesop );
    have hf_lim_inf : Filter.Tendsto f Filter.atTop (nhds 0) := by
      exact le_trans ( tendsto_finset_sum _ fun i hi => tendsto_const_nhds.div_atTop <| Filter.tendsto_pow_atTop <| by linarith [ Finset.mem_Icc.mp hi ] ) <| by norm_num;;
    have hf_exists : ∃ x ∈ Set.Ioi 0, f x = 1 := by
      have hf_exists : ∃ x ∈ Set.Ioi 0, f x > 1 := by
        have := hf_lim_zero.eventually_gt_atTop 1; have := this.and self_mem_nhdsWithin; obtain ⟨ x, hx₁, hx₂ ⟩ := this.exists; exact ⟨ x, hx₂, hx₁ ⟩ ;
      have hf_exists : ∃ x ∈ Set.Ioi 0, f x < 1 := by
        have := hf_lim_inf.eventually ( gt_mem_nhds zero_lt_one ) ; have := this.and ( Filter.eventually_gt_atTop 0 ) ; obtain ⟨ x, hx₁, hx₂ ⟩ := this.exists; exact ⟨ x, hx₂, hx₁ ⟩ ;
      have hf_exists : IsConnected (f '' Set.Ioi 0) := by
        exact ⟨ Set.Nonempty.image _ ⟨ 1, by norm_num ⟩, isPreconnected_Ioi.image _ hf_cont ⟩;
      exact hf_exists.Icc_subset ( Set.mem_image_of_mem f <| Classical.choose_spec ( ‹∃ x ∈ Set.Ioi 0, f x < 1› ) |>.1 ) ( Set.mem_image_of_mem f <| Classical.choose_spec ( ‹∃ x ∈ Set.Ioi 0, f x > 1› ) |>.1 ) ⟨ by linarith [ Classical.choose_spec ( ‹∃ x ∈ Set.Ioi 0, f x < 1› ) |>.2 ], by linarith [ Classical.choose_spec ( ‹∃ x ∈ Set.Ioi 0, f x > 1› ) |>.2 ] ⟩;
    grind;
  -- Let's now show that there is at most one positive root.
  have h_unique_pos_root : ∀ ζ₁ ζ₂ : ℝ, ζ₁ > 0 → ζ₂ > 0 → (ζ₁ ^ n - ∑ i ∈ Finset.Icc 1 n, p i * ζ₁ ^ (n - i)) = 0 → (ζ₂ ^ n - ∑ i ∈ Finset.Icc 1 n, p i * ζ₂ ^ (n - i)) = 0 → ζ₁ = ζ₂ := by
    -- We can divide both sides of the equation by $\zeta^n$ to simplify it to $1 = \sum_{i=1}^n \frac{p_i}{\zeta^i}$.
    intro ζ₁ ζ₂ hζ₁ hζ₂ h_eq₁ h_eq₂
    have h_div : 1 = ∑ i ∈ Finset.Icc 1 n, p i / ζ₁ ^ i ∧ 1 = ∑ i ∈ Finset.Icc 1 n, p i / ζ₂ ^ i := by
      have h_div : 1 = (∑ i ∈ Finset.Icc 1 n, p i * ζ₁ ^ (n - i)) / ζ₁ ^ n ∧ 1 = (∑ i ∈ Finset.Icc 1 n, p i * ζ₂ ^ (n - i)) / ζ₂ ^ n := by
        exact ⟨ by rw [ eq_div_iff ( pow_ne_zero _ hζ₁.ne' ) ] ; linarith, by rw [ eq_div_iff ( pow_ne_zero _ hζ₂.ne' ) ] ; linarith ⟩;
      convert h_div using 2;
      · rw [ Finset.sum_div _ _ _ ] ; refine' Finset.sum_congr rfl fun i hi => _ ; rw [ div_eq_div_iff ] <;> first | positivity | ring;
        rw [ mul_assoc, ← pow_add, Nat.sub_add_cancel ( Finset.mem_Icc.mp hi |>.2 ) ];
      · rw [ Finset.sum_div _ _ _ ] ; refine' Finset.sum_congr rfl fun i hi => _ ; rw [ div_eq_div_iff ] <;> first | positivity | ring;
        rw [ mul_assoc, ← pow_add, Nat.sub_add_cancel ( Finset.mem_Icc.mp hi |>.2 ) ];
    by_contra h_neq;
    -- Without loss of generality, assume $\zeta_1 < \zeta_2$.
    wlog h_wlog : ζ₁ < ζ₂ generalizing ζ₁ ζ₂;
    · exact this ζ₂ ζ₁ hζ₂ hζ₁ h_eq₂ h_eq₁ ⟨ h_div.2, h_div.1 ⟩ ( Ne.symm h_neq ) ( lt_of_le_of_ne ( le_of_not_gt h_wlog ) ( Ne.symm h_neq ) );
    · -- Since $\zeta_1 < \zeta_2$, we have $\frac{p_i}{\zeta_1^i} > \frac{p_i}{\zeta_2^i}$ for all $i$.
      have h_frac_gt : ∀ i ∈ Finset.Icc 1 n, p i / ζ₁ ^ i ≥ p i / ζ₂ ^ i := by
        field_simp;
        exact fun i hi => mul_le_mul_of_nonneg_left ( pow_le_pow_left₀ hζ₁.le h_wlog.le _ ) ( hp_nonneg i ( Finset.mem_Icc.mp hi |>.1 ) ( Finset.mem_Icc.mp hi |>.2 ) );
      -- Since $\zeta_1 < \zeta_2$, there exists some $i$ such that $p_i > 0$ and $\frac{p_i}{\zeta_1^i} > \frac{p_i}{\zeta_2^i}$.
      obtain ⟨i, hi₁, hi₂⟩ : ∃ i ∈ Finset.Icc 1 n, p i > 0 ∧ p i / ζ₁ ^ i > p i / ζ₂ ^ i := by
        obtain ⟨i, hi₁, hi₂⟩ : ∃ i ∈ Finset.Icc 1 n, p i > 0 := by
          exact Exists.elim ( Finset.exists_ne_zero_of_sum_ne_zero hp_sum_pos.ne' ) fun i hi => ⟨ i, hi.1, lt_of_le_of_ne ( hp_nonneg i ( Finset.mem_Icc.mp hi.1 |>.1 ) ( Finset.mem_Icc.mp hi.1 |>.2 ) ) ( Ne.symm hi.2 ) ⟩;
        exact ⟨ i, hi₁, hi₂, div_lt_div_of_pos_left hi₂ ( pow_pos hζ₁ _ ) ( pow_lt_pow_left₀ h_wlog ( by positivity ) ( by linarith [ Finset.mem_Icc.mp hi₁ ] ) ) ⟩;
      exact absurd ( Finset.sum_lt_sum ( fun x hx => h_frac_gt x hx ) ⟨ i, hi₁, hi₂.2 ⟩ ) ( by norm_num [ ← h_div.1, ← h_div.2 ] );
  obtain ⟨ ζ, hζ₁, hζ₂ ⟩ := h_exists_pos_root;
  exact ⟨ ζ, ⟨ hζ₁, by simpa [ h_poly_def, Polynomial.eval_finset_sum ] using hζ₂ ⟩, fun x hx => h_unique_pos_root x ζ hx.1 hζ₁ ( by simpa [ h_poly_def, Polynomial.eval_finset_sum ] using hx.2 ) hζ₂ ⟩