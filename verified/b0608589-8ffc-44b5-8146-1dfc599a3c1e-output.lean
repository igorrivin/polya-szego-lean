/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b0608589-8ffc-44b5-8146-1dfc599a3c1e
-/

/-
Formalization of Polya-Szego Problem 137.

We prove that if a continuous function f on [a, b] (with a < b) has all its moments vanishing, i.e., ∫_a^b f(t) * t^n dt = 0 for all n : ℕ, then f is identically zero on [a, b].

The proof uses the Weierstrass approximation theorem to show that the integral of f^2 is zero, which implies f is zero since it is continuous.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check exists_polynomial_near_of_continuousOn

/-
If f is continuous on [a, b] (with a < b) and all its moments vanish (i.e., ∫_a^b f(t) * t^n dt = 0 for all n : ℕ), then f is identically zero on [a, b].
-/
theorem problem_137 {a b : ℝ} (hab : a < b) {f : ℝ → ℝ}
    (hf_cont : ContinuousOn f (Set.Icc a b))
    (h_moments : ∀ (n : ℕ), ∫ t in a..b, f t * t ^ n = 0) :
    ∀ x ∈ Set.Icc a b, f x = 0 := by
  -- First show that the integral of $f(t) \cdot p(t)$ is zero for any polynomial $p$.
  have h_poly_int_zero : ∀ p : Polynomial ℝ, (∫ t in a..b, (f t) * (p.eval t)) = 0 := by
    simp_all +decide [ Polynomial.eval_eq_sum_range ];
    intro p; simp +decide [ Finset.mul_sum _ _ _, mul_assoc, mul_left_comm, ← intervalIntegral.integral_const_mul, h_moments ] ;
    rw [ intervalIntegral.integral_finset_sum ];
    · exact Finset.sum_eq_zero fun i hi => by simpa [ mul_assoc, mul_left_comm, ← intervalIntegral.integral_const_mul ] using mul_eq_zero_of_right ( p.coeff i ) ( h_moments i ) ;
    · intro i hi; apply_rules [ ContinuousOn.intervalIntegrable ];
      simpa only [ Set.uIcc_of_le hab.le ] using hf_cont.mul ( continuousOn_const.mul ( continuousOn_pow i ) );
  -- By the properties of the integral, if ∫ t in a..b, f t * f t = 0, then f must be zero almost everywhere on [a, b].
  have h_f_zero_ae : ∫ t in a..b, (f t) ^ 2 = 0 := by
    -- By the Weierstrass approximation theorem, there exists a sequence of polynomials $p_n$ that converges uniformly to $f$ on $[a, b]$.
    obtain ⟨p_n, hp_n⟩ : ∃ p_n : ℕ → Polynomial ℝ, (∀ n, ∀ t ∈ Set.Icc a b, |(p_n n).eval t - f t| < 1 / (n + 1)) := by
      have h_weierstrass : ∀ ε > 0, ∃ p : Polynomial ℝ, ∀ t ∈ Set.Icc a b, |p.eval t - f t| < ε := by
        apply_rules [ exists_polynomial_near_of_continuousOn, hf_cont ];
      exact ⟨ fun n => Classical.choose ( h_weierstrass _ <| by positivity ), fun n => Classical.choose_spec ( h_weierstrass _ <| by positivity ) ⟩;
    -- Since $p_n$ converges uniformly to $f$ on $[a, b]$, we have $\int_a^b f(t) p_n(t) dt \to \int_a^b f(t)^2 dt$ as $n \to \infty$.
    have h_integral_converge : Filter.Tendsto (fun n => ∫ t in a..b, (f t) * ((p_n n).eval t)) Filter.atTop (nhds (∫ t in a..b, (f t) ^ 2)) := by
      refine' intervalIntegral.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _;
      use fun x => |f x| * ( |f x| + 1 );
      · exact Filter.Eventually.of_forall fun n => ContinuousOn.aestronglyMeasurable ( hf_cont.mul ( Polynomial.continuousOn _ ) ) measurableSet_Icc |> fun h => h.mono_set <| by rw [ Set.uIoc_of_le hab.le ] ; exact Set.Ioc_subset_Icc_self;
      · simp +zetaDelta at *;
        exact ⟨ 1, fun n hn => Filter.Eventually.of_forall fun x hx => mul_le_mul_of_nonneg_left ( by cases abs_cases ( f x ) <;> cases abs_cases ( Polynomial.eval x ( p_n n ) ) <;> nlinarith [ abs_lt.mp ( hp_n n x ( by cases Set.mem_uIoc.mp hx <;> linarith ) ( by cases Set.mem_uIoc.mp hx <;> linarith ) ), inv_le_one_of_one_le₀ ( by linarith : ( n : ℝ ) + 1 ≥ 1 ) ] ) ( abs_nonneg _ ) ⟩;
      · apply_rules [ ContinuousOn.intervalIntegrable ];
        simpa only [ Set.uIcc_of_le hab.le ] using ContinuousOn.mul ( hf_cont.abs ) ( hf_cont.abs.add continuousOn_const );
      · filter_upwards [ ] with x hx using by simpa [ sq ] using tendsto_const_nhds.mul ( tendsto_iff_norm_sub_tendsto_zero.mpr <| squeeze_zero ( fun _ => by positivity ) ( fun n => le_of_lt <| hp_n n x <| by constructor <;> cases Set.mem_uIoc.mp hx <;> linarith ) <| tendsto_one_div_add_atTop_nhds_zero_nat ) ;
    exact tendsto_nhds_unique h_integral_converge ( by simpa only [ h_poly_int_zero ] using tendsto_const_nhds );
  intro x hx;
  contrapose! h_f_zero_ae;
  -- Since $f$ is continuous and $f(x) \neq 0$, there exists an interval $(c, d) \subseteq [a, b]$ around $x$ where $f(t) \neq 0$ for all $t \in (c, d)$.
  obtain ⟨c, d, hc, hd, hcd⟩ : ∃ c d : ℝ, a ≤ c ∧ c < d ∧ d ≤ b ∧ ∀ t ∈ Set.Ioo c d, f t ≠ 0 := by
    simp +zetaDelta at *;
    have := Metric.continuousOn_iff.mp hf_cont x hx;
    obtain ⟨ δ, δ_pos, H ⟩ := this ( |f x| ) ( abs_pos.mpr h_f_zero_ae );
    exact ⟨ Max.max a ( x - δ / 2 ), by norm_num, Min.min b ( x + δ / 2 ), by cases max_cases a ( x - δ / 2 ) <;> cases min_cases b ( x + δ / 2 ) <;> linarith, by cases max_cases a ( x - δ / 2 ) <;> cases min_cases b ( x + δ / 2 ) <;> linarith, fun t ht₁ ht₂ => by cases abs_cases ( f x ) <;> linarith [ abs_lt.mp ( H t ⟨ by cases max_cases a ( x - δ / 2 ) <;> linarith, by cases min_cases b ( x + δ / 2 ) <;> linarith ⟩ ( abs_lt.mpr ⟨ by cases max_cases a ( x - δ / 2 ) <;> linarith, by cases min_cases b ( x + δ / 2 ) <;> linarith ⟩ ) ) ] ⟩;
  -- Since $f(t) \neq 0$ on $(c, d)$, we have $\int_c^d f(t)^2 dt > 0$.
  have h_int_pos : 0 < ∫ t in c..d, (f t) ^ 2 := by
    rw [ intervalIntegral.integral_of_le ( by linarith ), MeasureTheory.integral_pos_iff_support_of_nonneg_ae ];
    · simp_all +decide [ Function.support ];
      exact lt_of_lt_of_le ( by aesop ) ( MeasureTheory.measure_mono <| show Set.Ioo c d ⊆ { x | ¬f x = 0 } ∩ Set.Ioc c d from fun x hx => ⟨ hcd.2 x hx.1 hx.2, ⟨ hx.1, hx.2.le ⟩ ⟩ );
    · exact Filter.Eventually.of_forall fun x => sq_nonneg _;
    · exact ContinuousOn.integrableOn_Icc ( by exact ContinuousOn.pow ( hf_cont.mono ( Set.Icc_subset_Icc ( by linarith ) ( by linarith ) ) ) _ ) |> fun h => h.mono_set ( Set.Ioc_subset_Icc_self );
  refine' ne_of_gt ( lt_of_lt_of_le h_int_pos _ );
  apply_rules [ intervalIntegral.integral_mono_interval ];
  · linarith;
  · linarith;
  · exact Filter.Eventually.of_forall fun x => sq_nonneg _;
  · apply_rules [ ContinuousOn.intervalIntegrable ];
    simpa only [ Set.uIcc_of_le hab.le ] using hf_cont.pow 2