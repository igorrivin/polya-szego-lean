/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 32a2c632-b173-4344-837d-7a3ee7f4f67f
-/

/-
We formalize and prove Polya-Szego Problem 17 from Part Three, Chapter 1.
The problem states that if $z_0$ is a zero of $P(z) = z^n + a_1 z^{n-1} + \dots + a_n$, then $|z_0| \le \zeta$, where $\zeta$ is the unique positive zero of $Q(z) = z^n - |a_1| z^{n-1} - \dots - |a_n|$.

We define the real polynomial `Q_real` corresponding to $Q(z)$ and show it has a unique positive root $\zeta$ (assuming not all $a_k$ are zero).
We then prove the main inequality $|z_0| \le \zeta$ by showing that $Q(|z_0|) \le 0$ and using the monotonicity of the related function $f(x) = \sum |a_k| x^{-k}$.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Complex.re
#check (norm : ℂ → ℝ)

#check Polynomial.monomial
#check Polynomial.eval
#check Finset.Icc
#check Polynomial.C

/-
Define the real polynomial Q(x) = x^n - sum_{k=1}^n |a_k| x^{n-k}.
-/
open Polynomial Finset

def Q_real (n : ℕ) (a : ℕ → ℂ) (x : ℝ) : ℝ :=
  x^n - ∑ k ∈ Icc 1 n, norm (a k) * x^(n - k)

/-
The real polynomial Q_real evaluated at x is equal to the real part of the corresponding complex polynomial evaluated at x (viewed as a complex number).
-/
open Polynomial Finset

theorem Q_real_eq_eval (n : ℕ) (a : ℕ → ℂ) (x : ℝ) :
    Q_real n a x = ((monomial n (1 : ℂ) - ∑ k ∈ Icc 1 n, C (norm (a k) : ℂ) * monomial (n - k) 1).eval (x : ℂ)).re := by
  norm_num [ Q_real, Polynomial.eval_finset_sum ];
  norm_cast

/-
If there is at least one non-zero coefficient, the polynomial Q_real has exactly one positive root.
-/
open Polynomial Finset

theorem exists_unique_pos_root (n : ℕ) (hn : n ≥ 1) (a : ℕ → ℂ) (h_nonzero : ∃ k ∈ Icc 1 n, a k ≠ 0) :
    ∃! ζ, ζ > 0 ∧ Q_real n a ζ = 0 := by
  -- Let's define the function $f(x) = \sum_{k=1}^n |a_k| x^{-k}$ and show it is strictly decreasing on $(0, \infty)$.
  set f : ℝ → ℝ := fun x => ∑ k ∈ Finset.Icc 1 n, norm (a k) * x⁻¹^k
  have h_f_decreasing : StrictAntiOn f (Set.Ioi 0) := by
    simp +zetaDelta at *;
    refine' fun x hx y hy hxy => Finset.sum_lt_sum _ _;
    · exact fun i hi => mul_le_mul_of_nonneg_left ( inv_anti₀ ( pow_pos hx _ ) ( pow_le_pow_left₀ hx.out.le hxy.le _ ) ) ( norm_nonneg _ );
    · exact ⟨ h_nonzero.choose, Finset.mem_Icc.mpr h_nonzero.choose_spec.1, mul_lt_mul_of_pos_left ( inv_strictAnti₀ ( pow_pos hx.out _ ) ( pow_lt_pow_left₀ hxy ( le_of_lt hx.out ) ( by linarith [ h_nonzero.choose_spec.1 ] ) ) ) ( norm_pos_iff.mpr h_nonzero.choose_spec.2 ) ⟩;
  -- By the properties of $f$, we know that $f(x) \to \infty$ as $x \to 0^+$ and $f(x) \to 0$ as $x \to \infty$.
  have h_f_tendsto_infty : Filter.Tendsto f (nhdsWithin 0 (Set.Ioi 0)) Filter.atTop := by
    -- Since $|a_k| > 0$ for some $k$, we can choose such a $k$ and show that $f(x) \geq |a_k| x^{-k}$ for all $x > 0$.
    obtain ⟨k, hk₁, hk₂⟩ : ∃ k ∈ Finset.Icc 1 n, a k ≠ 0 := h_nonzero
    have h_f_ge : ∀ x > 0, f x ≥ norm (a k) * x⁻¹^k := by
      exact fun x x_pos => Finset.single_le_sum ( fun k _ => mul_nonneg ( norm_nonneg ( a k ) ) ( pow_nonneg ( inv_nonneg.2 x_pos.le ) k ) ) hk₁;
    -- Since $x^{-k} \to \infty$ as $x \to 0^+$, it follows that $f(x) \geq |a_k| x^{-k} \to \infty$ as $x \to 0^+$.
    have h_f_inv_k_tendsto_infty : Filter.Tendsto (fun x : ℝ => x⁻¹^k) (nhdsWithin 0 (Set.Ioi 0)) Filter.atTop := by
      exact Filter.Tendsto.comp ( Filter.tendsto_pow_atTop ( by linarith [ Finset.mem_Icc.mp hk₁ ] ) ) ( tendsto_inv_nhdsGT_zero );
    exact Filter.tendsto_atTop.mpr fun x => by filter_upwards [ h_f_inv_k_tendsto_infty.eventually_gt_atTop ( x / ‖a k‖ ), self_mem_nhdsWithin ] with y hy₁ hy₂ using by nlinarith [ h_f_ge y hy₂, norm_pos_iff.mpr hk₂, mul_div_cancel₀ x ( norm_ne_zero_iff.mpr hk₂ ) ] ;
  have h_f_tendsto_zero : Filter.Tendsto f Filter.atTop (nhds 0) := by
    -- Each term $|a_k| x^{-k}$ tends to $0$ as $x \to \infty$.
    have h_term_tendsto_zero : ∀ k ∈ Finset.Icc 1 n, Filter.Tendsto (fun x : ℝ => norm (a k) * x⁻¹^k) Filter.atTop (nhds 0) := by
      intro k hk; exact le_trans ( Filter.Tendsto.mul tendsto_const_nhds ( Filter.Tendsto.pow ( tendsto_inv_atTop_zero ) _ ) ) ( by aesop ) ;
    simpa only [ Finset.sum_const_zero ] using tendsto_finset_sum _ h_term_tendsto_zero;
  -- By the properties of $f$, we know that there exists a unique $\zeta > 0$ such that $f(\zeta) = 1$.
  obtain ⟨ζ, hζ_pos, hζ_unique⟩ : ∃! ζ : ℝ, ζ > 0 ∧ f ζ = 1 := by
    -- By the properties of $f$, we know that there exists a $\zeta > 0$ such that $f(\zeta) = 1$.
    obtain ⟨ζ, hζ_pos, hζ_eq⟩ : ∃ ζ : ℝ, ζ > 0 ∧ f ζ = 1 := by
      have h_ivt : ∀ {y : ℝ}, 0 < y → ∃ x ∈ Set.Ioi 0, f x = y := by
        intro y hy
        have h_exists_gt : ∃ x ∈ Set.Ioi 0, f x > y := by
          have := h_f_tendsto_infty.eventually_gt_atTop y; have := this.and self_mem_nhdsWithin; obtain ⟨ x, hx₁, hx₂ ⟩ := this.exists; exact ⟨ x, hx₂, hx₁ ⟩ ;
        have h_exists_lt : ∃ x ∈ Set.Ioi 0, f x < y := by
          have := h_f_tendsto_zero.eventually ( gt_mem_nhds hy ) ; have := this.and ( Filter.eventually_gt_atTop 0 ) ; obtain ⟨ x, hx₁, hx₂ ⟩ := this.exists; exact ⟨ x, hx₂, hx₁ ⟩ ;
        have h_ivt : IsConnected (f '' Set.Ioi 0) := by
          exact ⟨ Set.Nonempty.image _ ⟨ 1, by norm_num ⟩, isPreconnected_Ioi.image _ <| ContinuousOn.mono ( show ContinuousOn f ( Set.Ioi 0 ) from continuousOn_of_forall_continuousAt fun x hx => by exact tendsto_finset_sum _ fun i hi => ContinuousAt.mul ( continuousAt_const ) <| ContinuousAt.pow ( continuousAt_id.inv₀ hx.out.ne' ) _ ) <| Set.Subset.refl _ ⟩;
        exact h_ivt.Icc_subset ( Set.mem_image_of_mem f h_exists_lt.choose_spec.1 ) ( Set.mem_image_of_mem f h_exists_gt.choose_spec.1 ) ⟨ h_exists_lt.choose_spec.2.le, h_exists_gt.choose_spec.2.le ⟩;
      exact h_ivt zero_lt_one;
    exact ⟨ ζ, ⟨ hζ_pos, hζ_eq ⟩, fun x hx => StrictAntiOn.injOn h_f_decreasing hx.1 hζ_pos <| hx.2.trans hζ_eq.symm ⟩;
  -- By the properties of $Q_real$, we know that $Q_real(\zeta) = \zeta^n (1 - f(\zeta))$.
  have h_Q_real : ∀ x > 0, Q_real n a x = x^n * (1 - f x) := by
    intro x hx_pos; unfold Q_real; simp +decide [ hx_pos.ne', mul_sub, Finset.mul_sum _ _ _, mul_assoc, mul_comm, mul_left_comm, pow_add, pow_one, pow_mul, div_eq_mul_inv ] ;
    rw [ Finset.mul_sum _ _ _ ] ; refine' Finset.sum_congr rfl fun i hi => _ ; rw [ show x ^ ( n - i ) = x ^ n / x ^ i from eq_div_of_mul_eq ( pow_ne_zero _ hx_pos.ne' ) <| by rw [ ← pow_add, Nat.sub_add_cancel <| Finset.mem_Icc.mp hi |>.2 ] ] ; ring;
  use ζ;
  norm_num +zetaDelta at *;
  exact ⟨ ⟨ hζ_pos.1, by rw [ h_Q_real ζ hζ_pos.1, hζ_pos.2 ] ; ring ⟩, fun y hy hy' => hζ_unique y hy <| by rw [ h_Q_real y hy ] at hy'; exact eq_of_sub_eq_zero <| by nlinarith [ pow_pos hy n ] ⟩

/-
If z₀ is a zero of the polynomial z^n + a₁ z^{n-1} + ... + a_n, then |z₀| is not larger than the only positive zero ζ of the polynomial z^n - |a₁| z^{n-1} - ... - |a_n|.
-/
open Polynomial Finset

theorem polyaszego_17 (n : ℕ) (hn : n ≥ 1) (a : ℕ → ℂ) (z₀ : ℂ)
    (hroot : (monomial n 1 + ∑ k ∈ Icc 1 n, C (a k) * monomial (n - k) 1).eval z₀ = 0) :
    ∃ (ζ : ℝ) (hζ : ζ > 0),
    (∀ (z : ℝ), z > 0 → (monomial n (1 : ℂ) - ∑ k ∈ Icc 1 n, C (norm (a k) : ℂ) * monomial (n - k) 1).eval (z : ℂ) = 0 → z = ζ) ∧
    norm z₀ ≤ ζ := by
  by_cases h_all_zero : ∀ k ∈ Finset.Icc 1 n, ‖a k‖ = 0;
  · simp_all +decide [ Finset.sum_eq_zero, sub_eq_zero ];
    exact ⟨ 1, by intros; linarith, by norm_num, by norm_num ⟩;
  · -- Use `exists_unique_pos_root` to find ζ such that ζ > 0 and Q_real(ζ) = 0.
    obtain ⟨ζ, hζ⟩ := exists_unique_pos_root n hn a (by
    aesop);
    refine' ⟨ ζ, hζ.1.1, fun z hz h => hζ.2 z ⟨ hz, _ ⟩, _ ⟩;
    · convert congr_arg Complex.re h using 1;
      convert Q_real_eq_eval n a z using 1;
    · -- From the root equation, z_0^n = - sum a_k z_0^{n-k}.
      -- Take norms: |z_0|^n ≤ sum |a_k| |z_0|^{n-k}.
      -- So Q_real(|z_0|) ≤ 0.
      have hQ_le_zero : Q_real n a (‖z₀‖) ≤ 0 := by
        have hQ_le_zero : ‖z₀‖^n ≤ ∑ k ∈ Finset.Icc 1 n, ‖a k‖ * ‖z₀‖^(n - k) := by
          have h_abs_le : ‖z₀‖ ^ n = ‖∑ k ∈ Finset.Icc 1 n, a k * z₀ ^ (n - k)‖ := by
            norm_num [ Polynomial.eval_finset_sum ] at *;
            rw [ eq_neg_of_add_eq_zero_right hroot, norm_neg ] ; norm_num;
          exact h_abs_le.symm ▸ le_trans ( norm_sum_le _ _ ) ( Finset.sum_le_sum fun _ _ => by norm_num );
        exact sub_nonpos_of_le hQ_le_zero;
      -- We know Q_real(x) = x^n (1 - f(x)) where f(x) = sum |a_k| x^{-k}.
      -- f is strictly decreasing for x > 0.
      -- Q_real(ζ) = 0 implies f(ζ) = 1.
      -- Q_real(|z_0|) ≤ 0 implies f(|z_0|) ≥ 1 (assuming |z_0| > 0).
      -- Since f is decreasing, |z_0| ≤ ζ.
      have h_f_decreasing : ∀ x y : ℝ, 0 < x → x < y → (∑ k ∈ Finset.Icc 1 n, ‖a k‖ * x⁻¹ ^ k) > (∑ k ∈ Finset.Icc 1 n, ‖a k‖ * y⁻¹ ^ k) := by
        intros x y hx hy;
        fapply Finset.sum_lt_sum;
        · exact fun k hk => mul_le_mul_of_nonneg_left ( pow_le_pow_left₀ ( inv_nonneg.2 ( by linarith ) ) ( inv_anti₀ ( by linarith ) hy.le ) _ ) ( norm_nonneg _ );
        · simp +zetaDelta at *;
          exact ⟨ h_all_zero.choose, ⟨ h_all_zero.choose_spec.1, h_all_zero.choose_spec.2.1 ⟩, mul_lt_mul_of_pos_left ( inv_strictAnti₀ ( pow_pos hx _ ) ( pow_lt_pow_left₀ hy ( by linarith ) ( by linarith [ h_all_zero.choose_spec.1 ] ) ) ) ( norm_pos_iff.mpr h_all_zero.choose_spec.2.2 ) ⟩;
      contrapose! hQ_le_zero;
      have h_f_ge_one : ∑ k ∈ Finset.Icc 1 n, ‖a k‖ * ‖z₀‖⁻¹ ^ k < 1 := by
        have h_f_ge_one : ∑ k ∈ Finset.Icc 1 n, ‖a k‖ * ζ⁻¹ ^ k = 1 := by
          have h_f_ge_one : ζ^n - ∑ k ∈ Finset.Icc 1 n, ‖a k‖ * ζ^(n - k) = 0 := by
            exact hζ.1.2;
          have h_f_ge_one : ∑ k ∈ Finset.Icc 1 n, ‖a k‖ * ζ^(n - k) = ζ^n * ∑ k ∈ Finset.Icc 1 n, ‖a k‖ * ζ⁻¹ ^ k := by
            rw [ Finset.mul_sum _ _ _ ] ; refine' Finset.sum_congr rfl fun x hx => _ ; rw [ show ζ ^ ( n - x ) = ζ ^ n / ζ ^ x from _ ] ; ring;
            rw [ eq_div_iff ( pow_ne_zero _ hζ.1.1.ne' ), ← pow_add, Nat.sub_add_cancel ( Finset.mem_Icc.mp hx |>.2 ) ];
          nlinarith [ pow_pos hζ.1.1 n ];
        exact h_f_ge_one ▸ h_f_decreasing _ _ hζ.1.1 hQ_le_zero;
      unfold Q_real;
      -- Multiply both sides of the inequality by ‖z₀‖^n to obtain the desired result.
      have h_mul : ∑ k ∈ Finset.Icc 1 n, ‖a k‖ * ‖z₀‖ ^ (n - k) = ‖z₀‖ ^ n * ∑ k ∈ Finset.Icc 1 n, ‖a k‖ * ‖z₀‖⁻¹ ^ k := by
        rw [ Finset.mul_sum _ _ _ ] ; refine' Finset.sum_congr rfl fun x hx => _ ; rw [ show ‖z₀‖ ^ ( n - x ) = ‖z₀‖ ^ n / ‖z₀‖ ^ x from _ ] ; ring;
        rw [ eq_div_iff ( pow_ne_zero _ <| ne_of_gt <| lt_trans hζ.1.1 hQ_le_zero ), ← pow_add, Nat.sub_add_cancel <| Finset.mem_Icc.mp hx |>.2 ];
      nlinarith [ pow_pos ( show 0 < ‖z₀‖ by linarith [ hζ.1.1 ] ) n ]