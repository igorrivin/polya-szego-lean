/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 42174c91-047e-4800-be21-d4d087bdb7ec

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Set
open scoped BigOperators

open MeasureTheory MeasureTheory.Measure Set Filter Topology
open scoped Topology

#check MeasurableSet.univ
#check Measure.restrict_apply
#check volume
#check Icc
#check FiniteMeasure

/-
The target measure is the Lebesgue measure restricted to [0,1].
-/
noncomputable def target_measure : FiniteMeasure â„ :=
  âŸ¨Measure.restrict volume (Icc (0 : â„) 1), by
    -- The volume of the interval [0,1] is 1, which is finite.
    simp [MeasureTheory.isFiniteMeasure_iff]âŸ©

open MeasureTheory MeasureTheory.Measure Set Filter Topology
open scoped Topology BigOperators ENNReal

noncomputable def empirical_measure (N : â„•) (a Ïƒ : â„) : FiniteMeasure â„ :=
  if h : N = 0 then 0 else
  âŸ¨(N : â„â‰¥0âˆ)â»Â¹ â€¢ âˆ‘ n âˆˆ Finset.range N, dirac (Int.fract (a * (Real.log (n + 1)) ^ Ïƒ)), by
    have : Fact (N â‰  0) := âŸ¨hâŸ©
    rw [MeasureTheory.isFiniteMeasure_iff]
    simp only [Measure.smul_apply, Finset.sum_apply, Measure.dirac_apply, smul_eq_mul]
    -- The measure of the whole space is the sum of the measures of the whole space for each dirac measure, scaled by 1/N.
    -- Each dirac measure has total mass 1.
    -- So the sum has total mass N.
    -- Scaled by 1/N, the total mass is 1.
    -- We need to show this is less than infinity.
    -- Since $N \neq 0$, multiplying $N$ by its inverse gives $1$, which is less than infinity.
    have h_final : (N : â„â‰¥0âˆ)â»Â¹ * N = 1 := by
      -- Since $N \neq 0$, we can apply the fact that multiplication by the inverse of a non-zero element in the extended non-negative reals gives 1.
      apply ENNReal.inv_mul_cancel; exact (by
      aesop);
      exact ENNReal.natCast_ne_top _;
    aesopâŸ©

/-
Generic empirical measure for a sequence x_n.
-/
noncomputable def empirical_measure_gen (N : â„•) (x : â„• â†’ â„) : FiniteMeasure â„ :=
  if h : N = 0 then 0 else
  âŸ¨(N : â„â‰¥0âˆ)â»Â¹ â€¢ âˆ‘ n âˆˆ Finset.range N, dirac (x n), by
    have : Fact (N â‰  0) := âŸ¨hâŸ©
    rw [MeasureTheory.isFiniteMeasure_iff]
    simp only [Measure.smul_apply, Finset.sum_apply, Measure.dirac_apply, smul_eq_mul]
    have h_final : (N : â„â‰¥0âˆ)â»Â¹ * N = 1 := by
      apply ENNReal.inv_mul_cancel; exact (by aesop); exact ENNReal.natCast_ne_top _;
    aesopâŸ©

/-
The complex exponential function e(k, x) = exp(2 * pi * i * k * x).
-/
noncomputable def e (k : â„¤) (x : â„) : â„‚ := Complex.exp (2 * â†‘Real.pi * Complex.I * k * x)

/-
The integral of e(k, x) with respect to the target measure is 1 if k = 0 and 0 otherwise.
-/
lemma integral_e_target (k : â„¤) :
  âˆ« x, e k x âˆ‚(target_measure : Measure â„) = if k = 0 then 1 else 0 :=
by
  split_ifs <;> simp_all +decide [ e ];
  Â· erw [ MeasureTheory.measureReal_def ];
    erw [ MeasureTheory.Measure.restrict_apply ] <;> norm_num;
  Â· -- We'll use the fact that the integral of a complex exponential over $[0, 1]$ is zero when $k \neq 0$.
    have h_int : âˆ« x in Set.Icc (0 : â„) 1, Complex.exp (2 * Real.pi * Complex.I * k * x) = (1 / (2 * Real.pi * Complex.I * k)) * (Complex.exp (2 * Real.pi * Complex.I * k) - 1) := by
      rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, â† intervalIntegral.integral_of_le zero_le_one ];
      have := @integral_exp_mul_complex 0 1;
      simpa [ div_eq_inv_mul ] using this ( show ( 2 * Real.pi * Complex.I * k : â„‚ ) â‰  0 by norm_num [ Complex.ext_iff, Real.pi_ne_zero, * ] );
    simp_all +decide [ Complex.exp_ne_zero, mul_comm ( 2 * Real.pi * Complex.I ) ];
    exact h_int

/-
If the Weyl sums converge to 0 for all non-zero k, then they converge to the expected value for all k.
-/
lemma limit_exponential_sum_all_k (x : â„• â†’ â„)
  (h_weyl : âˆ€ k : â„¤, k â‰  0 â†’ Tendsto (fun (N : â„•) => ((N : â„‚)â»Â¹) * âˆ‘ n âˆˆ Finset.range N, e k (x n)) atTop (ğ“ 0)) :
  âˆ€ k : â„¤, Tendsto (fun (N : â„•) => ((N : â„‚)â»Â¹) * âˆ‘ n âˆˆ Finset.range N, e k (x n)) atTop (ğ“ (if k = 0 then 1 else 0)) := by
    intro k; by_cases hk : k = 0 <;> simp_all +decide [ e ] ;
    exact tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_ne_atTop 0 ] with N hN; simp +decide [ hN ] )

/-
A function f is a trigonometric polynomial if it is in the span of the exponential functions e(k, x).
-/
def IsTrigPoly (f : â„ â†’ â„‚) : Prop :=
  f âˆˆ Submodule.span â„‚ (Set.range e)

/-
Trigonometric polynomials are integrable with respect to the target measure.
-/
lemma integrable_of_isTrigPoly (f : â„ â†’ â„‚) (hf : IsTrigPoly f) :
    Integrable f target_measure := by
      induction' hf using Submodule.span_induction with f hf ih;
      Â· obtain âŸ¨ k, rfl âŸ© := hf;
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun x => 1;
        Â· simp +decide [ target_measure ];
        Â· exact Continuous.aestronglyMeasurable ( by exact Complex.continuous_exp.comp <| by continuity );
        Â· exact Filter.Eventually.of_forall fun x => by simp +decide [ e, Complex.norm_exp ] ;
      Â· exact MeasureTheory.integrable_zero _ _ _;
      Â· exact MeasureTheory.Integrable.add â€¹_â€º â€¹_â€º;
      Â· exact?

/-
If the Weyl sums converge, then the empirical integrals of any trigonometric polynomial converge to its integral against the target measure.
-/
lemma integral_trig_poly_tendsto (x : â„• â†’ â„)
    (h_weyl : âˆ€ k : â„¤, k â‰  0 â†’ Tendsto (fun (N : â„•) => ((N : â„‚)â»Â¹) * âˆ‘ n âˆˆ Finset.range N, e k (x n)) atTop (ğ“ 0))
    (f : â„ â†’ â„‚) (hf : IsTrigPoly f) :
    Tendsto (fun (N : â„•) => ((N : â„‚)â»Â¹) * âˆ‘ n âˆˆ Finset.range N, f (x n)) atTop (ğ“ (âˆ« y, f y âˆ‚target_measure)) := by
      -- By definition of IsTrigPoly, we can write f as a finite linear combination of e(k, x).
      obtain âŸ¨k, c, hcâŸ© : âˆƒ (k : Finset â„¤) (c : â„¤ â†’ â„‚), f = âˆ‘ k âˆˆ k, c k â€¢ e k := by
        have := ( Finsupp.mem_span_range_iff_exists_finsupp.mp hf );
        obtain âŸ¨ c, rfl âŸ© := this; exact âŸ¨ c.support, c, by simp +decide [ Finsupp.sum ] âŸ© ;
      -- By linearity of the integral, we can break the integral into the sum of integrals of the individual exponential terms.
      have h_integral : âˆ« y, f y âˆ‚(target_measure : Measure â„) = âˆ‘ k âˆˆ k, c k * âˆ« y, e k y âˆ‚(target_measure : Measure â„) := by
        rw [ hc, â† Finset.sum_congr rfl fun _ _ => MeasureTheory.integral_const_mul _ _ ];
        simp +zetaDelta at *;
        exact MeasureTheory.integral_finset_sum _ fun i hi => Continuous.integrableOn_Icc <| by exact Continuous.mul ( continuous_const ) <| by exact Complex.continuous_exp.comp <| by continuity;
      -- By linearity of the integral, we can break the integral into the sum of integrals of the individual exponential terms, and apply the hypothesis h_weyl to each term.
      have h_tendsto : âˆ€ k : â„¤, Filter.Tendsto (fun N : â„• => ((N : â„‚)â»Â¹) * âˆ‘ n âˆˆ Finset.range N, e k (x n)) atTop (ğ“ (if k = 0 then 1 else 0)) := by
        exact?;
      simp_all +decide [ Finset.mul_sum _ _ _, Finset.sum_mul ];
      convert tendsto_finset_sum k fun i hi => Filter.Tendsto.const_mul ( c i ) ( h_tendsto i ) using 2 ; simp +decide [ mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul ];
      Â· exact Finset.sum_comm;
      Â· exact Finset.sum_congr rfl fun i hi => by rw [ integral_e_target i ] ;

#check AddCircle