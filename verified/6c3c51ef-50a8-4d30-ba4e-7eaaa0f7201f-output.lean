/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6c3c51ef-50a8-4d30-ba4e-7eaaa0f7201f
-/

/-
We formalized and proved the statement that for a holomorphic function $f$, its average over a disk of radius $r$, denoted $F_r(z)$, is holomorphic in $z$ and converges to $f(z)$ as $r \to 0$.

The formalization uses the Lebesgue integral over the ball `Metric.ball z r` and the volume of the ball for normalization, replacing the user's original notation which was ambiguous or undefined.

The main theorem is `problem_171_part1`.

Imports used:
* `Mathlib.Analysis.Complex.Basic`
* `Mathlib.MeasureTheory.Integral.SetIntegral`
* `Mathlib.MeasureTheory.Measure.Lebesgue.Complex`
* `Mathlib.Analysis.Calculus.FDeriv`
* `Mathlib.Analysis.Analytic.Basic`
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Complex Set MeasureTheory
open scoped Real NNReal

/-
If f is analytic, then its average over a disk F_r(z) is analytic in z and converges to f(z) as r -> 0.
-/
open Complex Set MeasureTheory Filter Topology Metric

theorem problem_171_part1 {f : â„‚ â†’ â„‚} (hf : Differentiable â„‚ f) (zâ‚€ : â„‚) :
    âˆƒ (F : â„‚ â†’ â„ â†’ â„‚), (âˆ€ r > 0, AnalyticAt â„‚ (Î» z => F z r) zâ‚€) âˆ§
    (Tendsto (Î» r => F zâ‚€ r) (nhdsWithin 0 (Ioi 0)) (nhds (f zâ‚€))) âˆ§
    âˆ€ (z : â„‚) (r : â„), r > 0 â†’
      F z r = (volume (ball z r)).toRealâ»Â¹ â€¢ âˆ« w in ball z r, f w := by
  -- Since $f$ is analytic, the average $F_r(z)$ is also analytic.
  have h_avg_analytic : âˆ€ r > 0, AnalyticAt â„‚ (fun z => (1 / (Real.pi * r ^ 2)) â€¢ âˆ« w in Metric.ball z r, f w) zâ‚€ := by
    intro r hr
    have h_avg : âˆ€ z, âˆ« w in Metric.ball z r, f w = âˆ« w in Metric.ball (0 : â„‚) r, f (z + w) := by
      intro z; rw [ â† MeasureTheory.integral_indicator ( measurableSet_ball ), â† MeasureTheory.integral_indicator ( measurableSet_ball ) ] ; rw [ â† MeasureTheory.integral_add_right_eq_self _ z ] ; simp +decide [ Set.indicator ] ;
      ac_rfl;
    -- Since $f$ is analytic, the integral $\int_{|w|<r} f(z+w) \, dw$ is analytic in $z$.
    have h_int_analytic : AnalyticOn â„‚ (fun z => âˆ« w in Metric.ball (0 : â„‚) r, f (z + w)) Set.univ := by
      apply_rules [ DifferentiableOn.analyticOn ];
      Â· intro z hz
        have h_diff : HasDerivAt (fun z => âˆ« w in Metric.ball (0 : â„‚) r, f (z + w)) (âˆ« w in Metric.ball (0 : â„‚) r, deriv f (z + w)) z := by
          rw [ hasDerivAt_iff_tendsto_slope_zero ];
          have h_diff : Filter.Tendsto (fun t => âˆ« w in Metric.ball (0 : â„‚) r, (f (z + t + w) - f (z + w)) / t) (ğ“[â‰ ] 0) (ğ“ (âˆ« w in Metric.ball (0 : â„‚) r, deriv f (z + w))) := by
            refine' MeasureTheory.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _;
            use fun w => 2 * ( SupSet.sSup ( Set.image ( fun x => â€–deriv f xâ€– ) ( Metric.closedBall z ( r + 1 ) ) ) );
            Â· exact Filter.Eventually.of_forall fun n => Continuous.aestronglyMeasurable ( by exact Continuous.div_const ( by exact Continuous.sub ( hf.continuous.comp ( by continuity ) ) ( hf.continuous.comp ( by continuity ) ) ) _ );
            Â· -- Since $f$ is differentiable, we have $|f(z + n + a) - f(z + a)| \leq |n| \cdot \sup_{x \in \text{closed ball}} |f'(x)|$.
              have h_diff_bound : âˆ€ n : â„‚, â€–nâ€– < 1 â†’ âˆ€ a âˆˆ Metric.ball 0 r, â€–f (z + n + a) - f (z + a)â€– â‰¤ â€–nâ€– * (SupSet.sSup (Set.image (fun x => â€–deriv f xâ€–) (Metric.closedBall z (r + 1)))) := by
                intros n hn a ha
                have h_diff_bound : âˆ€ t âˆˆ Set.Icc (0 : â„) 1, â€–deriv f (z + t * n + a)â€– â‰¤ SupSet.sSup (Set.image (fun x => â€–deriv f xâ€–) (Metric.closedBall z (r + 1))) := by
                  intros t ht
                  have h_diff_bound : z + t * n + a âˆˆ Metric.closedBall z (r + 1) := by
                    simp_all +decide [ Metric.mem_closedBall, dist_eq_norm ];
                    ring_nf;
                    exact le_trans ( norm_add_le _ _ ) ( by simpa [ abs_of_nonneg ht.1 ] using by nlinarith [ norm_nonneg n, norm_nonneg a ] );
                  apply le_csSup;
                  Â· have h_diff_bound : ContinuousOn (fun x => â€–deriv f xâ€–) (Metric.closedBall z (r + 1)) := by
                      have h_diff_bound : AnalyticOn â„‚ (deriv f) (Metric.ball z (r + 1 + 1)) := by
                        have h_diff_bound : AnalyticOn â„‚ f (Metric.ball z (r + 1 + 1)) := by
                          exact DifferentiableOn.analyticOn hf.differentiableOn ( Metric.isOpen_ball );
                        apply_rules [ DifferentiableOn.analyticOn, h_diff_bound.differentiableOn ];
                        Â· apply_rules [ DifferentiableOn.deriv, h_diff_bound.differentiableOn ];
                          exact Metric.isOpen_ball;
                        Â· exact Metric.isOpen_ball;
                      exact h_diff_bound.continuousOn.norm.mono ( Metric.closedBall_subset_ball <| by linarith );
                    exact IsCompact.bddAbove ( isCompact_closedBall z ( r + 1 ) |> IsCompact.image_of_continuousOn <| h_diff_bound );
                  Â· exact?;
                -- Apply the fundamental theorem of calculus to the interval $[0, 1]$.
                have h_ftc : f (z + n + a) - f (z + a) = âˆ« t in (0 : â„)..1, deriv f (z + t * n + a) * n := by
                  rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
                  rotate_right;
                  use fun t => f ( z + t * n + a );
                  Â· norm_num;
                  Â· intro t ht; convert HasDerivAt.comp t ( hf.differentiableAt.hasDerivAt ) ( HasDerivAt.add ( HasDerivAt.add ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) ( hasDerivAt_const _ _ ) ) ) ( hasDerivAt_const _ _ ) ) using 1 ; norm_num;
                  Â· apply_rules [ ContinuousOn.intervalIntegrable ];
                    refine' ContinuousOn.mul _ continuousOn_const;
                    refine' ContinuousOn.comp ( show ContinuousOn ( deriv f ) ( Metric.closedBall z ( r + 1 ) ) from _ ) _ _;
                    Â· have h_cont_deriv : AnalyticOn â„‚ (deriv f) Set.univ := by
                        have h_cont_deriv : AnalyticOn â„‚ f Set.univ := by
                          exact DifferentiableOn.analyticOn hf.differentiableOn ( by simpa );
                        simp +zetaDelta at *;
                        exact h_cont_deriv.deriv;
                      exact h_cont_deriv.continuousOn.mono ( Set.subset_univ _ );
                    Â· exact Continuous.continuousOn ( by continuity );
                    Â· intro t ht; simp_all +decide [ Metric.mem_closedBall, dist_eq_norm ];
                      norm_num [ add_assoc ];
                      exact le_trans ( norm_add_le _ _ ) ( by simpa [ abs_of_nonneg ht.1 ] using by nlinarith [ norm_nonneg n, norm_nonneg a ] );
                rw [ h_ftc, intervalIntegral.integral_of_le zero_le_one ];
                refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) _;
                refine' le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _;
                use fun t => â€–nâ€– * SupSet.sSup ( Set.image ( fun x => â€–deriv f xâ€– ) ( Metric.closedBall z ( r + 1 ) ) );
                Â· exact Filter.Eventually.of_forall fun x => norm_nonneg _;
                Â· fun_prop;
                Â· filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using by simpa [ mul_comm ] using mul_le_mul_of_nonneg_left ( h_diff_bound t <| Set.Ioc_subset_Icc_self ht ) <| norm_nonneg n;
                Â· norm_num;
              rw [ eventually_nhdsWithin_iff ];
              rw [ Metric.eventually_nhds_iff ];
              refine' âŸ¨ 1, by norm_num, fun y hy hy' => Filter.eventually_of_mem ( MeasureTheory.ae_restrict_mem measurableSet_ball ) fun a ha => _ âŸ© ; simp_all +decide [ div_le_iffâ‚€ ];
              exact le_trans ( h_diff_bound y hy a ha ) ( by nlinarith [ norm_nonneg y, show 0 â‰¤ SupSet.sSup ( ( fun x => â€–deriv f xâ€– ) '' Metric.closedBall z ( r + 1 ) ) from by apply_rules [ Real.sSup_nonneg ] ; rintro x âŸ¨ u, hu, rfl âŸ© ; exact norm_nonneg _ ] );
            Â· exact ContinuousOn.integrableOn_compact ( ProperSpace.isCompact_closedBall _ _ ) ( continuousOn_const ) |> fun h => h.mono_set <| Metric.ball_subset_closedBall;
            Â· refine' Filter.Eventually.of_forall fun w => _;
              have h_deriv : HasDerivAt (fun n => f (z + n + w)) (deriv f (z + w)) 0 := by
                convert HasDerivAt.comp 0 ( hf.differentiableAt.hasDerivAt ) ( HasDerivAt.add ( HasDerivAt.add ( hasDerivAt_const _ _ ) ( hasDerivAt_id 0 ) ) ( hasDerivAt_const _ _ ) ) using 1 ; norm_num;
              simpa [ div_eq_inv_mul ] using h_deriv.tendsto_slope_zero;
          convert h_diff using 2;
          rw [ â† MeasureTheory.integral_sub ( by exact ContinuousOn.integrableOn_compact ( ProperSpace.isCompact_closedBall _ _ ) ( by exact hf.continuous.comp_continuousOn ( continuousOn_const.add continuousOn_id ) ) |> fun h => h.mono_set <| Metric.ball_subset_closedBall ) ( by exact ContinuousOn.integrableOn_compact ( ProperSpace.isCompact_closedBall _ _ ) ( by exact hf.continuous.comp_continuousOn ( continuousOn_const.add continuousOn_id ) ) |> fun h => h.mono_set <| Metric.ball_subset_closedBall ) ] ; norm_num [ div_eq_inv_mul, MeasureTheory.integral_const_mul ];
        exact h_diff.differentiableAt.differentiableWithinAt;
      Â· exact isOpen_univ;
    simp_all +decide [ analyticOn_univ ];
    exact AnalyticAt.mul ( analyticAt_const ) ( h_int_analytic zâ‚€ ( Set.mem_univ zâ‚€ ) );
  refine' âŸ¨ _, _, _, _ âŸ©;
  use fun z r => ( 1 / ( Real.pi * r ^ 2 ) ) â€¢ âˆ« w in Metric.ball z r, f w;
  Â· assumption;
  Â· -- By the properties of the integral, we can rewrite the integral as $\int_{|w-zâ‚€|<r} f(w) \, dw = \int_{|w-zâ‚€|<1} f(zâ‚€ + rw) r^2 \, dw$.
    have h_integral : âˆ€ r > 0, âˆ« w in Metric.ball zâ‚€ r, f w = r^2 * âˆ« w in Metric.ball 0 1, f (zâ‚€ + r * w) := by
      intro r hr
      have h_integral : âˆ« w in Metric.ball zâ‚€ r, f w = âˆ« w in (fun w => zâ‚€ + r * w) '' Metric.ball 0 1, f w := by
        congr with w ; simp +decide [ dist_eq_norm, hr.ne' ];
        exact âŸ¨ fun h => âŸ¨ ( w - zâ‚€ ) / r, by simpa [ abs_of_pos hr, hr.ne' ] using div_lt_one hr |>.2 h, by simp +decide [ mul_div_cancelâ‚€, hr.ne' ] âŸ©, by rintro âŸ¨ x, hx, rfl âŸ© ; simpa [ abs_of_pos hr, hr.ne' ] using by simpa [ abs_of_pos hr, hr.ne' ] using mul_lt_mul_of_pos_left hx hr âŸ©;
      rw [ h_integral, MeasureTheory.integral_image_eq_integral_abs_det_fderiv_smul ] <;> norm_num [ hr.ne' ];
      any_goals intro x hx; exact HasFDerivAt.hasFDerivWithinAt ( HasFDerivAt.const_mul ( hasFDerivAt_id x ) _ );
      Â· norm_num [ ContinuousLinearMap.det ];
        rw [ MeasureTheory.integral_const_mul ];
      Â· exact measurableSet_ball;
    -- Since $f$ is continuous, we have $\lim_{r \to 0} \int_{|w|<1} f(zâ‚€ + rw) \, dw = \int_{|w|<1} f(zâ‚€) \, dw = f(zâ‚€) \cdot \text{Area}(D(0,1)) = f(zâ‚€) \cdot \pi$.
    have h_cont : Filter.Tendsto (fun r : â„ => âˆ« w in Metric.ball (0 : â„‚) 1, f (zâ‚€ + r * w)) (ğ“[>] 0) (nhds (f zâ‚€ * Real.pi)) := by
      have h_cont : Filter.Tendsto (fun r : â„ => âˆ« w in Metric.ball (0 : â„‚) 1, f (zâ‚€ + r * w)) (ğ“[>] 0) (nhds (âˆ« w in Metric.ball (0 : â„‚) 1, f zâ‚€)) := by
        refine' MeasureTheory.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _;
        use fun w => SupSet.sSup ( Set.image ( fun x => â€–f xâ€– ) ( Metric.closedBall zâ‚€ 1 ) );
        Â· exact Filter.eventually_of_mem self_mem_nhdsWithin fun r hr => Continuous.aestronglyMeasurable ( hf.continuous.comp <| by continuity );
        Â· filter_upwards [ Ioo_mem_nhdsGT zero_lt_one ] with r hr;
          filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_ball ] with w hw;
          refine' le_csSup _ _;
          Â· exact IsCompact.bddAbove ( isCompact_closedBall zâ‚€ 1 |> IsCompact.image <| hf.continuous.norm );
          Â· exact âŸ¨ zâ‚€ + r * w, by simpa [ abs_of_pos hr.1 ] using by nlinarith [ hr.1, hr.2, show â€–wâ€– â‰¤ 1 by simpa using hw.out.le ], rfl âŸ©;
        Â· exact ContinuousOn.integrableOn_compact ( ProperSpace.isCompact_closedBall _ _ ) ( continuousOn_const ) |> fun h => h.mono_set <| Metric.ball_subset_closedBall;
        Â· refine' Filter.eventually_of_mem ( MeasureTheory.ae_restrict_mem measurableSet_ball ) fun x hx => _;
          exact tendsto_nhdsWithin_of_tendsto_nhds ( Continuous.tendsto' ( by exact hf.continuous.comp <| by continuity ) _ _ <| by simpa );
      convert h_cont using 2 ; norm_num [ mul_comm, MeasureTheory.measureReal_def ];
    have := h_cont.const_mul ( 1 / Real.pi : â„‚ );
    simp_all +decide [ mul_assoc, mul_comm, mul_left_comm, Real.pi_ne_zero ];
    refine' this.congr' ( by filter_upwards [ self_mem_nhdsWithin ] with r hr using by rw [ h_integral r hr ] ; simp +decide [ mul_assoc, mul_left_comm, hr.out.ne' ] );
  Â· norm_num [ Complex.volume_ball ];
    exact fun z r hr => Or.inl <| by rw [ ENNReal.toReal_ofReal hr.le ] ; ring