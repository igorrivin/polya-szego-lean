/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a7c249b8-a070-4066-bb5a-194e6f68bba5

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Complex
open Set
open Metric

theorem problem_110_part_one_chapter_3 :
    ∀ (f : ℂ → ℂ) (h : DifferentiableOn ℂ f (ball (0 : ℂ) 1))
    (h_norm : f 0 = 0) (h_deriv_norm : deriv f 0 = 1)
    (h_starlike : ∀ z ∈ ball (0 : ℂ) 1,
        ∃ t : ℝ, t ∈ Set.Ioo (0 : ℝ) 1 ∧ deriv f z * z = t • (z * deriv f z)),
    Convex ℝ (f '' (ball (0 : ℂ) 1)) := by
  -- Let's choose any two points $z_1, z_2 \in \mathbb{D}$.
  intro f hf_diff hf_zero hf_deriv hf_convex
  simp_all +decide [ mul_comm ];
  -- Let's choose any two points $z_1, z_2 \in \mathbb{D}$ and show that the line segment connecting them is contained in $f(\mathbb{D})$.
  have h_segment : ∀ z₁ z₂ : ℂ, ‖z₁‖ < 1 → ‖z₂‖ < 1 → ∃ t ∈ Set.Ioo (0 : ℝ) 1, z₁ * deriv f z₁ = t • (z₁ * deriv f z₁) ∧ z₂ * deriv f z₂ = t • (z₂ * deriv f z₂) := by
    norm_num +zetaDelta at *;
    grind;
  -- Let's choose any two points $z_1, z_2 \in \mathbb{D}$ and show that the line segment connecting them is contained in $f(\mathbb{D})$ using the hypothesis $h_segment$.
  have h_segment : ∀ z₁ z₂ : ℂ, ‖z₁‖ < 1 → ‖z₂‖ < 1 → z₁ * deriv f z₁ = z₂ * deriv f z₂ := by
    intros z₁ z₂ hz₁ hz₂
    obtain ⟨t₁, ht₁⟩ := h_segment z₁ z₂ hz₁ hz₂
    obtain ⟨t₂, ht₂⟩ := h_segment z₂ z₁ hz₂ hz₁
    generalize_proofs at *; (
    norm_num [ Complex.ext_iff ] at * ; constructor <;> nlinarith [ ht₁.1.1, ht₁.1.2, ht₂.1.1, ht₂.1.2 ] ;)
  generalize_proofs at *; (
  -- Since $z \cdot \text{deriv} \, f \, z = 0$ for all $z \in \mathbb{D}$ with $z \neq 0$, and $\text{deriv} \, f \, 0 = 1$, we have a contradiction.
  have h_contra : ∀ z : ℂ, ‖z‖ < 1 → z ≠ 0 → deriv f z = 0 := by
    intro z hz hz'; specialize h_segment z 0 hz; aesop;
  generalize_proofs at *; (
  -- Since $deriv f z = 0$ for all $z \neq 0$ in the unit disk, and $deriv f 0 = 1$, this contradicts the continuity of the derivative.
  have h_cont_deriv : ContinuousAt (deriv f) 0 := by
    have h_cont_deriv : AnalyticOn ℂ (deriv f) (Metric.ball 0 1) := by
      apply_rules [ DifferentiableOn.analyticOn, hf_diff.deriv ];
      · exact Metric.isOpen_ball;
      · exact Metric.isOpen_ball
    generalize_proofs at *; (
    exact h_cont_deriv.continuousOn.continuousAt <| Metric.ball_mem_nhds _ zero_lt_one)
  generalize_proofs at *; (
  have h_contra : Filter.Tendsto (fun z : ℂ => deriv f z) (nhdsWithin 0 {0}ᶜ) (nhds 0) := by
    exact tendsto_const_nhds.congr' ( by filter_upwards [ self_mem_nhdsWithin, mem_nhdsWithin_of_mem_nhds ( Metric.ball_mem_nhds _ zero_lt_one ) ] with z hz₁ hz₂; aesop )
  generalize_proofs at *; (
  exact absurd ( tendsto_nhds_unique h_contra ( h_cont_deriv.mono_left inf_le_left ) ) ( by norm_num [ hf_deriv ] )))))

/-
The broken formalization is vacuously true because the premises are contradictory.
-/
theorem problem_110_broken_is_true :
    ∀ (f : ℂ → ℂ) (h : DifferentiableOn ℂ f (ball (0 : ℂ) 1))
    (h_norm : f 0 = 0) (h_deriv_norm : deriv f 0 = 1)
    (h_starlike : ∀ z ∈ ball (0 : ℂ) 1,
        ∃ t : ℝ, t ∈ Set.Ioo (0 : ℝ) 1 ∧ deriv f z * z = t • (z * deriv f z)),
    Convex ℝ (f '' (ball (0 : ℂ) 1)) := by
      exact?

/-
The analytic condition for convexity of f is equivalent to the analytic condition for starlikeness of z*f'(z).
-/
theorem alexander_analytic_equivalence (f : ℂ → ℂ) (hf : DifferentiableOn ℂ f (ball 0 1))
    (hf' : DifferentiableOn ℂ (deriv f) (ball 0 1))
    (h_deriv_ne : ∀ z ∈ ball 0 1, deriv f z ≠ 0)
    (h_f_ne : ∀ z ∈ ball 0 1, z ≠ 0 → f z ≠ 0) :
    (∀ z ∈ ball 0 1, z ≠ 0 → (1 + z * deriv (deriv f) z / deriv f z).re > 0) ↔
    (∀ z ∈ ball 0 1, z ≠ 0 → let g := fun w => w * deriv f w; (z * deriv g z / g z).re > 0) := by
  -- Let's simplify the expression for $g'(z)$.
  have hg_deriv : ∀ w ∈ Metric.ball 0 1, deriv (fun w => w * deriv f w) w = deriv f w + w * deriv (deriv f) w := by
    intro w hw;
    norm_num +zetaDelta at *;
    convert HasDerivAt.deriv ( HasDerivAt.mul ( hasDerivAt_id w ) ( hf'.hasDerivAt ( Metric.isOpen_ball.mem_nhds ( by simpa ) ) ) ) using 1 ; ring!;
  grind

/-
Definitions of analytic starlikeness and convexity.
-/
def AnalyticStarlike (f : ℂ → ℂ) : Prop :=
  ∀ z ∈ ball (0 : ℂ) 1, z ≠ 0 → (z * deriv f z / f z).re > 0

def AnalyticConvex (f : ℂ → ℂ) : Prop :=
  ∀ z ∈ ball (0 : ℂ) 1, z ≠ 0 → (1 + z * deriv (deriv f) z / deriv f z).re > 0

/-
The analytic condition for starlikeness of z*f'(z) is equivalent to the analytic condition for convexity of f.
-/
theorem problem_110_analytic (f : ℂ → ℂ) (hf : DifferentiableOn ℂ f (ball 0 1))
    (hf' : DifferentiableOn ℂ (deriv f) (ball 0 1))
    (h_deriv_ne : ∀ z ∈ ball 0 1, deriv f z ≠ 0) :
    AnalyticStarlike (fun z => z * deriv f z) ↔ AnalyticConvex f := by
      -- This follows directly from `alexander_analytic_equivalence` by setting `g(z) = z * f'(z)` and observing that `g(z) \ne 0` for `z \ne 0` since `f'(z) \ne 0`.
      apply Iff.intro;
      · intro h;
        intro z hz hz';
        -- Since $g(z) = z * deriv f z$, we have $deriv g z = deriv f z + z * deriv (deriv f) z$.
        have h_deriv_g : deriv (fun z => z * deriv f z) z = deriv f z + z * deriv (deriv f) z := by
          exact HasDerivAt.deriv ( by simpa using HasDerivAt.mul ( hasDerivAt_id z ) ( hf'.hasDerivAt ( Metric.isOpen_ball.mem_nhds hz ) ) );
        have := h z hz hz';
        simp_all +decide [ add_div, mul_div_mul_left ];
      · intro h_convex z hz hz';
        -- By definition of $g$, we know that $deriv g z = deriv f z + z * deriv (deriv f) z$.
        have h_deriv_g : deriv (fun z => z * deriv f z) z = deriv f z + z * deriv (deriv f) z := by
          exact HasDerivAt.deriv ( by simpa using HasDerivAt.mul ( hasDerivAt_id z ) ( hf'.hasDerivAt ( IsOpen.mem_nhds Metric.isOpen_ball hz ) ) );
        simp_all +decide [ mul_div_mul_left, mul_div_mul_right ];
        have := h_convex z ( by simpa using hz ) hz'; simp_all +decide [ add_div, mul_div_cancel_left₀ ] ;

/-
The analytic condition for starlikeness of z*f'(z) is equivalent to the analytic condition for convexity of f.
-/
theorem alexander_theorem_analytic (f : ℂ → ℂ) (hf : DifferentiableOn ℂ f (ball 0 1))
    (hf' : DifferentiableOn ℂ (deriv f) (ball 0 1))
    (h_deriv_ne : ∀ z ∈ ball 0 1, deriv f z ≠ 0) :
    AnalyticStarlike (fun z => z * deriv f z) ↔ AnalyticConvex f := by
      exact?