/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 37d282b0-0ec3-4b83-9ad1-8b912eaf7995
-/

/-
We have formally proven Polya-Szego Problem 117.
The first part (limit of integral with sin(nx)) is a direct application of the Riemann-Lebesgue lemma.
The second part (limit of integral with |sin(nx)|) is proven by approximating the integrable function f by step functions in the L1 norm.
We showed that step functions satisfy the limit property, and that the property is preserved under L1 approximation.
Step functions are dense in L1, which allows us to conclude the result for all integrable functions.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Checking for IntervalIntegrable in the global namespace and the Riemann-Lebesgue lemma.
-/
#check IntervalIntegrable
#check MeasureTheory.Integrable
#check Real.tendsto_integral_exp_smul_cocompact

/-
If f is integrable, then the integral of f(x)sin(nx) tends to 0 as n tends to infinity.
-/
theorem problem_117_part1 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    Filter.Tendsto (fun (n : ℕ) => ∫ x : ℝ, f x * Real.sin ((n : ℝ) * x)) Filter.atTop (nhds 0) := by
  -- Let $g(x) = f(x) \sin(nx)$.
  let g := fun n : ℕ => fun x : ℝ => f x * Real.sin (n * x);
  -- By the Riemann-Lebesgue lemma, the integral of $f(x) \sin(nx)$ tends to zero as $n$ tends to infinity.
  have h_riemann_lebesgue : Filter.Tendsto (fun n : ℕ => ∫ x, g n x) Filter.atTop (nhds 0) := by
    have h_ft : ∀ (f : ℝ → ℂ), MeasureTheory.Integrable f → Filter.Tendsto (fun n : ℕ => ∫ x, f x * Complex.exp (n * x * Complex.I)) Filter.atTop (nhds 0) := by
      intro f hf;
      have := @Real.tendsto_integral_exp_smul_cocompact;
      specialize this f;
      simp_all +decide [ mul_assoc, mul_comm, mul_left_comm, Real.fourierChar ];
      convert this.1.comp ( show Filter.Tendsto ( fun n : ℕ => - ( n : ℝ ) / ( 2 * Real.pi ) ) Filter.atTop Filter.atBot from Filter.tendsto_atTop_atBot.mpr _ ) using 2 ; norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Real.pi_ne_zero ];
      · simp +decide [ mul_comm, mul_assoc, mul_left_comm, Complex.exp_mul_I, Circle.smul_def ];
      · exact fun b => ⟨ Nat.ceil ( -b * ( 2 * Real.pi ) ), fun n hn => by rw [ div_le_iff₀ ( by positivity ) ] ; nlinarith [ Nat.ceil_le.mp hn, Real.pi_pos ] ⟩
    -- Apply the Riemann-Lebesgue lemma to the function $f(x) \sin(nx)$.
    have h_apply_riemann_lebesgue : Filter.Tendsto (fun n : ℕ => Complex.im (∫ x, f x * Complex.exp (n * x * Complex.I))) Filter.atTop (nhds 0) := by
      simpa using Filter.Tendsto.comp ( Complex.continuous_im.tendsto 0 ) ( h_ft ( fun x => f x ) ( by exact hf.ofReal ) );
    -- The integral of $f(x) \sin(nx)$ is the imaginary part of the integral of $f(x) e^{inx}$.
    have h_im : ∀ n : ℕ, ∫ x, f x * Real.sin (n * x) = Complex.im (∫ x, f x * Complex.exp (n * x * Complex.I)) := by
      intro n; rw [ ← MeasureTheory.integral_congr_ae ];
      convert integral_im _;
      any_goals tauto;
      · refine' MeasureTheory.Integrable.mono' _ _ _;
        exacts [ fun x => |f x|, hf.norm, by exact MeasureTheory.AEStronglyMeasurable.mul ( Complex.continuous_ofReal.comp_aestronglyMeasurable hf.1 ) ( Continuous.aestronglyMeasurable ( by continuity ) ), Filter.Eventually.of_forall fun x => by simp +decide [ Complex.norm_exp ] ];
      · filter_upwards [ ] with x using by simp +decide [ Complex.exp_im ];
    aesop;
  convert h_riemann_lebesgue using 1

/-
The integral of |sin(nx)| over [a, b] tends to (2/pi) * (b-a) as n tends to infinity.
-/
lemma problem_117_interval (a b : ℝ) :
    Filter.Tendsto (fun (n : ℕ) => ∫ x in a..b, |Real.sin ((n : ℝ) * x)|) Filter.atTop (nhds ((2 / Real.pi) * (b - a))) := by
  -- The integral of |sin(nx)| over [a, b] is (1/n) * integral of |sin(u)| over [na, nb].
  suffices h_suff : Filter.Tendsto (fun n : ℕ => (1 / (n : ℝ)) * ∫ u in (n * a).. (n * b), |Real.sin u|) Filter.atTop (nhds ((2 / Real.pi) * (b - a))) by
    refine h_suff.congr' ?_ ; filter_upwards [ Filter.eventually_ne_atTop 0 ] with n hn ; simp +decide [ hn, intervalIntegral.integral_comp_mul_left ( fun x => |Real.sin x| ) ];
  -- The integral of |sin(u)| over [0, T] is approximately (2/π) * T for large T.
  have h_integral_approx : Filter.Tendsto (fun T : ℝ => (∫ u in (0)..T, |Real.sin u|) / T) Filter.atTop (nhds (2 / Real.pi)) := by
    -- We'll use the fact that the integral of $|\sin(u)|$ over $[0, T]$ can be split into the sum of integrals over intervals of length $\pi$.
    have h_split : ∀ T : ℝ, 0 ≤ T → (∫ u in (0)..T, |Real.sin u|) = (∑ k ∈ Finset.range (Nat.floor (T / Real.pi)), (∫ u in (k * Real.pi)..((k + 1) * Real.pi), |Real.sin u|)) + (∫ u in ((Nat.floor (T / Real.pi)) * Real.pi)..T, |Real.sin u|) := by
      intro T hT_nonneg; induction' ⌊T / Real.pi⌋₊ with n ih <;> simp_all +decide [ Finset.sum_range_succ ];
      rw [ add_assoc, intervalIntegral.integral_add_adjacent_intervals ] <;> exact Continuous.intervalIntegrable ( by continuity ) _ _;
    -- The integral of $|\sin(u)|$ over $[k\pi, (k+1)\pi]$ is $2$.
    have h_integral_periodic : ∀ k : ℕ, ∫ u in (k * Real.pi)..((k + 1) * Real.pi), |Real.sin u| = 2 := by
      -- We'll use the fact that $|\sin(u)|$ is periodic with period $\pi$.
      intro k
      have h_integral_periodic : ∫ u in (k * Real.pi)..((k + 1) * Real.pi), |Real.sin u| = ∫ u in (0)..Real.pi, |Real.sin u| := by
        convert intervalIntegral.integral_comp_add_right _ ( -k * Real.pi ) using 2 <;> ring;
        norm_num [ Real.sin_sub ];
        norm_num [ abs_mul, Real.abs_cos_eq_sqrt_one_sub_sin_sq ];
      rw [ h_integral_periodic, intervalIntegral.integral_congr fun x hx => abs_of_nonneg ( Real.sin_nonneg_of_nonneg_of_le_pi ( by linarith [ Set.mem_Icc.mp ( by simpa [ Real.pi_pos.le ] using hx ) ] ) ( by linarith [ Set.mem_Icc.mp ( by simpa [ Real.pi_pos.le ] using hx ) ] ) ) ] ; norm_num;
    -- The integral of $|\sin(u)|$ over $[⌊T / π⌋₊ * π, T]$ is bounded by $π$.
    have h_integral_bound : ∀ T : ℝ, 0 ≤ T → |∫ u in (⌊T / Real.pi⌋₊ * Real.pi)..T, |Real.sin u| - 0| ≤ Real.pi := by
      intros T hT
      have h_integral_bound : ∫ u in (⌊T / Real.pi⌋₊ * Real.pi)..T, |Real.sin u| ≤ ∫ u in (⌊T / Real.pi⌋₊ * Real.pi)..T, 1 := by
        refine' intervalIntegral.integral_mono_on _ _ _ _ <;> norm_num;
        · nlinarith [ Nat.floor_le ( show 0 ≤ T / Real.pi by positivity ), Real.pi_pos, mul_div_cancel₀ T Real.pi_ne_zero ];
        · exact Continuous.intervalIntegrable ( Real.continuous_sin.abs ) _ _;
        · exact fun x _ _ => Real.abs_sin_le_one x;
      norm_num at *;
      rw [ abs_of_nonneg ( intervalIntegral.integral_nonneg ( by nlinarith [ Nat.floor_le ( show 0 ≤ T / Real.pi by positivity ), Real.pi_pos, mul_div_cancel₀ T Real.pi_ne_zero ] ) fun u hu => abs_nonneg _ ) ] ; nlinarith [ Nat.lt_floor_add_one ( T / Real.pi ), Real.pi_pos, mul_div_cancel₀ T Real.pi_ne_zero ];
    -- Using the bounds, we can show that the limit of the integral divided by $T$ is $2 / \pi$.
    have h_limit : Filter.Tendsto (fun T : ℝ => (∑ k ∈ Finset.range (Nat.floor (T / Real.pi)), 2 + ∫ u in (Nat.floor (T / Real.pi) * Real.pi)..T, |Real.sin u|) / T) Filter.atTop (nhds (2 / Real.pi)) := by
      -- We'll use the fact that the floor function tends to its argument as the argument tends to infinity.
      have h_floor : Filter.Tendsto (fun T : ℝ => Nat.floor (T / Real.pi) / T) Filter.atTop (nhds (1 / Real.pi)) := by
        -- We'll use the fact that the floor function tends to its argument as the argument tends to infinity. Formally, we have $\frac{\lfloor x \rfloor}{x} \to 1$ as $x \to \infty$.
        have h_floor : Filter.Tendsto (fun x : ℝ => Nat.floor x / x) Filter.atTop (nhds 1) := by
          rw [ Metric.tendsto_nhds ];
          intro ε hε; filter_upwards [ Filter.eventually_gt_atTop ( ε⁻¹ * 2 ), Filter.eventually_gt_atTop 0 ] with x hx₁ hx₂ using abs_lt.mpr ⟨ by nlinarith [ Nat.floor_le ( show 0 ≤ x by linarith ), Nat.lt_floor_add_one x, mul_inv_cancel₀ ( ne_of_gt hε ), div_mul_cancel₀ ( Nat.floor x : ℝ ) ( ne_of_gt hx₂ ) ], by nlinarith [ Nat.floor_le ( show 0 ≤ x by linarith ), Nat.lt_floor_add_one x, mul_inv_cancel₀ ( ne_of_gt hε ), div_mul_cancel₀ ( Nat.floor x : ℝ ) ( ne_of_gt hx₂ ) ] ⟩ ;
        have := h_floor.comp ( Filter.tendsto_id.atTop_div_const ( Real.pi_pos ) );
        convert this.const_mul ( Real.pi⁻¹ ) using 2 <;> norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Real.pi_ne_zero ];
      -- Using the fact that the integral of $|\sin(u)|$ over $[⌊T / π⌋₊ * π, T]$ is bounded by $π$, we can show that the limit of the integral divided by $T$ is $0$.
      have h_integral_zero : Filter.Tendsto (fun T : ℝ => (∫ u in (Nat.floor (T / Real.pi) * Real.pi)..T, |Real.sin u|) / T) Filter.atTop (nhds 0) := by
        refine' squeeze_zero_norm' _ _;
        exacts [ fun T => Real.pi / |T|, Filter.eventually_atTop.mpr ⟨ 1, fun T hT => by simpa [ abs_div ] using div_le_div_of_nonneg_right ( h_integral_bound T ( by positivity ) ) ( by positivity ) ⟩, tendsto_const_nhds.div_atTop ( tendsto_norm_atTop_atTop ) ];
      convert h_floor.const_mul 2 |> Filter.Tendsto.add <| h_integral_zero using 2 <;> ring;
      norm_num ; ring;
    exact h_limit.congr' ( by filter_upwards [ Filter.eventually_ge_atTop 0 ] with T hT using by rw [ h_split T hT, Finset.sum_congr rfl fun _ _ => h_integral_periodic _ ] );
  -- Using the fact that the integral of |sin(u)| over [0, T] is approximately (2/π) * T for large T, we can bound the integral over [na, nb].
  have h_bound : Filter.Tendsto (fun n : ℕ => (∫ u in (0)..n * b, |Real.sin u|) / (n : ℝ) - (∫ u in (0)..n * a, |Real.sin u|) / (n : ℝ)) Filter.atTop (nhds ((2 / Real.pi) * (b - a))) := by
    by_cases ha : a = 0 <;> by_cases hb : b = 0 <;> simp_all +decide [ div_mul_eq_mul_div ];
    · convert h_integral_approx.comp ( tendsto_natCast_atTop_atTop.atTop_mul_const ( show 0 < |b| from abs_pos.mpr hb ) ) |> Filter.Tendsto.mul_const b using 2 <;> norm_num ; ring;
      · cases abs_cases b <;> simp +decide [ *, mul_assoc, mul_comm, mul_left_comm ];
        rw [ show ( ∫ u in ( 0 : ℝ )..b * ( _ : ℕ ), |Real.sin u| ) = - ( ∫ u in ( 0 : ℝ )..- ( b * ( _ : ℕ ) ), |Real.sin u| ) by rw [ ← intervalIntegral.integral_symm ] ; convert intervalIntegral.integral_comp_neg _ using 2 <;> norm_num ] ; ring;
      · ring;
    · have := h_integral_approx.comp ( show Filter.Tendsto ( fun n : ℕ => ( n : ℝ ) * |a| ) Filter.atTop Filter.atTop from Filter.Tendsto.atTop_mul_const ( by positivity ) tendsto_natCast_atTop_atTop );
      convert this.neg.mul_const a using 2 <;> norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, ha ];
      cases abs_cases a <;> simp +decide [ *, mul_assoc, mul_left_comm ];
      rw [ show ( ∫ u in ( 0 : ℝ )..a * ( _ : ℕ ), |Real.sin u| ) = - ( ∫ u in ( 0 : ℝ )..- ( a * ( _ : ℕ ) ), |Real.sin u| ) by rw [ ← intervalIntegral.integral_symm ] ; convert intervalIntegral.integral_comp_neg _ using 2 <;> norm_num ] ; ring;
    · convert Filter.Tendsto.sub ( h_integral_approx.comp ( tendsto_natCast_atTop_atTop.atTop_mul_const ( show 0 < |b| by positivity ) ) |> Filter.Tendsto.mul_const b ) ( h_integral_approx.comp ( tendsto_natCast_atTop_atTop.atTop_mul_const ( show 0 < |a| by positivity ) ) |> Filter.Tendsto.mul_const a ) using 2 <;> norm_num [ abs_mul, abs_div, abs_of_pos, Real.pi_pos ] ; ring;
      · cases abs_cases b <;> cases abs_cases a <;> simp +decide [ *, mul_assoc, mul_comm, mul_left_comm ];
        · rw [ show ( ∫ u in ( 0 : ℝ )..a * ( _ : ℕ ), |Real.sin u| ) = - ( ∫ u in ( 0 : ℝ )..- ( a * ( _ : ℕ ) ), |Real.sin u| ) by rw [ ← intervalIntegral.integral_symm ] ; convert intervalIntegral.integral_comp_neg _ using 2 <;> norm_num ] ; ring;
        · rw [ show ( ∫ u in ( 0 : ℝ )..b * ( _ : ℕ ), |Real.sin u| ) = - ( ∫ u in ( 0 : ℝ )..- ( b * ( _ : ℕ ) ), |Real.sin u| ) by rw [ ← intervalIntegral.integral_symm ] ; convert intervalIntegral.integral_comp_neg _ using 2 <;> norm_num ] ; ring;
        · rw [ show ( ∫ u in ( 0 : ℝ )..b * ( _ : ℕ ), |Real.sin u| ) = - ( ∫ u in ( 0 : ℝ )..- ( b * ( _ : ℕ ) ), |Real.sin u| ) by rw [ ← intervalIntegral.integral_symm ] ; convert intervalIntegral.integral_comp_neg _ using 2 <;> norm_num, show ( ∫ u in ( 0 : ℝ )..a * ( _ : ℕ ), |Real.sin u| ) = - ( ∫ u in ( 0 : ℝ )..- ( a * ( _ : ℕ ) ), |Real.sin u| ) by rw [ ← intervalIntegral.integral_symm ] ; convert intervalIntegral.integral_comp_neg _ using 2 <;> norm_num ] ; ring;
      · ring;
  convert h_bound using 2 ; ring;
  rw [ ← mul_sub, intervalIntegral.integral_interval_sub_left ];
  · exact Continuous.intervalIntegrable ( Real.continuous_sin.abs ) _ _;
  · exact Continuous.intervalIntegrable ( Real.continuous_sin.abs ) _ _

/-
If f can be approximated in L1 by functions satisfying the limit property, then f satisfies the limit property.
-/
def HasAbsSinLimit (f : ℝ → ℝ) : Prop :=
  Filter.Tendsto (fun n : ℕ => ∫ x, f x * |Real.sin ((n : ℝ) * x)|) Filter.atTop (nhds ((2 / Real.pi) * ∫ x, f x))

lemma hasAbsSinLimit_of_approx {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f)
    (h_approx : ∀ ε > 0, ∃ g, HasAbsSinLimit g ∧ MeasureTheory.Integrable g ∧ ∫ x, |f x - g x| < ε) :
    HasAbsSinLimit f := by
  -- We'll use the fact that if the integral of |f(x) - g(x)| is small, then the integral of |f(x)sin(nx)| and |g(x)sin(nx)| should be close.
  have h_close : ∀ ε > 0, ∃ g : ℝ → ℝ,
    (MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume) ∧
    (((∫ x, abs ((f x) - (g x))) < ε) ∧
      Filter.Tendsto (fun n : ℕ => (∫ x, (g x) * (abs (Real.sin (n * x))))) Filter.atTop (nhds ((2 / Real.pi) * (∫ x, (g x))))) ∧
      (∀ n : ℕ, abs ((∫ x, (f x) * (abs (Real.sin (n * x)))) - (∫ x, (g x) * (abs (Real.sin (n * x))))) ≤ ∫ x, abs ((f x) - (g x))) := by
        intro ε hε;
        obtain ⟨ g, hg₁, hg₂, hg₃ ⟩ := h_approx ε hε;
        refine' ⟨ g, hg₂, ⟨ hg₃, hg₁ ⟩, fun n => _ ⟩;
        rw [ ← MeasureTheory.integral_sub ];
        · refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) ) ( MeasureTheory.integral_mono_of_nonneg _ _ _ );
          · exact Filter.Eventually.of_forall fun x => norm_nonneg _;
          · exact MeasureTheory.Integrable.abs ( hf.sub hg₂ );
          · filter_upwards [ ] with x using by simpa [ ← sub_mul ] using mul_le_of_le_one_right ( abs_nonneg _ ) ( Real.abs_sin_le_one _ ) ;
        · refine' hf.norm.mono' _ _;
          · exact hf.1.mul ( Continuous.aestronglyMeasurable ( Real.continuous_sin.abs.comp ( continuous_const.mul continuous_id' ) ) );
          · filter_upwards [ ] with x using by simpa using mul_le_mul_of_nonneg_left ( Real.abs_sin_le_one _ ) ( abs_nonneg _ ) ;
        · refine' hg₂.norm.mono' _ _;
          · exact hg₂.1.mul ( Continuous.aestronglyMeasurable ( Real.continuous_sin.abs.comp ( continuous_const.mul continuous_id' ) ) );
          · filter_upwards [ ] with x using by simpa [ abs_mul ] using mul_le_mul_of_nonneg_left ( Real.abs_sin_le_one _ ) ( abs_nonneg _ ) ;
  refine' Metric.tendsto_atTop.mpr _;
  intro ε hε; rcases h_close ( ε / 4 ) ( by positivity ) with ⟨ g, hg₁, ⟨ hg₂, hg₃ ⟩, hg₄ ⟩ ; rcases Metric.tendsto_atTop.mp hg₃ ( ε / 4 ) ( by positivity ) with ⟨ N, hN ⟩ ; use N; intros n hn; refine' abs_lt.mpr ⟨ _, _ ⟩ <;> have := abs_lt.mp ( hN n hn ) <;> have := abs_le.mp ( hg₄ n ) <;> norm_num at *;
  · have h_integral_diff : abs ((∫ x, f x) - (∫ x, g x)) ≤ ∫ x, abs ((f x) - (g x)) := by
      simpa only [ ← MeasureTheory.integral_sub hf hg₁ ] using MeasureTheory.norm_integral_le_integral_norm ( f - g );
    nlinarith [ abs_le.mp h_integral_diff, Real.pi_gt_three, mul_div_cancel₀ ( 2 : ℝ ) Real.pi_ne_zero ];
  · have h_integral_bound : abs ((∫ x, f x) - (∫ x, g x)) ≤ ∫ x, abs ((f x) - (g x)) := by
      simpa only [ ← MeasureTheory.integral_sub hf hg₁ ] using MeasureTheory.norm_integral_le_integral_norm ( f - g );
    nlinarith [ abs_le.mp h_integral_bound, Real.pi_gt_three, mul_div_cancel₀ ( 2 : ℝ ) Real.pi_ne_zero ]

/-
HasAbsSinLimit is linear and holds for indicator functions of intervals.
-/
lemma HasAbsSinLimit_add {f g : ℝ → ℝ} (hf : HasAbsSinLimit f) (hg : HasAbsSinLimit g)
    (hf_int : MeasureTheory.Integrable f) (hg_int : MeasureTheory.Integrable g) :
    HasAbsSinLimit (f + g) := by
      unfold HasAbsSinLimit at *;
      convert hf.add hg using 2 <;> norm_num [ add_mul ];
      · rw [ MeasureTheory.integral_add ];
        · refine' hf_int.norm.mono' _ _;
          · exact hf_int.1.mul ( Continuous.aestronglyMeasurable ( Real.continuous_sin.abs.comp ( continuous_const.mul continuous_id' ) ) );
          · filter_upwards [ ] with x using by simpa [ abs_mul ] using mul_le_mul_of_nonneg_left ( Real.abs_sin_le_one _ ) ( abs_nonneg _ ) ;
        · refine' hg_int.norm.mono' _ _;
          · exact hg_int.1.mul ( Continuous.aestronglyMeasurable ( Real.continuous_sin.abs.comp ( continuous_const.mul continuous_id' ) ) );
          · filter_upwards [ ] with x using by simpa using mul_le_mul_of_nonneg_left ( Real.abs_sin_le_one _ ) ( abs_nonneg _ ) ;
      · rw [ ← mul_add, MeasureTheory.integral_add hf_int hg_int ]

lemma HasAbsSinLimit_smul {f : ℝ → ℝ} (c : ℝ) (hf : HasAbsSinLimit f) (hf_int : MeasureTheory.Integrable f) :
    HasAbsSinLimit (c • f) := by
      convert hf.const_mul c using 1;
      unfold HasAbsSinLimit; norm_num [ mul_assoc, mul_comm, mul_left_comm, ← MeasureTheory.integral_const_mul ] ;

lemma HasAbsSinLimit_indicator_Ioc {a b : ℝ} (h : a ≤ b) :
    HasAbsSinLimit (Set.indicator (Set.Ioc a b) 1) := by
      -- By lemma 3, we know that $\int_a^b |\sin(nx)| \, dx \to \frac{2}{\pi} (b - a)$ as $n \to \infty$.
      have h_integral : Filter.Tendsto (fun n : ℕ => ∫ x in a..b, |Real.sin ((n : ℝ) * x)|) Filter.atTop (nhds ((2 / Real.pi) * (b - a))) := by
        exact?;
      unfold HasAbsSinLimit;
      simp_all +decide [ intervalIntegral.integral_of_le h, MeasureTheory.integral_indicator ];
      convert h_integral using 2 ; rw [ ← MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ]

/-
Checking for density of continuous functions with compact support in L1.
-/
#check MeasureTheory.Integrable.exists_hasCompactSupport_integral_sub_le
#check Continuous.integrable_of_hasCompactSupport

/-
Checking Submodule.span_induction and Set.Ioc_eq_empty
-/
#check Submodule.span_induction
#check Set.Ioc_eq_empty

/-
HasAbsSinLimit holds for the indicator function of any interval (a, b].
-/
lemma HasAbsSinLimit_indicator_Ioc_general (a b : ℝ) :
    HasAbsSinLimit (Set.indicator (Set.Ioc a b) 1) := by
      by_cases hab : a ≤ b;
      · exact?;
      · simp +decide [ Set.Ioc_eq_empty_of_le ( le_of_not_ge hab ), HasAbsSinLimit ]

/-
Checking if HasAbsSinLimit_indicator_Ioc_general exists.
-/
#check HasAbsSinLimit_indicator_Ioc_general

/-
Step functions are integrable and satisfy the limit property.
-/
lemma HasAbsSinLimit_zero : HasAbsSinLimit 0 := by
  -- The integral of the zero function is zero, so the limit is trivially zero.
  simp [HasAbsSinLimit]

def IsStepFunction (f : ℝ → ℝ) : Prop :=
  f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) (1 : ℝ → ℝ)))

lemma Integrable_of_IsStepFunction {f : ℝ → ℝ} (hf : IsStepFunction f) :
    MeasureTheory.Integrable f := by
      revert hf;
      refine' Submodule.span_induction _ _ _ _;
      · rintro _ ⟨ p, rfl ⟩ ; exact MeasureTheory.integrable_indicator_iff ( measurableSet_Ioc ) |>.2 ( MeasureTheory.integrable_const _ ) ;
      · exact MeasureTheory.integrable_zero _ _ _;
      · exact fun x y hx hy hx' hy' => hx'.add hy';
      · exact fun a x hx hx' => hx'.smul a

lemma HasAbsSinLimit_of_IsStepFunction {f : ℝ → ℝ} (hf : IsStepFunction f) :
    HasAbsSinLimit f := by
      contrapose! hf;
      intro h;
      apply hf;
      -- Prove HasAbsSinLimit for 0.
      have h_zero : HasAbsSinLimit (fun _ => 0) := by
        unfold HasAbsSinLimit; norm_num;
      -- Prove Integrable for StepFunction by induction on span.
      have h_integrable : ∀ (f : ℝ → ℝ), f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) 1)) → MeasureTheory.Integrable f := by
        exact?;
      -- Prove HasAbsSinLimit for StepFunction by induction on span.
      have h_has_abs_sin_limit : ∀ (f : ℝ → ℝ), f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) 1)) → HasAbsSinLimit f := by
        intro f hf
        induction' hf using Submodule.span_induction with f g hf hg ihf ihg;
        · obtain ⟨ p, rfl ⟩ := g; exact HasAbsSinLimit_indicator_Ioc_general p.1 p.2;
        · exact h_zero;
        · exact HasAbsSinLimit_add ‹_› ‹_› ( h_integrable _ ihf ) ( h_integrable _ ihg );
        · exact HasAbsSinLimit_smul _ ‹_› ( h_integrable _ ‹_› );
      exact h_has_abs_sin_limit f h

/-
Checking if HasAbsSinLimit_indicator_Ioc_general is already defined.
-/
#check HasAbsSinLimit_indicator_Ioc_general

/-
Checking signatures of Integrable.indicator and Integrable.smul
-/
#check MeasureTheory.Integrable.indicator
#check MeasureTheory.Integrable.smul

/-
Step functions are integrable and satisfy the limit property.
-/
lemma HasAbsSinLimit_zero' : HasAbsSinLimit 0 := by
  exact?

def IsStepFunction' (f : ℝ → ℝ) : Prop :=
  f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) (1 : ℝ → ℝ)))

lemma Integrable_of_IsStepFunction' {f : ℝ → ℝ} (hf : IsStepFunction' f) :
    MeasureTheory.Integrable f := by
      exact?

lemma HasAbsSinLimit_of_IsStepFunction' {f : ℝ → ℝ} (hf : IsStepFunction' f) :
    HasAbsSinLimit f := by
      exact?

/-
Checking availability of measure_Ioc_lt_top, Real.volume_Ioc, IsStepFunction, and IsStepFunction'.
-/
#check measure_Ioc_lt_top
#check Real.volume_Ioc
#check IsStepFunction
#check IsStepFunction'

/-
Step functions are integrable and satisfy the limit property.
-/
lemma HasAbsSinLimit_zero'' : HasAbsSinLimit 0 := by
  exact?

def IsStepFunction'' (f : ℝ → ℝ) : Prop :=
  f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) (1 : ℝ → ℝ)))

lemma Integrable_of_IsStepFunction'' {f : ℝ → ℝ} (hf : IsStepFunction'' f) :
    MeasureTheory.Integrable f MeasureTheory.volume := by
      exact?

lemma HasAbsSinLimit_of_IsStepFunction'' {f : ℝ → ℝ} (hf : IsStepFunction'' f) :
    HasAbsSinLimit f := by
      exact?

/-
Step functions are integrable and satisfy the limit property.
-/
lemma HasAbsSinLimit_zero_v3 : HasAbsSinLimit 0 := by
  exact?

def IsStepFunction_v3 (f : ℝ → ℝ) : Prop :=
  f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) (1 : ℝ → ℝ)))

lemma Integrable_of_IsStepFunction_v3 {f : ℝ → ℝ} (hf : IsStepFunction_v3 f) :
    MeasureTheory.Integrable f MeasureTheory.volume := by
      exact?

lemma HasAbsSinLimit_of_IsStepFunction_v3 {f : ℝ → ℝ} (hf : IsStepFunction_v3 f) :
    HasAbsSinLimit f := by
      exact?

/-
Step functions are integrable and satisfy the limit property.
-/
lemma HasAbsSinLimit_zero_v4 : HasAbsSinLimit 0 := by
  exact?

def IsStepFunction_v4 (f : ℝ → ℝ) : Prop :=
  f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) (1 : ℝ → ℝ)))

lemma Integrable_of_IsStepFunction_v4 {f : ℝ → ℝ} (hf : IsStepFunction_v4 f) :
    MeasureTheory.Integrable f MeasureTheory.volume := by
      exact?

lemma HasAbsSinLimit_of_IsStepFunction_v4 {f : ℝ → ℝ} (hf : IsStepFunction_v4 f) :
    HasAbsSinLimit f := by
      exact?

/-
Step functions are integrable and satisfy the limit property.
-/
lemma HasAbsSinLimit_zero_v5 : HasAbsSinLimit 0 := by
  exact HasAbsSinLimit_zero

def IsStepFunction_v5 (f : ℝ → ℝ) : Prop :=
  f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) (1 : ℝ → ℝ)))

lemma Integrable_of_IsStepFunction_v5 {f : ℝ → ℝ} (hf : IsStepFunction_v5 f) :
    MeasureTheory.Integrable f MeasureTheory.volume := by
      exact?

lemma HasAbsSinLimit_of_IsStepFunction_v5 {f : ℝ → ℝ} (hf : IsStepFunction_v5 f) :
    HasAbsSinLimit f := by
      exact?

/-
Step functions are integrable and satisfy the limit property.
-/
lemma HasAbsSinLimit_zero_v6 : HasAbsSinLimit 0 := by
  exact HasAbsSinLimit_zero

def IsStepFunction_v6 (f : ℝ → ℝ) : Prop :=
  f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) (1 : ℝ → ℝ)))

lemma Integrable_of_IsStepFunction_v6 {f : ℝ → ℝ} (hf : IsStepFunction_v6 f) :
    MeasureTheory.Integrable f MeasureTheory.volume := by
      exact?

lemma HasAbsSinLimit_of_IsStepFunction_v6 {f : ℝ → ℝ} (hf : IsStepFunction_v6 f) :
    HasAbsSinLimit f := by
      exact?

/-
Checking the signature of Submodule.span_induction.
-/
#check Submodule.span_induction

/-
Step functions are integrable.
-/
def IsStepFunction_v7 (f : ℝ → ℝ) : Prop :=
  f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) (1 : ℝ → ℝ)))

lemma Integrable_of_IsStepFunction_v7 {f : ℝ → ℝ} (hf : IsStepFunction_v7 f) :
    MeasureTheory.Integrable f MeasureTheory.volume := by
      exact?

/-
Step functions are integrable and satisfy the limit property.
-/
def IsStepFunction_v8 (f : ℝ → ℝ) : Prop :=
  f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) (1 : ℝ → ℝ)))

lemma Integrable_of_IsStepFunction_v8 {f : ℝ → ℝ} (hf : IsStepFunction_v8 f) :
    MeasureTheory.Integrable f MeasureTheory.volume := by
      exact?
      skip

lemma HasAbsSinLimit_of_IsStepFunction_v8 {f : ℝ → ℝ} (hf : IsStepFunction_v8 f) :
    HasAbsSinLimit f := by
      exact?

/-
Step functions are integrable and satisfy the limit property.
-/
def IsStepFunction_v9 (f : ℝ → ℝ) : Prop :=
  f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) (1 : ℝ → ℝ)))

lemma Integrable_of_IsStepFunction_v9 {f : ℝ → ℝ} (hf : IsStepFunction_v9 f) :
    MeasureTheory.Integrable f MeasureTheory.volume := by
      exact?

lemma HasAbsSinLimit_of_IsStepFunction_v9 {f : ℝ → ℝ} (hf : IsStepFunction_v9 f) :
    HasAbsSinLimit f := by
      exact?

/-
Step functions are integrable and satisfy the limit property.
-/
def IsStepFunction_v10 (f : ℝ → ℝ) : Prop :=
  f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) (1 : ℝ → ℝ)))

lemma Integrable_of_IsStepFunction_v10 {f : ℝ → ℝ} (hf : IsStepFunction_v10 f) :
    MeasureTheory.Integrable f MeasureTheory.volume := by
      exact?

lemma HasAbsSinLimit_of_IsStepFunction_v10 {f : ℝ → ℝ} (hf : IsStepFunction_v10 f) :
    HasAbsSinLimit f := by
      exact?

/-
Step functions are integrable and satisfy the limit property.
-/
lemma HasAbsSinLimit_zero_v11 : HasAbsSinLimit 0 := by
  exact?

def IsStepFunction_v11 (f : ℝ → ℝ) : Prop :=
  f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) (1 : ℝ → ℝ)))

lemma Integrable_of_IsStepFunction_v11 {f : ℝ → ℝ} (hf : IsStepFunction_v11 f) :
    MeasureTheory.Integrable f MeasureTheory.volume := by
      exact?

lemma HasAbsSinLimit_of_IsStepFunction_v11 {f : ℝ → ℝ} (hf : IsStepFunction_v11 f) :
    HasAbsSinLimit f := by
      exact?

/-
Step functions are integrable and satisfy the limit property.
-/
def IsStepFunction_Final (f : ℝ → ℝ) : Prop :=
  f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) (1 : ℝ → ℝ)))

lemma Integrable_of_IsStepFunction_Final {f : ℝ → ℝ} (hf : IsStepFunction_Final f) :
    MeasureTheory.Integrable f MeasureTheory.volume := by
      exact?

lemma HasAbsSinLimit_zero_Final : HasAbsSinLimit 0 := by
  exact?

lemma HasAbsSinLimit_of_IsStepFunction_Final {f : ℝ → ℝ} (hf : IsStepFunction_Final f) :
    HasAbsSinLimit f := by
      exact HasAbsSinLimit_of_IsStepFunction_v11 hf

/-
Step functions are integrable and satisfy the limit property.
-/
def IsStepFunction_Final2 (f : ℝ → ℝ) : Prop :=
  f ∈ Submodule.span ℝ (Set.range (fun (p : ℝ × ℝ) => Set.indicator (Set.Ioc p.1 p.2) (1 : ℝ → ℝ)))

lemma Integrable_of_IsStepFunction_Final2 {f : ℝ → ℝ} (hf : IsStepFunction_Final2 f) :
    MeasureTheory.Integrable f MeasureTheory.volume := by
      exact?

lemma HasAbsSinLimit_of_IsStepFunction_Final2 {f : ℝ → ℝ} (hf : IsStepFunction_Final2 f) :
    HasAbsSinLimit f := by
      exact?

/-
Checking boundedness lemmas.
-/
#check IsCompact.isBounded
#check Bornology.IsBounded.subset_Icc_sInf_sSup

/-
Continuous functions with compact support can be approximated by step functions in L1.
-/
lemma ContinuousHasCompactSupport_approx_by_StepFunction {f : ℝ → ℝ}
    (hf_cont : Continuous f) (hf_supp : HasCompactSupport f) {ε : ℝ} (hε : 0 < ε) :
    ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
  by_contra h_contra;
  -- Since f has compact support, there exists an interval [a, b] containing the support.
  obtain ⟨a, b, hab⟩ : ∃ a b : ℝ, a ≤ b ∧ ∀ x, x ∉ Set.Icc a b → f x = 0 := by
    have := hf_supp.isCompact.isBounded.exists_pos_norm_le;
    obtain ⟨ R, hR₀, hR ⟩ := this; exact ⟨ -R, R, by linarith, fun x hx => Classical.not_not.1 fun hx' => hx <| ⟨ by linarith [ abs_le.mp ( hR x <| subset_closure hx' ) ], by linarith [ abs_le.mp ( hR x <| subset_closure hx' ) ] ⟩ ⟩ ;
  -- Since f is uniformly continuous on [a, b], we can find a partition of [a, b] such that the variation of f on each subinterval is less than ε / (2 * (b - a + 1)).
  obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ x y, x ∈ Set.Icc a b → y ∈ Set.Icc a b → |x - y| < δ → |f x - f y| < ε / (2 * (b - a + 1)) := by
    have h_unif_cont : UniformContinuousOn f (Set.Icc a b) := by
      exact ( isCompact_Icc.uniformContinuousOn_of_continuous hf_cont.continuousOn );
    exact Metric.uniformContinuousOn_iff.mp h_unif_cont ( ε / ( 2 * ( b - a + 1 ) ) ) ( div_pos hε ( by linarith ) ) |> Exists.imp fun δ hδ => by tauto;
  -- Construct a partition of [a, b] with mesh less than δ.
  obtain ⟨n, hn⟩ : ∃ n : ℕ, n > 0 ∧ (b - a) / n < δ := by
    exact ⟨ ⌊ ( b - a ) / δ⌋₊ + 1, Nat.succ_pos _, by rw [ div_lt_iff₀ ] <;> push_cast <;> nlinarith [ Nat.lt_floor_add_one ( ( b - a ) / δ ), mul_div_cancel₀ ( b - a ) hδ_pos.ne' ] ⟩;
  -- Define a step function $g$ on this partition.
  obtain ⟨g, hg⟩ : ∃ g : ℝ → ℝ, (∀ x, x ∉ Set.Icc a b → g x = 0) ∧ (∀ i ∈ Finset.range n, ∀ x ∈ Set.Ioc (a + i * (b - a) / n) (a + (i + 1) * (b - a) / n), g x = f (a + i * (b - a) / n)) ∧ IsStepFunction_Final2 g := by
    refine' ⟨ fun x => ∑ i ∈ Finset.range n, ( if x ∈ Set.Ioc ( a + i * ( b - a ) / n ) ( a + ( i + 1 ) * ( b - a ) / n ) then f ( a + i * ( b - a ) / n ) else 0 ), _, _, _ ⟩ <;> norm_num;
    · intro x hx; rw [ Finset.sum_eq_zero ] ; intros i hi; split_ifs <;> norm_num;
      exact False.elim <| hx ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( i : ℝ ) + 1 ) * ( b - a ) ) ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ) ] ) |> not_lt_of_ge ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( i : ℝ ) + 1 ) * ( b - a ) ) ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ) ] );
    · intro i hi x hx₁ hx₂; rw [ Finset.sum_eq_single i ] <;> simp_all +decide [ mul_comm ] ;
      intro j hj₁ hj₂ hj₃ hj₄; exact False.elim <| hj₂ <| Nat.le_antisymm ( Nat.le_of_lt_succ <| by { rw [ ← @Nat.cast_lt ℝ ] ; push_cast; ring_nf at *; nlinarith [ mul_inv_cancel₀ ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ) ] } ) ( Nat.le_of_lt_succ <| by { rw [ ← @Nat.cast_lt ℝ ] ; push_cast; ring_nf at *; nlinarith [ mul_inv_cancel₀ ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ) ] } ) ;
    · -- Each term in the sum is a step function, and the sum of step functions is also a step function.
      have h_step : ∀ i ∈ Finset.range n, IsStepFunction_Final2 (fun x => if a + i * (b - a) / n < x ∧ x ≤ a + (i + 1) * (b - a) / n then f (a + i * (b - a) / n) else 0) := by
        intro i hi
        have h_step : IsStepFunction_Final2 (fun x => if a + i * (b - a) / n < x ∧ x ≤ a + (i + 1) * (b - a) / n then 1 else 0) := by
          exact Submodule.subset_span ⟨ ( a + i * ( b - a ) / n, a + ( i + 1 ) * ( b - a ) / n ), by aesop ⟩;
        convert Submodule.smul_mem _ ( f ( a + i * ( b - a ) / n ) ) h_step using 1 ; ext ; aesop;
      convert Submodule.sum_mem _ fun i hi => h_step i hi using 1;
      exact?;
  -- Show that |f - g| is small on each subinterval.
  have h_small : ∀ i ∈ Finset.range n, ∫ x in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), |f x - g x| ≤ ε / (2 * (b - a + 1)) * ((b - a) / n) := by
    intros i hi
    have h_small_subinterval : ∀ x ∈ Set.Ioc (a + i * (b - a) / n) (a + (i + 1) * (b - a) / n), |f x - g x| ≤ ε / (2 * (b - a + 1)) := by
      intros x hx
      have hxy : |x - (a + i * (b - a) / n)| < δ := by
        exact abs_lt.mpr ⟨ by ring_nf at *; linarith [ hx.1, hx.2 ], by ring_nf at *; linarith [ hx.1, hx.2, hn.2 ] ⟩;
      rw [ hg.2.1 i hi x hx ] ; exact le_of_lt ( hδ x ( a + i * ( b - a ) / n ) ⟨ by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], div_mul_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ), hx.1 ], by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], div_mul_cancel₀ ( ( i + 1 : ℝ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ), hx.2 ] ⟩ ⟨ by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], div_mul_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ) ], by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], div_mul_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ) ] ⟩ hxy ) ;
    rw [ intervalIntegral.integral_of_le ];
    · refine' le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _;
      refine' fun x => ε / ( 2 * ( b - a + 1 ) );
      · exact Filter.Eventually.of_forall fun x => abs_nonneg _;
      · norm_num;
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx using h_small_subinterval x hx;
      · norm_num [ mul_div, mul_comm ];
        rw [ max_eq_left ( by ring_nf; nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_inv_cancel₀ ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ) ] ) ] ; ring_nf; norm_num;
    · bound;
  -- Summing these inequalities over all subintervals, we get the desired result.
  have h_sum : ∫ x in Set.Icc a b, |f x - g x| ≤ ε / (2 * (b - a + 1)) * (b - a) := by
    have h_sum : ∫ x in Set.Icc a b, |f x - g x| = ∑ i ∈ Finset.range n, ∫ x in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), |f x - g x| := by
      rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le hab.1 ];
      symm;
      convert intervalIntegral.sum_integral_adjacent_intervals _ <;> norm_num [ hn.1.ne' ];
      intro k hk;
      rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le ];
      · rw [ MeasureTheory.integrableOn_congr_fun ( fun x hx => by rw [ hg.2.1 k ( Finset.mem_range.mpr hk ) x hx ] ) measurableSet_Ioc ];
        exact Continuous.integrableOn_Ioc ( by continuity );
      · bound;
    exact h_sum.symm ▸ le_trans ( Finset.sum_le_sum h_small ) ( by norm_num [ mul_assoc, mul_comm, mul_left_comm, div_eq_mul_inv, hn.1.ne' ] );
  -- Since $|f - g|$ is zero outside $[a, b]$, we can extend the integral to the entire real line.
  have h_ext : ∫ x, |f x - g x| = ∫ x in Set.Icc a b, |f x - g x| := by
    rw [ MeasureTheory.setIntegral_eq_integral_of_forall_compl_eq_zero ] ; aesop;
  exact h_contra ⟨ g, hg.2.2, by rw [ h_ext ] ; exact h_sum.trans_lt ( by rw [ div_mul_eq_mul_div, div_lt_iff₀ ] <;> nlinarith ) ⟩

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      have h_dense : ∀ ε > 0, ∃ g : ℝ → ℝ, IsStepFunction_Final2 g ∧ ∫ x, abs (f x - g x) < ε := by
        intro ε hε_pos
        have h_cont : ∃ g : ℝ → ℝ, Continuous g ∧ HasCompactSupport g ∧ ∫ x, abs (f x - g x) < ε / 2 := by
          have h_dense : ∀ ε > 0, ∃ g : ℝ → ℝ, Continuous g ∧ HasCompactSupport g ∧ (∫ x, |f x - g x|) < ε := by
            intro ε hε_pos
            have := @MeasureTheory.Integrable.exists_hasCompactSupport_integral_sub_le;
            exact Exists.elim ( this hf ( half_pos hε_pos ) ) fun g hg => ⟨ g, hg.2.2.1, hg.1, hg.2.1.trans_lt ( half_lt_self hε_pos ) ⟩;
          exact h_dense _ ( half_pos hε_pos )
        obtain ⟨ g, hg_cont, hg_supp, hg_int ⟩ := h_cont
        obtain ⟨ h, hh_step, hh_int ⟩ := ContinuousHasCompactSupport_approx_by_StepFunction hg_cont hg_supp (half_pos hε_pos);
        refine' ⟨ h, hh_step, lt_of_le_of_lt ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ ⟩;
        refine' fun x => |f x - g x| + |g x - h x|;
        · exact Filter.Eventually.of_forall fun x => abs_nonneg _;
        · refine' MeasureTheory.Integrable.add _ _;
          · exact MeasureTheory.Integrable.abs ( hf.sub ( hg_cont.integrable_of_hasCompactSupport hg_supp ) );
          · exact MeasureTheory.Integrable.abs ( MeasureTheory.Integrable.sub ( hg_cont.integrable_of_hasCompactSupport hg_supp ) ( Integrable_of_IsStepFunction_Final2 hh_step ) );
        · filter_upwards [ ] with x using abs_sub_le _ _ _;
        · rw [ MeasureTheory.integral_add ];
          · linarith;
          · exact MeasureTheory.Integrable.abs ( hf.sub ( hg_cont.integrable_of_hasCompactSupport hg_supp ) );
          · exact MeasureTheory.Integrable.abs ( MeasureTheory.Integrable.sub ( hg_cont.integrable_of_hasCompactSupport hg_supp ) ( Integrable_of_IsStepFunction_Final2 hh_step ) );
      assumption

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final2 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final3 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Checking abs_sub_le and add_lt_add_of_le_of_lt
-/
#check abs_sub_le
#check add_lt_add_of_le_of_lt

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final4 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Checking lemmas for compact support and uniform continuity.
-/
#check HasCompactSupport.isCompact
#check IsCompact.isBounded
#check Bornology.IsBounded.subset_Icc_sInf_sSup
#check Metric.uniformContinuousOn_iff
#check isCompact_Icc
#check IsCompact.uniformContinuousOn_of_continuous

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final5 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final6 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final7 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Polya-Szego Problem 117: If f is integrable, then integral of f(x)sin(nx) -> 0 and integral of f(x)|sin(nx)| -> (2/pi) * integral of f(x).
-/
theorem problem_117 {f : ℝ → ℝ} (hf_loc : ∀ (a b : ℝ), IntervalIntegrable f MeasureTheory.volume a b)
    (hf_abs_int : MeasureTheory.Integrable f) :
    Filter.Tendsto (fun (n : ℕ) => ∫ x : ℝ, f x * Real.sin ((n : ℝ) * x)) Filter.atTop (nhds 0) ∧
    Filter.Tendsto (fun (n : ℕ) => ∫ x : ℝ, f x * |Real.sin ((n : ℝ) * x)|) Filter.atTop
      (nhds ((2/Real.pi) * ∫ x : ℝ, f x)) := by
        refine' ⟨ problem_117_part1 hf_abs_int, _ ⟩;
        apply_rules [ hasAbsSinLimit_of_approx, hf_abs_int ];
        intro ε hε_pos
        obtain ⟨g, hg_step, hg_approx⟩ : ∃ g : ℝ → ℝ, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
          exact?;
        exact ⟨ g, HasAbsSinLimit_of_IsStepFunction_Final2 hg_step, Integrable_of_IsStepFunction_Final2 hg_step, hg_approx ⟩

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final_v3 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final8 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final9 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Checking add_lt_add_of_le_of_lt and Real.norm_eq_abs
-/
#check add_lt_add_of_le_of_lt
#check Real.norm_eq_abs

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final10 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final11 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final12 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final13 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final14 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Checking if ContinuousHasCompactSupport_approx_by_StepFunction is available.
-/
#check ContinuousHasCompactSupport_approx_by_StepFunction

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final15 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      exact?

/-
Step functions are dense in L1.
-/
lemma IsStepFunction_dense_L1_Final16 {f : ℝ → ℝ} (hf : MeasureTheory.Integrable f) :
    ∀ ε > 0, ∃ g, IsStepFunction_Final2 g ∧ ∫ x, |f x - g x| < ε := by
      -- Apply the density lemma to obtain the existence of such a step function g.
      apply IsStepFunction_dense_L1_Final15; assumption

/-
Polya-Szego Problem 117: If f is integrable, then integral of f(x)sin(nx) -> 0 and integral of f(x)|sin(nx)| -> (2/pi) * integral of f(x).
-/
theorem problem_117_final {f : ℝ → ℝ} (hf_loc : ∀ (a b : ℝ), IntervalIntegrable f MeasureTheory.volume a b)
    (hf_abs_int : MeasureTheory.Integrable f) :
    Filter.Tendsto (fun (n : ℕ) => ∫ x : ℝ, f x * Real.sin ((n : ℝ) * x)) Filter.atTop (nhds 0) ∧
    Filter.Tendsto (fun (n : ℕ) => ∫ x : ℝ, f x * |Real.sin ((n : ℝ) * x)|) Filter.atTop
      (nhds ((2/Real.pi) * ∫ x : ℝ, f x)) := by
        apply problem_117 hf_loc hf_abs_int