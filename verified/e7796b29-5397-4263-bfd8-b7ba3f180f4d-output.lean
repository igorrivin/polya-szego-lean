/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e7796b29-5397-4263-bfd8-b7ba3f180f4d
-/

/-
We formalized Polya-Szego Problem 132.1 regarding the rearrangement of the alternating harmonic product.
We defined the partial product `P p q m` corresponding to taking `p` positive terms and `q` negative terms in each block `m`.
We proved that this sequence converges to `√(p/q)` as `m → ∞`.
The proof relies on relating the partial products to the Wallis product for `π`.
Specifically, we showed that the squared partial product can be expressed in terms of the Wallis product sequence, allowing us to derive the limit.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def R (n : ℕ) : ℝ :=
  ∏ k ∈ Finset.range n, ((2:ℝ) * (k:ℝ) + 1) / ((2:ℝ) * (k:ℝ))

def partial_product (p q m : ℕ) : ℝ :=
  ∏ b ∈ Finset.range m, (∏ i ∈ Finset.range p, (1 + 1/((2:ℝ) * ((b*(p+q) + i):ℝ) + 2))) *
                         ∏ j ∈ Finset.range q, (1 - 1/((2:ℝ) * ((b*(p+q) + p + j):ℝ) + 3))

#check Real.Wallis.W
#check Real.tendsto_prod_pi_div_two

def Q (n : ℕ) : ℝ := ∏ k ∈ Finset.range n, (2 * (k + 1 : ℝ) + 1) / (2 * (k + 1 : ℝ))

def P (p q m : ℕ) : ℝ :=
  ∏ b ∈ Finset.range m,
    (∏ i ∈ Finset.range p, (1 + 1 / (2 * ((b * p + i : ℝ) + 1)))) *
    (∏ j ∈ Finset.range q, (1 - 1 / (2 * ((b * q + j : ℝ) + 1) + 1)))

theorem P_eq_Q_div_Q (p q m : ℕ) : P p q m = Q (p * m) / Q (q * m) := by
  unfold P Q;
  induction' m with m ih <;> simp_all +decide [ Nat.mul_succ, Finset.prod_range_succ ];
  -- Now use the induction hypothesis to simplify the expression.
  field_simp [ih];
  norm_num [ Finset.prod_range_add, mul_add, add_assoc ];
  -- Now use algebra to factor out and simplify:
  field_simp
  ring

lemma Q_sq_eq_div_W (n : ℕ) : (Q n) ^ 2 = (2 * n + 1) / Real.Wallis.W n := by
  -- By definition of $Q$, we know that $Q(n) = \prod_{k=0}^{n-1} \frac{2(k+1)+1}{2(k+1)}$.
  have hQ_def : ∀ n : ℕ, Q n = ∏ k ∈ Finset.range n, (2 * (k + 1) + 1 : ℝ) / (2 * (k + 1)) := by
    exact?;
  field_simp;
  induction n <;> simp_all +decide [ Finset.prod_range_succ ];
  · exact?;
  · simp_all +decide [ mul_div_mul_comm, Real.Wallis.W ];
    simp_all +decide [ Finset.prod_range_succ, mul_pow ];
    -- Combine and simplify the fractions
    field_simp
    ring

lemma tendsto_Q_sq_div_n : Filter.Tendsto (fun n => Q n ^ 2 / n) Filter.atTop (nhds (4 / Real.pi)) := by
  -- Using the fact that $W_n \sim \frac{\pi}{2}$ as $n \to \infty$, we can simplify the expression.
  have h_W : Filter.Tendsto (fun n : ℕ => Real.Wallis.W n) Filter.atTop (nhds (Real.pi / 2)) := by
    convert Real.tendsto_prod_pi_div_two using 1;
  -- Substitute $W_n$ with $Q_n^2$ in the limit expression.
  suffices h_suff'' : Filter.Tendsto (fun n : ℕ => (2 * n + 1) / (n * Real.Wallis.W n)) Filter.atTop (nhds (4 / Real.pi)) by
    refine h_suff''.congr' ?_ ; filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn ; rw [ Q_sq_eq_div_W ] ; ring;
  -- We can divide the numerator and the denominator by $n$.
  suffices h_suff''' : Filter.Tendsto (fun n : ℕ => (2 + 1 / (n : ℝ)) / Real.Wallis.W n) Filter.atTop (nhds (4 / Real.pi)) by
    refine h_suff'''.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn using by rw [ add_div' ] <;> ring ; positivity );
  convert Filter.Tendsto.div ( tendsto_const_nhds.add ( tendsto_one_div_atTop_nhds_zero_nat ) ) h_W _ using 2 <;> ring ; norm_num [ Real.pi_ne_zero ]

theorem problem_132_1_corrected (p q : ℕ) (hp : p > 0) (hq : q > 0) :
    Filter.Tendsto (P p q) Filter.atTop (nhds (Real.sqrt ((p:ℝ) / q))) := by
      -- By combining the previous results, we can conclude
      have h_tendsto : Filter.Tendsto (fun m => Q (p * m) ^ 2 / Q (q * m) ^ 2) Filter.atTop (nhds (p / q)) := by
        -- We'll use the fact that $Q(n)^2 / n$ converges to $4 / \pi$.
        have h_Q_sq_div_n : Filter.Tendsto (fun n => Q n ^ 2 / n) Filter.atTop (nhds (4 / Real.pi)) := by
          exact?;
        have h_Q_ratio : Filter.Tendsto (fun m => (Q (p * m) ^ 2 / (p * m)) / (Q (q * m) ^ 2 / (q * m))) Filter.atTop (nhds ((4 / Real.pi) / (4 / Real.pi))) := by
          exact Filter.Tendsto.div ( by exact_mod_cast h_Q_sq_div_n.comp <| Filter.tendsto_id.nsmul_atTop hp ) ( by exact_mod_cast h_Q_sq_div_n.comp <| Filter.tendsto_id.nsmul_atTop hq ) <| by positivity;
        have := h_Q_ratio.const_mul ( p / q : ℝ ) ; simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, ne_of_gt, Real.pi_pos ] ;
        exact this.congr' ( by filter_upwards [ Filter.eventually_ne_atTop 0 ] with m hm; simp +decide [ hm ] );
      convert h_tendsto.sqrt using 2;
      -- By definition of $P$, we know that $P p q m = Q (p * m) / Q (q * m)$.
      have hP_def : P p q ‹_› = Q (p * ‹_›) / Q (q * ‹_›) := by
        exact?;
      rw [ hP_def, Real.sqrt_div ( by positivity ), Real.sqrt_sq ( by exact Finset.prod_nonneg fun _ _ => by positivity ), Real.sqrt_sq ( by exact Finset.prod_nonneg fun _ _ => by positivity ) ]