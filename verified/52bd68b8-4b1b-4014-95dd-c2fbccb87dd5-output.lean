/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 52bd68b8-4b1b-4014-95dd-c2fbccb87dd5
-/

/-
We have verified Polya-Szego Problem 104.
We defined the function s(x) = 4[x] - 2[2x] + 1 and proved that for any Riemann integrable function f on [0,1], the integral of f(x)s(nx) tends to 0 as n goes to infinity.
The proof proceeds by showing that s(x) is periodic with mean 0, and then using the density of continuous functions (and step functions) in L1 to extend the result from intervals to all integrable functions.
Key lemmas proved include:
- `s_periodic`: s(x) is periodic with period 1.
- `s_mean_zero`: The integral of s over [0,1] is 0.
- `limit_s_interval`: The integral of s(nx) over any interval [a,b] tends to 0.
- `limit_s_continuous`: The result holds for continuous functions.
- `problem_104`: The main theorem.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def s (x : ℝ) : ℝ := 4 * (Int.floor x : ℝ) - 2 * (Int.floor (2 * x) : ℝ) + 1

#check MeasureTheory.volume

/-
The function s(x) is periodic with period 1.
-/
theorem s_periodic (x : ℝ) : s (x + 1) = s x := by
  unfold s;
  norm_num [ mul_add, Int.floor_eq_iff ]

/-
The absolute value of s(x) is always 1.
-/
theorem s_bounded (x : ℝ) : |s x| = 1 := by
  unfold s;
  -- Let's consider the two cases for $x$, $x < \frac{1}{2}$ and $x \geq \frac{1}{2}$.
  by_cases h : x - ⌊x⌋ < 1 / 2;
  · norm_num [ show ⌊2 * x⌋ = 2 * ⌊x⌋ by exact Int.floor_eq_iff.mpr ⟨ by push_cast; linarith [ Int.floor_le x ], by push_cast; linarith [ Int.lt_floor_add_one x ] ⟩ ];
    ring ; norm_num;
  · rw [ abs_of_nonpos ] <;> linarith [ show ( ⌊2 * x⌋ : ℝ ) = 2 * ⌊x⌋ + 1 by exact_mod_cast Int.floor_eq_iff.2 ⟨ by norm_num; linarith [ Int.floor_le x ], by norm_num; linarith [ Int.lt_floor_add_one x ] ⟩ ]

/-
s is integrable on [0,1].
-/
theorem s_integrable : IntervalIntegrable s MeasureTheory.volume 0 1 := by
  rw [ intervalIntegrable_iff_integrableOn_Ioo_of_le ] <;> norm_num [ s ];
  refine' MeasureTheory.Integrable.mono' _ _ _;
  refine' fun x => 1;
  · norm_num;
  · refine' Measurable.aestronglyMeasurable _;
    exact Measurable.add ( Measurable.const_mul ( by exact Measurable.comp ( by measurability ) ( by exact measurable_id'.floor ) ) _ ) ( Measurable.neg ( Measurable.const_mul ( by exact Measurable.comp ( by measurability ) ( by exact measurable_id'.const_mul _ |> Measurable.floor ) ) _ ) ) |> Measurable.add <| measurable_const;
  · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioo ] with x hx using le_of_eq ( s_bounded x )

/-
The integral of s(x) over [0,1] is 0.
-/
theorem s_mean_zero : ∫ x in (0 : ℝ)..1, s x = 0 := by
  -- Let's simplify the integral. Since $s(x)$ is constant on the intervals $[0, 0.5)$ and $(0.5, 1]$, we can split the integral.
  have h_split : ∫ x in (0 : ℝ)..1, s x = (∫ x in (0 : ℝ)..(1 / 2), s x) + (∫ x in (1 / 2 : ℝ)..1, s x) := by
    -- Apply the interval integral addition theorem to split the integral at 1/2.
    have h_split : ∫ x in (0 : ℝ)..1, s x = (∫ x in (0 : ℝ)..(1 / 2), s x) + (∫ x in (1 / 2 : ℝ)..1, s x) := by
      have h_integrable : IntervalIntegrable s MeasureTheory.volume 0 1 := by
        exact?
      rw [ intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ h_integrable.mono_set, Set.Icc_subset_Icc ] <;> norm_num;
    exact h_split;
  -- On the interval [0, 0.5), s(x) = 1, and on the interval (0.5, 1], s(x) = -1.
  have h_values : ∀ x ∈ Set.Ioo (0 : ℝ) (1 / 2), s x = 1 := by
    exact fun x hx => by unfold s; norm_num [ show ⌊x⌋ = 0 by exact Int.floor_eq_iff.mpr ⟨ by norm_num; linarith [ hx.1 ], by norm_num; linarith [ hx.2 ] ⟩, show ⌊2 * x⌋ = 0 by exact Int.floor_eq_iff.mpr ⟨ by norm_num; linarith [ hx.1 ], by norm_num; linarith [ hx.2 ] ⟩ ] ;
  have h_values' : ∀ x ∈ Set.Ioo (1 / 2 : ℝ) 1, s x = -1 := by
    unfold s;
    intro x hx; norm_num [ show ⌊x⌋ = 0 by exact Int.floor_eq_iff.mpr ⟨ by norm_num; linarith [ hx.1 ], by norm_num; linarith [ hx.2 ] ⟩, show ⌊2 * x⌋ = 1 by exact Int.floor_eq_iff.mpr ⟨ by norm_num; linarith [ hx.1 ], by norm_num; linarith [ hx.2 ] ⟩ ] ;
  -- Using the values of $s(x)$ on the intervals $(0, 0.5)$ and $(0.5, 1)$, we can simplify the integrals.
  have h_integral_simplified : (∫ x in (0 : ℝ)..(1 / 2), s x) + (∫ x in (1 / 2 : ℝ)..1, s x) = (∫ x in (0 : ℝ)..(1 / 2), 1) + (∫ x in (1 / 2 : ℝ)..1, -1) := by
    norm_num [ intervalIntegral.integral_of_le ] at *;
    rw [ MeasureTheory.integral_Ioc_eq_integral_Ioo, MeasureTheory.integral_Ioc_eq_integral_Ioo ];
    rw [ MeasureTheory.setIntegral_congr_fun measurableSet_Ioo fun x hx => h_values x hx.1 hx.2, MeasureTheory.setIntegral_congr_fun measurableSet_Ioo fun x hx => h_values' x hx.1 hx.2 ] ; norm_num;
  norm_num [ h_split, h_integral_simplified ]

def S_antideriv (y : ℝ) : ℝ := ∫ t in (0 : ℝ)..y, s t

/-
The antiderivative of s is periodic with period 1.
-/
theorem S_antideriv_periodic (y : ℝ) : S_antideriv (y + 1) = S_antideriv y := by
  -- Using the periodicity of $s$, we can split the integral into two parts:
  have h_split : ∫ x in (0 : ℝ)..y + 1, s x = (∫ x in (0 : ℝ)..1, s x) + (∫ x in (1 : ℝ)..y + 1, s x) := by
    rw [ intervalIntegral.integral_add_adjacent_intervals ];
    · exact?;
    · apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ];
      refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => 1;
      · exact Continuous.integrableOn_Icc ( by continuity );
      · refine' Measurable.aestronglyMeasurable _;
        exact Measurable.sub ( Measurable.mul ( measurable_const ) ( by exact Measurable.comp ( by measurability ) ( Int.measurable_floor ) ) ) ( Measurable.mul ( measurable_const ) ( by exact Measurable.comp ( by measurability ) ( Int.measurable_floor.comp ( measurable_const.mul measurable_id' ) ) ) ) |> Measurable.add <| measurable_const;
      · exact Filter.Eventually.of_forall fun x => s_bounded x ▸ le_rfl;
  -- Using the periodicity of $s$, we can rewrite the second integral as $\int_0^y s(t + 1) \, dt$.
  have h_periodic : ∫ x in (1 : ℝ)..y + 1, s x = ∫ x in (0 : ℝ)..y, s (x + 1) := by
    rw [ intervalIntegral.integral_comp_add_right ] ; ring;
  -- Using the periodicity of $s(x)$, we can simplify the second integral to the integral over $[0, y]$.
  have h_periodic_simplified : ∫ x in (0 : ℝ)..y, s (x + 1) = ∫ x in (0 : ℝ)..y, s x := by
    exact intervalIntegral.integral_congr fun x hx => s_periodic x;
  exact h_split.trans ( by rw [ h_periodic, h_periodic_simplified ] ; linarith! [ s_mean_zero ] )

/-
The antiderivative of s is continuous.
-/
theorem S_antideriv_continuous : Continuous S_antideriv := by
  apply_rules [ intervalIntegral.continuous_primitive ];
  intro a b;
  apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ];
  -- Since $s(x)$ is bounded and piecewise constant, it is integrable on any interval.
  have h_integrable : ∀ x : ℝ, |s x| ≤ 1 := by
    exact fun x => le_of_eq ( s_bounded x );
  refine' MeasureTheory.Integrable.mono' _ _ _;
  refine' fun x => 1;
  · exact Continuous.integrableOn_Icc ( by continuity );
  · refine' Measurable.aestronglyMeasurable _;
    exact Measurable.sub ( Measurable.mul ( measurable_const ) ( by exact Measurable.comp ( by measurability ) Int.measurable_floor ) ) ( Measurable.mul ( measurable_const ) ( by exact Measurable.comp ( by measurability ) ( Int.measurable_floor.comp ( measurable_const.mul measurable_id' ) ) ) ) |> Measurable.add <| measurable_const;
  · exact Filter.Eventually.of_forall h_integrable

/-
The antiderivative of s is bounded.
-/
theorem S_antideriv_bounded_exists : ∃ C, ∀ y, |S_antideriv y| ≤ C := by
  -- Since S_antideriv is continuous and periodic with period 1, it is bounded.
  have h_bounded : ∃ C : ℝ, ∀ y ∈ Set.Icc 0 1, abs (S_antideriv y) ≤ C := by
    exact IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) ( S_antideriv_continuous.continuousOn );
  -- Now use the periodicity of S_antideriv to extend the bound to all y.
  have h_periodic : ∀ y : ℝ, S_antideriv y = S_antideriv (y - ⌊y⌋) := by
    -- By periodicity, we have $S_antideriv(y + 1) = S_antideriv(y)$ for all $y$.
    have h_periodic : ∀ y : ℝ, S_antideriv (y + 1) = S_antideriv y := by
      exact?;
    exact fun x => by simpa using Function.Periodic.int_mul h_periodic ⌊x⌋ ( x - ⌊x⌋ ) ;
  exact ⟨ h_bounded.choose, fun y => h_periodic y ▸ h_bounded.choose_spec _ ⟨ Int.fract_nonneg _, Int.fract_lt_one _ |> le_of_lt ⟩ ⟩

/-
The integral of s(nx) over any interval [a, b] tends to 0 as n goes to infinity.
-/
theorem limit_s_interval (a b : ℝ) :
    Filter.Tendsto (λ (n : ℕ) => ∫ x in a..b, s (n * x)) Filter.atTop (nhds 0) := by
  have int_s_zero : ∀ a b : ℝ, ∫ x in a..b, s (x) = S_antideriv b - S_antideriv a := by
    unfold S_antideriv;
    intro a b; rw [ eq_sub_iff_add_eq', intervalIntegral.integral_add_adjacent_intervals ] ; all_goals apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ];
    · refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => 2;
      · exact Continuous.integrableOn_Icc ( by continuity );
      · refine' Measurable.aestronglyMeasurable _;
        exact Measurable.sub ( Measurable.const_mul ( by exact Measurable.comp ( by measurability ) ( by exact measurable_id'.floor ) ) _ ) ( Measurable.const_mul ( by exact Measurable.comp ( by measurability ) ( by exact measurable_const.mul measurable_id' |> Measurable.floor ) ) _ ) |> Measurable.add <| measurable_const;
      · exact Filter.Eventually.of_forall fun x => abs_le.mpr ⟨ by linarith [ show ( s x : ℝ ) ≥ -1 by exact neg_le_of_abs_le ( by exact s_bounded x |> le_of_eq ) ], by linarith [ show ( s x : ℝ ) ≤ 1 by exact le_of_abs_le ( by exact s_bounded x |> le_of_eq ) ] ⟩;
    · refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => 1;
      · exact Continuous.integrableOn_Icc ( by continuity );
      · refine' Measurable.aestronglyMeasurable _;
        exact Measurable.sub ( Measurable.const_mul ( by exact Measurable.comp ( by measurability ) ( Int.measurable_floor ) ) _ ) ( Measurable.const_mul ( by exact Measurable.comp ( by measurability ) ( Int.measurable_floor.comp ( measurable_const.mul measurable_id' ) ) ) _ ) |> Measurable.add <| measurable_const;
      · exact Filter.Eventually.of_forall fun x => by rw [ Real.norm_eq_abs, s_bounded ] ;
  -- By the properties of the integral, we can rewrite the integral as $\frac{1}{n} \left( S(nb) - S(na) \right)$.
  suffices h_integral : ∀ n : ℕ, n ≠ 0 → ∫ x in a..b, s (n * x) = (1 / (n : ℝ)) * (S_antideriv (n * b) - S_antideriv (n * a)) by
    -- Since $S$ is bounded, the difference $S(nb) - S(na)$ is also bounded.
    obtain ⟨C, hC⟩ : ∃ C, ∀ n : ℕ, |S_antideriv (n * b) - S_antideriv (n * a)| ≤ C := by
      have h_bounded : ∃ C : ℝ, ∀ y : ℝ, abs (S_antideriv y) ≤ C := by
        exact?;
      exact ⟨ h_bounded.choose + h_bounded.choose, fun n => le_trans ( abs_sub _ _ ) ( add_le_add ( h_bounded.choose_spec _ ) ( h_bounded.choose_spec _ ) ) ⟩;
    refine' squeeze_zero_norm' _ _;
    exacts [ fun n => 1 / ( n : ℝ ) * C, Filter.eventually_atTop.mpr ⟨ 1, fun n hn => by rw [ h_integral n ( by positivity ) ] ; simpa [ abs_mul, abs_inv ] using mul_le_mul_of_nonneg_left ( hC n ) ( by positivity ) ⟩, by simpa using tendsto_inverse_atTop_nhds_zero_nat.mul tendsto_const_nhds ];
  intros n hn_ne; rw [ intervalIntegral.integral_comp_mul_left ] <;> aesop;

/-
The integral of s(nx) over the interval [k/n, (k+1)/n] is 0.
-/
theorem integral_s_subinterval (n : ℕ) (hn : n ≠ 0) (k : ℕ) :
  ∫ x in (k : ℝ) / n..((k + 1) : ℝ) / n, s (n * x) = 0 := by
  -- Let $u = nx$. Then $du = ndx$.
  have h_subst : ∫ x in (k / n : ℝ)..((k + 1) / n : ℝ), s (n * x) = (1 / n) * ∫ u in (k : ℝ)..((k + 1) : ℝ), s u := by
    rw [ intervalIntegral.integral_comp_mul_left ] <;> ring <;> aesop;
  -- Since $s$ is periodic with period 1, we have $\int_k^{k+1} s(u) \, du = \int_0^1 s(u) \, du$.
  have h_periodic : ∫ u in (k : ℝ)..((k + 1) : ℝ), s u = ∫ u in (0 : ℝ)..1, s u := by
    convert intervalIntegral.integral_comp_add_right _ ( -k ) using 2 <;> ring;
    funext x; exact (by
    unfold s; norm_num [ Int.floor_eq_iff ] ;
    rw [ show ⌊2 * ( x - k ) ⌋ = ⌊2 * x⌋ - 2 * k by rw [ Int.floor_eq_iff ] ; constructor <;> push_cast <;> linarith [ Int.floor_le ( 2 * x ), Int.lt_floor_add_one ( 2 * x ) ] ] ; push_cast ; ring);
  rw [ h_subst, h_periodic, s_mean_zero, MulZeroClass.mul_zero ]

/-
The limit of the integral of g(x)s(nx) is 0 for continuous g.
-/
theorem limit_s_continuous (g : ℝ → ℝ) (hg : ContinuousOn g (Set.Icc 0 1)) :
    Filter.Tendsto (λ (n : ℕ) => ∫ x in (0 : ℝ)..1, g x * s (n * x)) Filter.atTop (nhds 0) := by
  -- By the properties of the integral, we can pull the constant multiplier out of the integral.
  suffices h : ∀ ε > 0, ∃ N : ℕ, ∀ n ≥ N, |∫ x in (0 : ℝ)..1, g x * s (n * x)| < ε by
    exact Metric.tendsto_atTop.mpr fun ε hε => by simpa using h ε hε;
  -- Consider the integral $\int_0^1 g(x) s(nx) \, dx$. We can split this into the sum of integrals over the subintervals $[k/n, (k+1)/n]$.
  have h_split : ∀ n : ℕ, n ≠ 0 → ∫ x in (0 : ℝ)..1, g x * s (n * x) = ∑ k ∈ Finset.range n, ∫ x in (k / n : ℝ)..((k + 1) / n : ℝ), g x * s (n * x) := by
    intro n hn;
    symm;
    convert intervalIntegral.sum_integral_adjacent_intervals _;
    · norm_num;
    · norm_num;
    · rw [ div_self ( Nat.cast_ne_zero.mpr hn ) ];
    · intro k hk;
      rw [ intervalIntegrable_iff_integrableOn_Ioo_of_le ];
      · refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun x => |g x|;
        · exact MeasureTheory.IntegrableOn.mono_set ( hg.norm.integrableOn_Icc ) ( Set.Ioo_subset_Icc_self.trans ( Set.Icc_subset_Icc ( by positivity ) ( by rw [ div_le_iff₀ ( by positivity ) ] ; norm_cast; linarith ) ) );
        · refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
          · exact hg.aestronglyMeasurable ( measurableSet_Icc ) |> fun h => h.mono_set ( Set.Ioo_subset_Icc_self.trans ( Set.Icc_subset_Icc ( by positivity ) ( by rw [ div_le_iff₀ ( by positivity ) ] ; norm_cast; linarith ) ) );
          · refine' Measurable.aestronglyMeasurable _;
            exact Measurable.comp ( show Measurable s from by rw [ show s = fun x => 4 * ( Int.floor x : ℝ ) - 2 * ( Int.floor ( 2 * x ) : ℝ ) + 1 from funext fun x => rfl ] ; exact Measurable.add ( Measurable.sub ( measurable_const.mul ( by exact Measurable.comp ( by measurability ) ( by exact measurable_id'.floor ) ) ) ( measurable_const.mul ( by exact Measurable.comp ( by measurability ) ( by exact measurable_const.mul measurable_id' |> Measurable.floor ) ) ) ) measurable_const ) ( measurable_const.mul measurable_id' );
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioo ] with x hx using by rw [ Real.norm_eq_abs, abs_mul ] ; exact mul_le_of_le_one_right ( abs_nonneg _ ) ( by rw [ show s ( n * x ) = 4 * ⌊n * x⌋ - 2 * ⌊2 * ( n * x ) ⌋ + 1 from rfl ] ; exact abs_le.mpr ⟨ by linarith [ show ( ⌊n * x⌋ : ℝ ) ≥ 0 by exact_mod_cast Int.floor_nonneg.mpr ( mul_nonneg ( Nat.cast_nonneg _ ) ( le_of_lt ( show 0 < x by exact lt_of_le_of_lt ( by positivity ) hx.1 ) ) ), show ( ⌊2 * ( n * x ) ⌋ : ℝ ) ≤ 2 * ⌊n * x⌋ + 1 by exact_mod_cast Int.le_of_lt_add_one ( Int.floor_lt.mpr ( by norm_num; linarith [ Int.lt_floor_add_one ( n * x ) ] ) ) ], by linarith [ show ( ⌊n * x⌋ : ℝ ) ≥ 0 by exact_mod_cast Int.floor_nonneg.mpr ( mul_nonneg ( Nat.cast_nonneg _ ) ( le_of_lt ( show 0 < x by exact lt_of_le_of_lt ( by positivity ) hx.1 ) ) ), show ( ⌊2 * ( n * x ) ⌋ : ℝ ) ≥ 2 * ⌊n * x⌋ by exact_mod_cast Int.le_floor.mpr ( by push_cast; linarith [ Int.floor_le ( n * x ) ] ) ] ⟩ ) ;
      · bound;
  -- On each subinterval $[k/n, (k+1)/n]$, $g(x)$ is close to $g(k/n)$.
  have h_close : ∀ ε > 0, ∃ N : ℕ, ∀ n ≥ N, ∀ k ∈ Finset.range n, |∫ x in (k / n : ℝ)..((k + 1) / n : ℝ), g x * s (n * x) - g (k / n : ℝ) * s (n * x)| ≤ ε / n := by
    -- Since $g$ is continuous on $[0,1]$, it is uniformly continuous. For any $\epsilon > 0$, there exists $\delta > 0$ such that $|x - y| < \delta$ implies $|g(x) - g(y)| < \epsilon$.
    intro ε hεpos
    obtain ⟨δ, hδpos, hδ⟩ : ∃ δ > 0, ∀ x y : ℝ, 0 ≤ x → x ≤ 1 → 0 ≤ y → y ≤ 1 → |x - y| < δ → |g x - g y| < ε / 2 := by
      have := Metric.uniformContinuousOn_iff.mp ( isCompact_Icc.uniformContinuousOn_of_continuous hg ) ( ε / 2 ) ( half_pos hεpos ) ; aesop;
    refine' ⟨ ⌈δ⁻¹⌉₊ + 1, fun n hn k hk => _ ⟩ ; refine' le_trans ( intervalIntegral.abs_integral_le_integral_abs _ ) _;
    · bound;
    · -- Since $|s(nx)| = 1$, we have $|g(x) * s(nx) - g(k/n) * s(nx)| = |g(x) - g(k/n)|$.
      suffices h_abs : ∫ x in (k / n : ℝ)..((k + 1) / n : ℝ), |g x - g (k / n : ℝ)| ≤ ε / n by
        convert h_abs using 1;
        refine' intervalIntegral.integral_congr fun x hx => _;
        rw [ ← sub_mul, abs_mul ] ; norm_num [ s_bounded ];
      -- Since $|g(x) - g(k/n)| < \epsilon / 2$ for all $x \in [k/n, (k+1)/n]$, we can bound the integral.
      have h_bound : ∀ x ∈ Set.Icc ((k : ℝ) / n) (((k + 1) : ℝ) / n), |g x - g ((k : ℝ) / n)| < ε / 2 := by
        intros x hx;
        exact hδ x ( k / n ) ( by exact le_trans ( by positivity ) hx.1 ) ( by exact le_trans hx.2 ( by rw [ div_le_iff₀ ( by norm_cast; linarith ) ] ; norm_cast; linarith [ Finset.mem_range.mp hk ] ) ) ( by positivity ) ( by rw [ div_le_iff₀ ( by norm_cast; linarith ) ] ; norm_cast; linarith [ Finset.mem_range.mp hk ] ) ( abs_lt.mpr ⟨ by nlinarith [ hx.1, hx.2, show ( n : ℝ ) ≥ ⌈δ⁻¹⌉₊ + 1 by exact_mod_cast hn, Nat.le_ceil ( δ⁻¹ ), mul_inv_cancel₀ ( ne_of_gt hδpos ), div_mul_cancel₀ ( ( k : ℝ ) : ℝ ) ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ), div_mul_cancel₀ ( ( k + 1 : ℝ ) : ℝ ) ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ) ], by nlinarith [ hx.1, hx.2, show ( n : ℝ ) ≥ ⌈δ⁻¹⌉₊ + 1 by exact_mod_cast hn, Nat.le_ceil ( δ⁻¹ ), mul_inv_cancel₀ ( ne_of_gt hδpos ), div_mul_cancel₀ ( ( k : ℝ ) : ℝ ) ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ), div_mul_cancel₀ ( ( k + 1 : ℝ ) : ℝ ) ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ) ] ⟩ );
      refine' le_trans ( intervalIntegral.integral_mono_on _ _ _ fun x hx => le_of_lt ( h_bound x hx ) ) _ <;> norm_num;
      · bound;
      · apply_rules [ ContinuousOn.intervalIntegrable ];
        exact ContinuousOn.abs ( ContinuousOn.sub ( hg.mono ( by rw [ Set.uIcc_of_le ( by rw [ div_le_div_iff_of_pos_right ( by norm_cast; linarith [ Finset.mem_range.mp hk ] ) ] ; linarith ) ] ; exact Set.Icc_subset_Icc ( by positivity ) ( by rw [ div_le_iff₀ ( by norm_cast; linarith [ Finset.mem_range.mp hk ] ) ] ; norm_cast; linarith [ Finset.mem_range.mp hk ] ) ) ) continuousOn_const );
      · ring_nf; norm_num [ show n ≠ 0 by linarith ] ; nlinarith [ inv_mul_cancel₀ ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ) ];
  -- Using the fact that the integral of $g(k/n) * s(nx)$ over $[k/n, (k+1)/n]$ is zero, we can bound the sum.
  have h_bound : ∀ ε > 0, ∃ N : ℕ, ∀ n ≥ N, |∑ k ∈ Finset.range n, ∫ x in (k / n : ℝ)..((k + 1) / n : ℝ), g x * s (n * x)| ≤ ε := by
    intros ε hε_pos
    obtain ⟨N, hN⟩ := h_close ε hε_pos
    use N + 1
    intro n hn
    have h_sum : ∑ k ∈ Finset.range n, ∫ x in (k / n : ℝ)..((k + 1) / n : ℝ), g x * s (n * x) = ∑ k ∈ Finset.range n, (∫ x in (k / n : ℝ)..((k + 1) / n : ℝ), g x * s (n * x) - g (k / n : ℝ) * s (n * x)) := by
      rw [ Finset.sum_congr rfl ] ; intros ; rw [ intervalIntegral.integral_sub ] <;> norm_num;
      · have := integral_s_subinterval n ( by linarith ) ‹_›; aesop;
      · rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le ( by rw [ div_le_div_iff_of_pos_right ( by norm_cast; linarith ) ] ; linarith ) ];
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun x => |g x| * 1;
        · exact ContinuousOn.integrableOn_Icc ( by exact ContinuousOn.mul ( hg.abs.mono ( Set.Icc_subset_Icc ( by positivity ) ( by rw [ div_le_iff₀ ( by norm_cast; linarith ) ] ; norm_cast; linarith [ Finset.mem_range.mp ‹_› ] ) ) ) continuousOn_const ) |> fun h => h.mono_set ( Set.Ioc_subset_Icc_self );
        · refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
          · exact hg.aestronglyMeasurable ( measurableSet_Icc ) |> fun h => h.mono_set ( Set.Ioc_subset_Icc_self.trans ( Set.Icc_subset_Icc ( by positivity ) ( by rw [ div_le_iff₀ ( by norm_cast; linarith ) ] ; norm_cast; linarith [ Finset.mem_range.mp ‹_› ] ) ) );
          · refine' Measurable.aestronglyMeasurable _;
            exact Measurable.comp ( show Measurable s from by exact Measurable.sub ( Measurable.mul ( measurable_const ) ( by exact Measurable.comp ( by measurability ) ( by exact measurable_id'.floor ) ) ) ( Measurable.mul ( measurable_const ) ( by exact Measurable.comp ( by measurability ) ( by exact measurable_id'.floor.comp ( measurable_const.mul measurable_id' ) ) ) ) |> Measurable.add <| measurable_const ) ( measurable_const.mul measurable_id' );
        · simp [s];
          rw [ Filter.eventually_inf_principal ];
          filter_upwards [ ] with x hx using mul_le_of_le_one_right ( abs_nonneg _ ) ( abs_le.mpr ⟨ by linarith [ show ( ⌊ ( n : ℝ ) * x⌋ : ℝ ) ≥ 0 by exact Int.cast_nonneg.mpr ( Int.floor_nonneg.mpr ( mul_nonneg ( Nat.cast_nonneg _ ) ( le_trans ( by positivity ) hx.1.le ) ) ), show ( ⌊2 * ( ( n : ℝ ) * x ) ⌋ : ℝ ) ≤ 2 * ⌊ ( n : ℝ ) * x⌋ + 1 by exact_mod_cast Int.le_of_lt_add_one ( Int.floor_lt.mpr ( by norm_num; linarith [ Int.lt_floor_add_one ( ( n : ℝ ) * x ) ] ) ) ], by linarith [ show ( ⌊ ( n : ℝ ) * x⌋ : ℝ ) ≥ 0 by exact Int.cast_nonneg.mpr ( Int.floor_nonneg.mpr ( mul_nonneg ( Nat.cast_nonneg _ ) ( le_trans ( by positivity ) hx.1.le ) ) ), show ( ⌊2 * ( ( n : ℝ ) * x ) ⌋ : ℝ ) ≥ 2 * ⌊ ( n : ℝ ) * x⌋ by exact_mod_cast Int.le_floor.mpr ( by push_cast; linarith [ Int.floor_le ( ( n : ℝ ) * x ) ] ) ] ⟩ );
      · apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ];
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun x => |g ( ↑‹ℕ› / ↑n )| * 1;
        · exact Continuous.integrableOn_Icc ( by continuity );
        · refine' Measurable.aestronglyMeasurable _;
          apply_rules [ Measurable.mul, Measurable.sub, Measurable.add, measurable_const, measurable_id ];
          · exact Measurable.comp ( by measurability ) ( Measurable.floor ( measurable_const.mul measurable_id' ) );
          · fun_prop;
        · simp [s_bounded];
    exact h_sum.symm ▸ le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( le_trans ( Finset.sum_le_sum fun i hi => hN n ( by linarith ) i hi ) ( by norm_num [ mul_div_cancel₀, show n ≠ 0 by linarith ] ) );
  exact fun ε hε => by obtain ⟨ N, hN ⟩ := h_bound ( ε / 2 ) ( half_pos hε ) ; exact ⟨ N + 1, fun n hn => by rw [ h_split n ( by linarith ) ] ; exact lt_of_le_of_lt ( hN n ( by linarith ) ) ( by linarith ) ⟩ ;

/-
The integral of f(x)s(nx) tends to 0 for any integrable f.
-/
theorem problem_104 (f : ℝ → ℝ) (hf : IntervalIntegrable f MeasureTheory.volume 0 1) :
    Filter.Tendsto (λ (n : ℕ) => ∫ x in (0 : ℝ)..1, f x * s (n * x)) Filter.atTop (nhds 0) := by
  -- By the density of continuous functions in $L^1([0, 1])$, there exists a sequence of continuous functions $g_m$ converging to $f$ in $L^1([0, 1])$.
  obtain ⟨g_seq, hg_seq⟩ : ∃ g_seq : ℕ → ℝ → ℝ, (∀ m, ContinuousOn (g_seq m) (Set.Icc 0 1)) ∧ (∀ m, ∫ x in (Set.Icc 0 1), |f x - g_seq m x| < (1 / (m + 1))) := by
    have h_dense : ∀ ε > 0, ∃ g : ℝ → ℝ, ContinuousOn g (Set.Icc 0 1) ∧ ∫ x in (Set.Icc 0 1), |f x - g x| < ε := by
      have h_dense : ∀ {g : ℝ → ℝ}, MeasureTheory.IntegrableOn g (Set.Icc 0 1) → ∀ ε > 0, ∃ h : ℝ → ℝ, ContinuousOn h (Set.Icc 0 1) ∧ ∫ x in Set.Icc 0 1, |g x - h x| < ε := by
        intro g hg ε ε_pos;
        have := @MeasureTheory.Integrable.exists_hasCompactSupport_integral_sub_le;
        specialize this ( show MeasureTheory.IntegrableOn g ( Set.Icc 0 1 ) MeasureTheory.MeasureSpace.volume from hg ) ( half_pos ε_pos );
        exact ⟨ this.choose, this.choose_spec.2.2.1.continuousOn, lt_of_le_of_lt this.choose_spec.2.1 ( half_lt_self ε_pos ) ⟩;
      apply h_dense;
      rwa [ intervalIntegrable_iff_integrableOn_Icc_of_le zero_le_one ] at hf;
    exact ⟨ fun m => Classical.choose ( h_dense _ <| by positivity ), fun m => Classical.choose_spec ( h_dense _ <| by positivity ) |>.1, fun m => Classical.choose_spec ( h_dense _ <| by positivity ) |>.2 ⟩;
  -- By the triangle inequality and the fact that $|s(nx)| = 1$, we have:
  have h_triangle : ∀ m n : ℕ, |∫ x in (0 : ℝ)..1, f x * s (n * x)| ≤ |∫ x in (0 : ℝ)..1, (f x - g_seq m x) * s (n * x)| + |∫ x in (0 : ℝ)..1, g_seq m x * s (n * x)| := by
    intro m n; rw [ show ( fun x => f x * s ( n * x ) ) = fun x => ( f x - g_seq m x ) * s ( n * x ) + g_seq m x * s ( n * x ) by ext; ring ] ; rw [ intervalIntegral.integral_add ] ;
    · exact?;
    · rw [ intervalIntegrable_iff_integrableOn_Icc_of_le zero_le_one ] at *;
      refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => |f x - g_seq m x| * 1;
      · simpa using MeasureTheory.Integrable.abs ( hf.sub ( hg_seq.1 m |> ContinuousOn.integrableOn_Icc ) );
      · refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
        · exact hf.aestronglyMeasurable.sub ( hg_seq.1 m |> ContinuousOn.aestronglyMeasurable <| measurableSet_Icc );
        · refine' Measurable.aestronglyMeasurable _;
          refine' Measurable.sub _ _ |> Measurable.add <| measurable_const;
          · fun_prop;
          · fun_prop (disch := norm_num);
      · simp [s_bounded];
    · rw [ intervalIntegrable_iff_integrableOn_Icc_of_le zero_le_one ];
      refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => |g_seq m x| * 1;
      · exact ContinuousOn.integrableOn_Icc ( by simpa using hg_seq.1 m |> ContinuousOn.abs );
      · refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
        · exact ContinuousOn.aestronglyMeasurable ( hg_seq.1 m ) measurableSet_Icc;
        · refine' Measurable.aestronglyMeasurable _;
          refine' Measurable.sub _ _ |> Measurable.add <| measurable_const;
          · fun_prop (disch := solve_by_elim);
          · fun_prop;
      · simp [s_bounded];
  -- By the properties of the integral, we can bound the first term:
  have h_bound : ∀ m n : ℕ, |∫ x in (0 : ℝ)..1, (f x - g_seq m x) * s (n * x)| ≤ ∫ x in (Set.Icc 0 1), |f x - g_seq m x| := by
    intro m n;
    rw [ intervalIntegral.integral_of_le zero_le_one, MeasureTheory.integral_Icc_eq_integral_Ioc ];
    refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) ) ( MeasureTheory.integral_mono_of_nonneg _ _ _ );
    · exact Filter.Eventually.of_forall fun x => norm_nonneg _;
    · exact MeasureTheory.Integrable.abs ( hf.1.sub ( hg_seq.1 m |> ContinuousOn.integrableOn_Icc |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self ) );
    · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx using by simpa [ abs_mul, s_bounded ] ;
  -- By the properties of the integral, we can bound the second term:
  have h_bound2 : ∀ m : ℕ, Filter.Tendsto (fun n : ℕ => |∫ x in (0 : ℝ)..1, g_seq m x * s (n * x)|) Filter.atTop (nhds 0) := by
    intro m;
    have := limit_s_continuous ( g_seq m ) ( hg_seq.1 m );
    simpa using this.abs;
  -- By the properties of the integral, we can bound the first term and the second term:
  have h_combined : ∀ ε > 0, ∃ N : ℕ, ∀ n ≥ N, |∫ x in (0 : ℝ)..1, f x * s (n * x)| < ε := by
    intros ε hε_pos
    obtain ⟨m, hm⟩ : ∃ m : ℕ, ∫ x in (Set.Icc 0 1), |f x - g_seq m x| < ε / 2 := by
      exact ⟨ ⌈ε⁻¹ * 2⌉₊, lt_of_lt_of_le ( hg_seq.2 _ ) ( by rw [ div_le_iff₀ ] <;> nlinarith [ Nat.le_ceil ( ε⁻¹ * 2 ), mul_inv_cancel₀ ( ne_of_gt hε_pos ) ] ) ⟩;
    exact Filter.eventually_atTop.mp ( h_bound2 m |> fun h => h.eventually ( gt_mem_nhds <| half_pos hε_pos ) ) |> fun ⟨ N, hN ⟩ => ⟨ N, fun n hn => by linarith [ h_triangle m n, h_bound m n, hN n hn ] ⟩;
  exact Metric.tendsto_atTop.mpr fun ε hε => by simpa using h_combined ε hε;