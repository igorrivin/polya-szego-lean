/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 75416bbf-f018-485a-95ec-5fb92cb76fd9

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A set s separates the signs of f on (a,b) if f does not change sign on any interval in (a,b) disjoint from s.
-/
def IsSignSeparatingSet (f : ℝ → ℝ) (a b : ℝ) (s : Finset ℝ) : Prop :=
  ∀ x ∈ Set.Ioo a b, ∀ y ∈ Set.Ioo a b, (∀ z ∈ s, z ∉ Set.Ioo (min x y) (max x y)) → f x * f y ≥ 0

/-
If the empty set separates the signs of f on (a,b), then f is either non-negative or non-positive on (a,b).
-/
lemma constant_sign_of_empty_separating {f : ℝ → ℝ} {a b : ℝ}
    (hf : ContinuousOn f (Set.Ioo a b)) (h_sep : IsSignSeparatingSet f a b ∅) :
    (∀ x ∈ Set.Ioo a b, 0 ≤ f x) ∨ (∀ x ∈ Set.Ioo a b, f x ≤ 0) := by
  contrapose! h_sep;
  -- By definition of IsSignSeparatingSet, if ∅ is a separating set, then for any x, y in (a, b), f(x) * f(y) ≥ 0.
  simp [IsSignSeparatingSet] at *;
  obtain ⟨ ⟨ x, hx₁, hx₂ ⟩, y, hy₁, hy₂ ⟩ := h_sep; exact ⟨ x, hx₁.1, hx₁.2, y, hy₁.1, hy₁.2, by nlinarith ⟩ ;

/-
Base case: If the empty list separates signs, there exists a sign-matching polynomial (constant).
-/
def PolyFromSublist (sub : List ℝ) : Polynomial ℝ :=
  sub.foldr (fun z p => (Polynomial.X - Polynomial.C z) * p) 1

def HasSignMatchingPoly (f : ℝ → ℝ) (a b : ℝ) (l : List ℝ) : Prop :=
  ∃ sub, List.Sublist sub l ∧ ∃ C : ℝ, C ≠ 0 ∧
  let p := Polynomial.C C * PolyFromSublist sub
  ∀ x ∈ Set.Ioo a b, f x * p.eval x ≥ 0

lemma has_sign_matching_poly_nil {f : ℝ → ℝ} {a b : ℝ} (hab : a < b)
    (hf : ContinuousOn f (Set.Ioo a b)) (h_sep : IsSignSeparatingSet f a b ∅) :
    HasSignMatchingPoly f a b [] := by
  constructor;
  swap;
  exact if h : ∀ x ∈ Set.Ioo a b, 0 ≤ f x then [ ] else [ ];
  split_ifs <;> simp_all +decide [ PolyFromSublist ];
  · exact ⟨ 1, by norm_num, fun x hx₁ hx₂ => mul_nonneg ( by solve_by_elim ) ( by norm_num ) ⟩;
  · exact ⟨ -1, by norm_num, fun x hx₁ hx₂ => by nlinarith [ show f x ≤ 0 from le_of_not_gt fun hx₃ => by obtain ⟨ y, hy₁, hy₂, hy₃ ⟩ := ‹∃ x, a < x ∧ x < b ∧ f x < 0›; exact absurd ( h_sep x ⟨ hx₁, hx₂ ⟩ y ⟨ hy₁, hy₂ ⟩ <| by aesop ) ( by nlinarith ) ] ⟩

/-
If s separates signs and all elements of s are >= x, then f has constant sign on (a, x).
-/
lemma IsSignSeparatingSet_constant_sign_left {f : ℝ → ℝ} {a b x : ℝ} {s : Finset ℝ}
    (hab : a < b) (hx : a < x ∧ x < b)
    (h_sep : IsSignSeparatingSet f a b s)
    (hs_right : ∀ z ∈ s, x ≤ z) :
    (∀ y ∈ Set.Ioo a x, 0 ≤ f y) ∨ (∀ y ∈ Set.Ioo a x, f y ≤ 0) := by
  contrapose! h_sep;
  simp_all +decide [ IsSignSeparatingSet ];
  rcases h_sep with ⟨ ⟨ y, ⟨ hy₁, hy₂ ⟩, hy₃ ⟩, ⟨ z, ⟨ hz₁, hz₂ ⟩, hz₃ ⟩ ⟩ ; exact ⟨ y, hy₁, by linarith, z, hz₁, by linarith, fun w hw₁ hw₂ => ⟨ by cases hw₂ <;> linarith [ hs_right w hw₁ ], by cases hw₂ <;> linarith [ hs_right w hw₁ ] ⟩, by nlinarith ⟩ ;

/-
If all roots in `sub` are greater than x, then for any y < x, the polynomial evaluated at y has the same sign as (-1)^length(sub).
-/
lemma sign_of_poly_from_sublist_left {sub : List ℝ} {x : ℝ}
    (h_right : ∀ z ∈ sub, x < z) :
    ∀ y < x, (PolyFromSublist sub).eval y * (-1)^sub.length > 0 := by
  -- Since `sub.foldr (fun z p => (Polynomial.X - Polynomial.C z) * p) 1` is a polynomial of degree `sub.length`, and `y < x`, we have `(y - z) < 0` for all `z ∈ sub`.
  have h_poly_neg : ∀ y < x, Polynomial.eval y (List.foldr (fun z p => (Polynomial.X - Polynomial.C z) * p) 1 sub) = (-1) ^ sub.length * List.prod (List.map (fun z => z - y) sub) := by
    intros y hy
    induction' sub with z sub ih generalizing y;
    · norm_num;
    · simp_all +decide [ pow_succ', mul_assoc, mul_comm, mul_left_comm, List.prod_cons, List.map_cons ];
      ring;
  -- Since the product of positive numbers is positive, and each term $(z - y)$ is positive for $z \in sub$ and $y < x$, their product is positive.
  have h_prod_pos : ∀ y < x, 0 < List.prod (List.map (fun z => z - y) sub) := by
    intros y hy
    have h_prod_pos : ∀ z ∈ List.map (fun z => z - y) sub, 0 < z := by
      exact fun z hz => by obtain ⟨ w, hw, rfl ⟩ := List.mem_map.mp hz; linarith [ h_right w hw ] ;
    exact?;
  intro y hy; rw [ show PolyFromSublist sub = List.foldr ( fun z p => ( Polynomial.X - Polynomial.C z ) * p ) 1 sub from rfl ] ; rw [ h_poly_neg y hy ] ; cases' Nat.even_or_odd ( List.length sub ) with h h <;> rw [ h.neg_one_pow ] <;> nlinarith [ h_prod_pos y hy ] ;

/-
Helper lemma: If f matches C*p on the right of x, and f and p have constant signs on the left of x, then either C*p or C*(x-x)*p matches f on the whole interval (a,b).
-/
lemma exists_extension_choice {f : ℝ → ℝ} {a b x C : ℝ} {p : Polynomial ℝ}
    (hab : a < b) (hx : a < x ∧ x < b)
    (hf_cont : ContinuousOn f (Set.Ioo a b))
    (hf_match_right : ∀ y ∈ Set.Ioo x b, f y * (C * p.eval y) ≥ 0)
    (hf_const_left : (∀ y ∈ Set.Ioo a x, 0 ≤ f y) ∨ (∀ y ∈ Set.Ioo a x, f y ≤ 0))
    (hp_const_left : ∀ y ∈ Set.Ioo a x, p.eval y ≠ 0)
    (hp_sign_left : ∀ y₁ ∈ Set.Ioo a x, ∀ y₂ ∈ Set.Ioo a x, p.eval y₁ * p.eval y₂ > 0) :
    (∀ y ∈ Set.Ioo a b, f y * (C * p.eval y) ≥ 0) ∨
    (∀ y ∈ Set.Ioo a b, f y * (C * (y - x) * p.eval y) ≥ 0) := by
  -- Since $p$ is continuous and non-zero on $(a,x)$, it must have a constant sign on $(a,x)$.
  have hp_sign_left_cases : (∀ y ∈ Set.Ioo a x, 0 < Polynomial.eval y p) ∨ (∀ y ∈ Set.Ioo a x, Polynomial.eval y p < 0) := by
    exact or_iff_not_imp_left.mpr fun h => by push_neg at h; obtain ⟨ y, hy, hy' ⟩ := h; exact fun z hz => lt_of_le_of_ne ( le_of_not_gt fun hz' => by nlinarith [ hp_sign_left y hy z hz ] ) ( hp_const_left z hz ) ;
  -- Consider the two cases: $C*p(x)$ does not match $f$ on $(a,x)$ or $C*p(x)$ matches $f$ on $(a,x)$.
  by_cases h_case : (∀ y ∈ Set.Ioo a x, f y * (C * p.eval y) ≥ 0) ∨ (∀ y ∈ Set.Ioo a x, f y * (C * p.eval y) ≤ 0);
  · cases' h_case with h_case h_case;
    · refine Or.inl fun y hy => if h : y < x then h_case y ⟨ hy.1, h ⟩ else if h' : y = x then ?_ else hf_match_right y ⟨ lt_of_le_of_ne ( le_of_not_gt h ) ( Ne.symm h' ), hy.2 ⟩;
      have h_lim : Filter.Tendsto (fun y => f y * (C * p.eval y)) (nhdsWithin x (Set.Iio x)) (nhds (f x * (C * p.eval x))) := by
        exact Filter.Tendsto.mul ( hf_cont.continuousAt ( Ioo_mem_nhds hx.1 hx.2 ) |> Filter.Tendsto.mono_left <| nhdsWithin_le_nhds ) ( tendsto_const_nhds.mul <| p.continuous.continuousWithinAt );
      exact h'.symm ▸ le_of_tendsto_of_tendsto tendsto_const_nhds h_lim ( Filter.eventually_of_mem ( Ioo_mem_nhdsLT hx.1 ) fun y hy => h_case y hy );
    · refine Or.inr fun y hy => ?_;
      by_cases hyx : y < x;
      · nlinarith [ h_case y ⟨ hy.1, hyx ⟩, hyx ];
      · by_cases hyx : y = x;
        · aesop;
        · cases lt_or_gt_of_ne hyx <;> nlinarith [ hf_match_right y ⟨ by linarith [ hy.1 ], by linarith [ hy.2 ] ⟩ ];
  · contrapose! h_case; simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ] ;
    cases' hp_sign_left_cases with hp_sign_left_cases hp_sign_left_cases;
    · cases' hf_const_left with hf_const_left hf_const_left;
      · field_simp;
        exact if h : 0 ≤ C then Or.inl fun y hy₁ hy₂ => mul_nonneg ( mul_nonneg h ( hf_const_left y hy₁ hy₂ ) ) ( le_of_lt ( hp_sign_left_cases y hy₁ hy₂ ) ) else Or.inr fun y hy₁ hy₂ => mul_nonpos_of_nonpos_of_nonneg ( mul_nonpos_of_nonpos_of_nonneg ( le_of_not_ge h ) ( hf_const_left y hy₁ hy₂ ) ) ( le_of_lt ( hp_sign_left_cases y hy₁ hy₂ ) );
      · cases' h_case.1 with y hy;
        cases lt_or_gt_of_ne ( show C ≠ 0 by rintro rfl; norm_num at hy ) <;> first | left; intros y hy₁ hy₂ ; nlinarith [ hf_const_left y hy₁ hy₂, hp_sign_left_cases y hy₁ hy₂, mul_le_mul_of_nonneg_right ( hf_const_left y hy₁ hy₂ ) ( le_of_lt ( hp_sign_left_cases y hy₁ hy₂ ) ) ] | right; intros y hy₁ hy₂ ; nlinarith [ hf_const_left y hy₁ hy₂, hp_sign_left_cases y hy₁ hy₂, mul_le_mul_of_nonneg_right ( hf_const_left y hy₁ hy₂ ) ( le_of_lt ( hp_sign_left_cases y hy₁ hy₂ ) ) ] ;
    · cases' hf_const_left with hf_const_left hf_const_left;
      · by_cases hC : C ≥ 0;
        · exact Or.inr fun y hy₁ hy₂ => mul_nonpos_of_nonneg_of_nonpos hC ( mul_nonpos_of_nonneg_of_nonpos ( hf_const_left y hy₁ hy₂ ) ( le_of_lt ( hp_sign_left_cases y hy₁ hy₂ ) ) );
        · exact Or.inl fun y hy₁ hy₂ => by nlinarith [ hf_const_left y hy₁ hy₂, hp_sign_left_cases y hy₁ hy₂, mul_nonneg ( neg_nonneg.mpr ( le_of_not_ge hC ) ) ( hf_const_left y hy₁ hy₂ ) ] ;
      · cases le_or_gt 0 C <;> [ left; right ] <;> intro y hy₁ hy₂ <;> nlinarith [ hf_const_left y hy₁ hy₂, hp_sign_left_cases y hy₁ hy₂, mul_le_mul_of_nonneg_left ( hf_const_left y hy₁ hy₂ ) ( neg_nonneg.mpr ( hp_sign_left_cases y hy₁ hy₂ |> le_of_lt ) ) ]