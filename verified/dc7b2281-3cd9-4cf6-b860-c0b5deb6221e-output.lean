/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: dc7b2281-3cd9-4cf6-b860-c0b5deb6221e
-/

/-
We formalized and proved Polya-Szego Problem 139.
The original statement was slightly incorrect as stated in the formalization because it allowed the interval $[a, b]$ to be a single point, in which case the integral condition is vacuously true but the function need not be zero. We corrected the hypothesis to $a < b$.

The proof proceeds by:
1.  Using the linearity of the integral to show that $\int_a^b f(t) p(t) dt = 0$ for all polynomials $p$.
2.  Using the Weierstrass Approximation Theorem (via `exists_polynomial_near_of_continuousOn`) to approximate any continuous function $g$ by polynomials, thereby showing $\int_a^b f(t) g(t) dt = 0$ for all continuous $g$.
3.  Proving that if $f$ is continuous at $x$ and $f(x) \neq 0$, we can construct a continuous function $g$ (a "bump" function) such that $\int_a^b f(t) g(t) dt \neq 0$, deriving a contradiction. Thus $f(x) = 0$.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
If f is integrable on [a, b] (with a < b) and all its moments ∫_a^b f(t) t^n dt = 0 for n = 0, 1, 2, ..., then f(x) = 0 at every point x ∈ [a, b] where f is continuous.
-/
theorem problem_139 {a b : ℝ} (hab : a < b) {f : ℝ → ℝ}
    (hf_int : IntervalIntegrable f MeasureTheory.volume a b)
    (h_moments : ∀ (n : ℕ), ∫ t in a..b, f t * (t : ℝ) ^ n = 0) :
    ∀ x ∈ Set.Icc a b, ContinuousAt f x → f x = 0 := by
  -- First, we need to show that the integral of $f(t)g(t)$ is 0 for any continuous function $g$ on $[a, b]$.
  have h_cont : ∀ g : ℝ → ℝ, ContinuousOn g (Set.Icc a b) → ∫ t in a..b, f t * g t = 0 := by
    -- By the density of polynomials in the space of continuous functions, for any continuous function $g$ on $[a, b]$, there exists a sequence of polynomials $p_n$ such that $p_n \to g$ uniformly on $[a, b]$.
    intro g hg
    obtain ⟨p_n, hp_n⟩ : ∃ p_n : ℕ → Polynomial ℝ, (∀ n, ∀ t ∈ Set.Icc a b, abs ((p_n n).eval t - g t) < 1 / (n + 1)) := by
      have h_weierstrass : ∀ ε > 0, ∃ p : Polynomial ℝ, ∀ t ∈ Set.Icc a b, abs (p.eval t - g t) < ε := by
        apply_rules [ exists_polynomial_near_of_continuousOn ];
      exact ⟨ fun n => Classical.choose ( h_weierstrass _ <| by positivity ), fun n => Classical.choose_spec ( h_weierstrass _ <| by positivity ) ⟩;
    -- Since $p_n \to g$ uniformly on $[a, b]$, we have $\int_a^b f(t) p_n(t) \, dt \to \int_a^b f(t) g(t) \, dt$.
    have h_integral_conv : Filter.Tendsto (fun n => ∫ t in a..b, f t * (p_n n).eval t) Filter.atTop (nhds (∫ t in a..b, f t * g t)) := by
      refine' intervalIntegral.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _;
      refine' fun x => |f x| * ( |g x| + 1 );
      · simp_all +decide [ intervalIntegrable_iff ];
        exact ⟨ 0, fun n hn => MeasureTheory.AEStronglyMeasurable.mul ( hf_int.aestronglyMeasurable ) ( Continuous.aestronglyMeasurable ( Polynomial.continuous _ ) ) ⟩;
      · simp +zetaDelta at *;
        exact ⟨ 1, fun n hn => Filter.Eventually.of_forall fun x hx => mul_le_mul_of_nonneg_left ( by cases abs_cases ( Polynomial.eval x ( p_n n ) ) <;> cases abs_cases ( g x ) <;> linarith [ abs_lt.mp ( hp_n n x ( by cases Set.mem_uIoc.mp hx <;> linarith ) ( by cases Set.mem_uIoc.mp hx <;> linarith ) ), inv_le_one_of_one_le₀ ( by linarith : ( n : ℝ ) + 1 ≥ 1 ) ] ) ( abs_nonneg _ ) ⟩;
      · rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le hab.le ] at *;
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun x => |f x| * ( SupSet.sSup ( Set.image ( fun x => |g x| ) ( Set.Icc a b ) ) + 1 );
        · exact MeasureTheory.Integrable.mul_const ( hf_int.norm ) _;
        · exact MeasureTheory.AEStronglyMeasurable.mul ( hf_int.abs.aestronglyMeasurable ) ( MeasureTheory.AEStronglyMeasurable.add ( hg.norm.aestronglyMeasurable measurableSet_Icc |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self ) ( MeasureTheory.aestronglyMeasurable_const ) );
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx using by rw [ Real.norm_of_nonneg ( by positivity ) ] ; exact mul_le_mul_of_nonneg_left ( add_le_add_right ( le_csSup ( IsCompact.bddAbove ( isCompact_Icc.image_of_continuousOn ( hg.abs ) ) ) ( Set.mem_image_of_mem _ <| Set.Ioc_subset_Icc_self hx ) ) _ ) ( by positivity ) ;
      · filter_upwards [ ] with x hx using tendsto_const_nhds.mul ( tendsto_iff_norm_sub_tendsto_zero.mpr <| squeeze_zero ( fun _ => by positivity ) ( fun n => le_of_lt <| hp_n n x <| by constructor <;> cases Set.mem_uIoc.mp hx <;> linarith ) <| tendsto_one_div_add_atTop_nhds_zero_nat );
    -- Since $p_n$ is a polynomial, we can write it as a finite sum of monomials.
    have h_poly_sum : ∀ n, ∫ t in a..b, f t * (p_n n).eval t = ∑ k ∈ Finset.range ((p_n n).natDegree + 1), (p_n n).coeff k * ∫ t in a..b, f t * t ^ k := by
      intros n
      simp [Polynomial.eval_eq_sum_range];
      simp +decide only [Finset.mul_sum _ _ _];
      rw [ intervalIntegral.integral_finset_sum ];
      · simp +decide only [← intervalIntegral.integral_const_mul, mul_left_comm];
      · intro i hi;
        have := hf_int.mul_continuousOn ( Continuous.continuousOn ( show Continuous fun t : ℝ => ( p_n n |> Polynomial.coeff ) i * t ^ i by continuity ) );
        exact this;
    aesop;
  -- Now consider any $x \in [a, b]$ where $f$ is continuous.
  intro x hx hfx
  by_contra h_nonzero
  -- Since $f$ is continuous at $x$, there exists a $\delta > 0$ such that $f(t) \neq 0$ for all $t \in (x - \delta, x + \delta) \cap [a, b]$.
  obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ t ∈ Set.Icc (a : ℝ) b, abs (t - x) < δ → f t * f x > 0 := by
    have := Metric.continuousAt_iff.mp ( show ContinuousAt ( fun t => f t * f x ) x from hfx.mul continuousAt_const );
    exact Exists.elim ( this _ ( mul_self_pos.mpr h_nonzero ) ) fun δ hδ => ⟨ δ, hδ.1, fun t ht ht' => by nlinarith [ abs_lt.mp ( hδ.2 ht' ) ] ⟩;
  -- Define a continuous function $g$ that is non-zero only on the interval $(x - \delta, x + \delta) \cap [a, b]$.
  obtain ⟨g, hg_cont, hg_support⟩ : ∃ g : ℝ → ℝ, ContinuousOn g (Set.Icc a b) ∧ (∀ t ∈ Set.Icc a b, t ∈ Set.Ioo (max a (x - δ)) (min b (x + δ)) → g t > 0) ∧ (∀ t ∈ Set.Icc a b, t ∉ Set.Ioo (max a (x - δ)) (min b (x + δ)) → g t = 0) := by
    refine' ⟨ fun t => Max.max ( Min.min ( t - Max.max a ( x - δ ) ) ( Min.min b ( x + δ ) - t ) ) 0, _, _, _ ⟩ <;> norm_num;
    · fun_prop;
    · intro t ht₁ ht₂ ht₃; contrapose! ht₃; aesop;
  -- Since $f(t) * f(x) > 0$ for all $t \in (x - \delta, x + \delta) \cap [a, b]$, we have $\int_a^b f(t) * g(t) * f(x) \, dt > 0$.
  have h_integral_pos : 0 < ∫ t in Set.Ioo (max a (x - δ)) (min b (x + δ)), f t * g t * f x := by
    rw [ MeasureTheory.integral_pos_iff_support_of_nonneg_ae ];
    · refine' lt_of_lt_of_le _ ( MeasureTheory.measure_mono _ );
      rotate_left;
      exact Set.Ioo ( Max.max a ( x - δ ) ) ( Min.min b ( x + δ ) );
      · simp +zetaDelta at *;
        exact ⟨ ⟨ fun t ht => by specialize hδ t ( by cases max_cases a ( x - δ ) <;> linarith [ ht.1 ] ) ( by cases min_cases b ( x + δ ) <;> linarith [ ht.2 ] ) ( abs_lt.mpr ⟨ by cases max_cases a ( x - δ ) <;> linarith [ ht.1 ], by cases min_cases b ( x + δ ) <;> linarith [ ht.2 ] ⟩ ) ; aesop, fun t ht => by specialize hg_support ; exact ne_of_gt ( hg_support.1 t ( by cases max_cases a ( x - δ ) <;> linarith [ ht.1 ] ) ( by cases min_cases b ( x + δ ) <;> linarith [ ht.2 ] ) ( by cases max_cases a ( x - δ ) <;> linarith [ ht.1 ] ) ( by cases max_cases a ( x - δ ) <;> linarith [ ht.1 ] ) ( by cases min_cases b ( x + δ ) <;> linarith [ ht.2 ] ) ( by cases min_cases b ( x + δ ) <;> linarith [ ht.2 ] ) ) ⟩, fun t ht => by aesop ⟩;
      · simp +zetaDelta at *;
        exact ⟨ ⟨ hab, by linarith ⟩, by linarith, by linarith ⟩;
    · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioo ] with t ht;
      simp +zetaDelta at *;
      nlinarith [ hδ t ( by linarith ) ( by linarith ) ( abs_lt.mpr ⟨ by linarith, by linarith ⟩ ), hg_support.1 t ( by linarith ) ( by linarith ) ( by linarith ) ( by linarith ) ( by linarith ) ( by linarith ) ];
    · refine' MeasureTheory.Integrable.mul_const _ _;
      refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun t => |f t| * ( SupSet.sSup ( Set.image ( fun t => |g t| ) ( Set.Icc a b ) ) );
      · refine' MeasureTheory.Integrable.mul_const _ _;
        exact MeasureTheory.IntegrableOn.mono_set ( hf_int.abs.1 ) ( Set.Ioo_subset_Ioc_self.trans ( Set.Ioc_subset_Ioc ( by cases max_cases a ( x - δ ) <;> linarith [ hx.1, hx.2 ] ) ( by cases min_cases b ( x + δ ) <;> linarith [ hx.1, hx.2 ] ) ) );
      · refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
        · exact hf_int.aestronglyMeasurable.mono_set ( Set.Ioo_subset_Ioc_self.trans ( Set.Ioc_subset_Ioc ( by cases max_cases a ( x - δ ) <;> linarith [ hx.1, hx.2 ] ) ( by cases min_cases b ( x + δ ) <;> linarith [ hx.1, hx.2 ] ) ) );
        · exact hg_cont.aestronglyMeasurable ( measurableSet_Icc ) |> fun h => h.mono_set ( Set.Ioo_subset_Icc_self.trans ( Set.Icc_subset_Icc ( by cases max_cases a ( x - δ ) <;> linarith [ hx.1, hx.2 ] ) ( by cases min_cases b ( x + δ ) <;> linarith [ hx.1, hx.2 ] ) ) );
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioo ] with t ht using by rw [ norm_mul ] ; exact mul_le_mul_of_nonneg_left ( le_csSup ( IsCompact.bddAbove ( isCompact_Icc.image_of_continuousOn ( hg_cont.abs ) ) ) ( Set.mem_image_of_mem _ <| Set.Ioo_subset_Icc_self ht |> Set.mem_of_mem_of_subset <| Set.Icc_subset_Icc ( by cases max_cases a ( x - δ ) <;> linarith [ ht.1, ht.2 ] ) ( by cases min_cases b ( x + δ ) <;> linarith [ ht.1, ht.2 ] ) ) ) ( abs_nonneg _ ) ;
  -- Since $g(t) = 0$ outside $(x - \delta, x + \delta) \cap [a, b]$, we can restrict the integral to this interval.
  have h_integral_restrict : ∫ t in Set.Ioo (max a (x - δ)) (min b (x + δ)), f t * g t * f x = ∫ t in a..b, f t * g t * f x := by
    rw [ intervalIntegral.integral_of_le hab.le, MeasureTheory.integral_Ioc_eq_integral_Ioo ];
    rw [ ← MeasureTheory.integral_indicator, ← MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
    congr with t ; split_ifs <;> norm_num;
    · grind;
    · exact Or.inl <| Or.inr <| hg_support.2 t ⟨ by linarith, by linarith ⟩ <| by aesop;
  simp_all +decide [ intervalIntegral.integral_comp_mul_right ]