/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9d2eed78-7f4f-4904-881d-b641c2bc8d03
-/

/-
We have constructed a function f(x) that satisfies the conditions of Polya-Szego Problem 114.1. The function is defined piecewise based on a sequence a_n = 1/(n(log n)^2). We proved that f is positive, bounded on finite intervals, and integrable on finite intervals. We further proved that the improper integral of f converges (corresponding to Î±=1), but the improper integral of f^Î± diverges for any Î± â‰  1.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open MeasureTheory Filter Topology Set Real

/-
Define the sequence a_n and the function f(x) for the problem.
-/
noncomputable def seq_a (n : â„•) : â„ :=
  if n < 3 then 1/2 else 1 / (n * (Real.log n)^2)

noncomputable def solution_f (x : â„) : â„ :=
  let n := Nat.floor x + 1
  if x < n - (seq_a n)^2 then seq_a n else 1 / seq_a n

/-
The sequence a_n is always positive.
-/
lemma seq_a_pos (n : â„•) : 0 < seq_a n := by
  unfold seq_a;
  split_ifs <;> norm_num;
  exact mul_pos ( inv_pos.mpr ( sq_pos_of_pos ( Real.log_pos ( by norm_cast; linarith ) ) ) ) ( inv_pos.mpr ( by norm_cast; linarith ) )

/-
The sequence a_n is bounded by 1.
-/
lemma seq_a_le_one (n : â„•) : seq_a n â‰¤ 1 := by
  unfold seq_a;
  split_ifs <;> norm_num;
  exact mul_le_oneâ‚€ ( inv_le_one_of_one_leâ‚€ <| one_le_powâ‚€ <| Real.le_log_iff_exp_le ( by norm_cast; linarith ) |>.2 <| by exact Real.exp_one_lt_d9.le.trans <| by norm_num; linarith [ show ( n : â„ ) â‰¥ 3 by norm_cast; linarith ] ) ( by positivity ) ( inv_le_one_of_one_leâ‚€ <| by norm_cast; linarith )

/-
The sequence a_n tends to 0 as n goes to infinity.
-/
lemma seq_a_tendsto_zero : Tendsto seq_a atTop (ğ“ 0) := by
  have h_lim_inf : Filter.Tendsto (fun n => 1 / (n * (Real.log n)^2 : â„)) Filter.atTop (ğ“ 0) := by
    norm_num +zetaDelta at *;
    exact le_trans ( Filter.Tendsto.mul ( Filter.Tendsto.inv_tendsto_atTop <| Filter.Tendsto.comp ( Filter.tendsto_pow_atTop ( by norm_num ) ) <| Real.tendsto_log_atTop ) <| tendsto_inv_atTop_zero ) <| by norm_num;
  have h_lim_inf : Filter.Tendsto (fun n => if n < 3 then 1/2 else 1 / (n * (Real.log n)^2 : â„)) Filter.atTop (ğ“ 0) := by
    exact Filter.Tendsto.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 3 ] with n hn; rw [ if_neg hn.not_lt ] ) h_lim_inf;
  convert h_lim_inf.comp tendsto_natCast_atTop_atTop using 1;
  ext; unfold seq_a; aesop;

/-
The function solution_f is positive for non-negative x.
-/
lemma solution_f_pos (x : â„) (hx : 0 â‰¤ x) : 0 < solution_f x := by
  -- By definition of `solution_f`, we know that it is either `seq_a n` or `1/seq_a n`, both of which are positive for `n â‰¥ 3`.
  simp [solution_f];
  split_ifs <;> [ exact seq_a_pos _; exact inv_pos.mpr ( seq_a_pos _ ) ]

/-
The function solution_f is bounded on any finite interval [a, b].
-/
lemma solution_f_bounded_on_Icc (a b : â„) (ha : 0 â‰¤ a) (hab : a â‰¤ b) :
  âˆƒ M : â„, âˆ€ x âˆˆ Set.Icc a b, |solution_f x| â‰¤ M := by
  -- Let $N$ be the maximum of $\lfloor b \rfloor$ and $3$.
  obtain âŸ¨N, hNâŸ© : âˆƒ N : â„•, âˆ€ x âˆˆ Set.Icc a b, Nat.floor x + 1 â‰¤ N := by
    exact âŸ¨ âŒŠbâŒ‹â‚Š + 1, fun x hx => Nat.succ_le_succ <| Nat.floor_mono hx.2 âŸ©;
  -- Let $M$ be the maximum of $a_n$ and $1/a_n$ for $n \leq N$.
  obtain âŸ¨M, hMâŸ© : âˆƒ M : â„, âˆ€ n â‰¤ N, (seq_a n â‰¤ M âˆ§ 1 / seq_a n â‰¤ M) := by
    use Max.max ( âˆ‘ n âˆˆ Finset.range ( N + 1 ), seq_a n ) ( âˆ‘ n âˆˆ Finset.range ( N + 1 ), 1 / seq_a n );
    exact fun n hn => âŸ¨ le_max_of_le_left <| Finset.single_le_sum ( fun n _ => le_of_lt <| seq_a_pos n ) <| Finset.mem_range.mpr <| by linarith, le_max_of_le_right <| Finset.single_le_sum ( fun n _ => le_of_lt <| one_div_pos.mpr <| seq_a_pos n ) <| Finset.mem_range.mpr <| by linarith âŸ©;
  use M;
  intro x hx;
  rw [ abs_of_nonneg ( solution_f_pos x ( by linarith [ hx.1 ] ) |> le_of_lt ) ];
  unfold solution_f; aesop

/-
The function solution_f is integrable on any finite interval [a, b].
-/
lemma solution_f_intervalIntegrable (a b : â„) (ha : 0 â‰¤ a) (hab : a â‰¤ b) :
  IntervalIntegrable solution_f volume a b := by
  apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ];
  -- The function $solution\_f$ is integrable on any finite interval because it is bounded and continuous.
  have h_integrable : MeasureTheory.IntegrableOn solution_f (Set.Icc a b) := by
    have h_bounded : âˆƒ M : â„, âˆ€ x âˆˆ Set.Icc a b, |solution_f x| â‰¤ M := by
      exact?
    norm_num +zetaDelta at *;
    refine' MeasureTheory.Integrable.mono' _ _ _;
    refine' fun x => h_bounded.choose;
    Â· norm_num;
    Â· refine' Measurable.aestronglyMeasurable _;
      refine' Measurable.ite _ _ _;
      Â· refine' measurableSet_lt _ _;
        Â· exact measurable_id;
        Â· fun_prop;
      Â· -- The function seq_a is measurable because it is a composition of measurable functions.
        have h_seq_a_measurable : Measurable seq_a := by
          exact?;
        exact h_seq_a_measurable.comp ( Measurable.add ( measurable_id'.nat_floor ) measurable_const );
      Â· fun_prop (disch := norm_num);
    Â· filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using h_bounded.choose_spec x hx.1 hx.2;
  rwa [ Set.uIcc_of_le hab ]

/-
The integral of (f(x))^Î± over [n-1, n] is given by the formula involving a_n.
-/
lemma integral_solution_f_pow_on_interval (n : â„•) (hn : n â‰¥ 1) (Î± : â„) :
  âˆ« x in (n - 1 : â„)..n, (solution_f x) ^ Î± = (seq_a n) ^ Î± * (1 - (seq_a n) ^ 2) + (seq_a n) ^ (2 - Î±) := by
  unfold solution_f;
  -- We can split the integral into two parts: one over the interval where $f(x) = a_n$ and one over the interval where $f(x) = 1/a_n$.
  have h_integral_split : âˆ« x in (n - 1 : â„)..n, (if x < n - (seq_a n)^2 then seq_a n else 1 / seq_a n) ^ Î± = (âˆ« x in (n - 1 : â„)..(n - (seq_a n)^2), seq_a n ^ Î±) + (âˆ« x in (n - (seq_a n)^2)..n, (1 / seq_a n) ^ Î±) := by
    have h_integral_split : âˆ« x in (n - 1 : â„)..n, (if x < n - (seq_a n)^2 then seq_a n else 1 / seq_a n) ^ Î± = (âˆ« x in (n - 1 : â„)..(n - (seq_a n)^2), (if x < n - (seq_a n)^2 then seq_a n else 1 / seq_a n) ^ Î±) + (âˆ« x in (n - (seq_a n)^2)..n, (if x < n - (seq_a n)^2 then seq_a n else 1 / seq_a n) ^ Î±) := by
      rw [ intervalIntegral.integral_add_adjacent_intervals ];
      Â· apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ];
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun x => ( seq_a n ) ^ Î± + ( 1 / seq_a n ) ^ Î±;
        Â· exact Continuous.integrableOn_Icc ( by continuity );
        Â· exact Measurable.aestronglyMeasurable ( by exact Measurable.pow_const ( by exact Measurable.ite ( measurableSet_Iio ) measurable_const measurable_const ) _ );
        Â· filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx;
          split_ifs <;> norm_num;
          Â· rw [ abs_of_nonneg ( Real.rpow_nonneg ( le_of_lt ( seq_a_pos n ) ) _ ) ] ; exact le_add_of_nonneg_right ( Real.rpow_nonneg ( inv_nonneg.mpr ( le_of_lt ( seq_a_pos n ) ) ) _ );
          Â· rw [ abs_of_nonneg ( Real.rpow_nonneg ( inv_nonneg.mpr ( le_of_lt ( seq_a_pos n ) ) ) _ ) ] ; exact le_add_of_nonneg_left ( Real.rpow_nonneg ( le_of_lt ( seq_a_pos n ) ) _ );
      Â· rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le ];
        Â· rw [ MeasureTheory.integrableOn_congr_fun ( fun x hx => by rw [ if_neg hx.1.not_lt ] ) measurableSet_Ioc ] ; norm_num;
        Â· exact sub_le_self _ ( sq_nonneg _ );
    convert h_integral_split using 2;
    Â· rw [ intervalIntegral.integral_of_le, intervalIntegral.integral_of_le ];
      Â· rw [ MeasureTheory.integral_Ioc_eq_integral_Ioo, MeasureTheory.integral_Ioc_eq_integral_Ioo ];
        exact MeasureTheory.setIntegral_congr_fun measurableSet_Ioo fun x hx => by rw [ if_pos hx.2 ] ;
      Â· gcongr;
        exact pow_le_oneâ‚€ ( by exact le_of_lt ( seq_a_pos n ) ) ( seq_a_le_one n );
      Â· gcongr;
        exact pow_le_oneâ‚€ ( by exact le_of_lt ( seq_a_pos n ) ) ( seq_a_le_one n );
    Â· rw [ intervalIntegral.integral_of_le, intervalIntegral.integral_of_le ] <;> norm_num;
      Â· rw [ MeasureTheory.setIntegral_congr_fun measurableSet_Ioc fun x hx => if_neg hx.1.not_lt ] ; norm_num;
      Â· positivity;
      Â· positivity;
  convert h_integral_split using 1;
  Â· rw [ intervalIntegral.integral_of_le, intervalIntegral.integral_of_le ] <;> norm_num;
    rw [ MeasureTheory.integral_Ioc_eq_integral_Ioo, MeasureTheory.integral_Ioc_eq_integral_Ioo ];
    refine' MeasureTheory.setIntegral_congr_fun measurableSet_Ioo fun x hx => _;
    norm_num [ show âŒŠxâŒ‹â‚Š = n - 1 from Nat.floor_eq_iff ( by linarith [ hx.1, show ( n : â„ ) â‰¥ 1 by norm_cast ] ) |>.2 âŸ¨ by cases n <;> norm_num at * ; linarith, by cases n <;> norm_num at * ; linarith âŸ© ];
    rw [ Nat.sub_add_cancel hn ];
    rw [ Nat.cast_pred hn ] ; ring;
  Â· norm_num [ Real.rpow_sub ( seq_a_pos n ) ] ; ring;
    rw [ Real.inv_rpow ( le_of_lt ( seq_a_pos n ) ) ]

/-
The series sum(a_n) converges.
-/
lemma summable_seq_a : Summable seq_a := by
  unfold seq_a;
  rw [ â† summable_nat_add_iff 3 ];
  -- We will show that the integral of $\int_{3}^{\infty} \frac{1}{x (\log x)^2} dx$ converges.
  have h_integral_converges : Summable (fun n : â„• => âˆ« x in (n + 3 : â„)..((n + 4) : â„), (1 / (x * (Real.log x)^2))) := by
    -- We'll use the fact that the integral of $\frac{1}{x (\log x)^2}$ is $-\frac{1}{\log x}$.
    have h_integral_eval : âˆ€ a b : â„, 3 â‰¤ a â†’ a < b â†’ âˆ« x in a..b, (1 / (x * (Real.log x) ^ 2)) = -1 / Real.log b + 1 / Real.log a := by
      intros; rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
      rotate_right;
      use fun x => -1 / Real.log x;
      Â· ring;
      Â· intro x hx; convert HasDerivAt.div ( hasDerivAt_const _ _ ) ( Real.hasDerivAt_log ( show x â‰  0 by cases Set.mem_uIcc.mp hx <;> linarith ) ) ( ne_of_gt <| Real.log_pos <| show x > 1 by cases Set.mem_uIcc.mp hx <;> linarith ) using 1 ; ring;
      Â· apply_rules [ ContinuousOn.intervalIntegrable ];
        exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.div continuousAt_const ( ContinuousAt.mul continuousAt_id <| ContinuousAt.pow ( Real.continuousAt_log <| by cases Set.mem_uIcc.mp hx <;> linarith ) _ ) <| ne_of_gt <| mul_pos ( by cases Set.mem_uIcc.mp hx <;> linarith ) <| sq_pos_of_pos <| Real.log_pos <| by cases Set.mem_uIcc.mp hx <;> linarith;
    -- We can use the fact that the series $\sum_{n=3}^{\infty} \left( \frac{1}{\log n} - \frac{1}{\log (n+1)} \right)$ is a telescoping series.
    have h_telescoping : âˆ€ N : â„•, âˆ‘ n âˆˆ Finset.range N, (âˆ« x in (n + 3 : â„)..((n + 4) : â„), 1 / (x * (Real.log x) ^ 2)) = 1 / Real.log 3 - 1 / Real.log (N + 3) := by
      intro N; induction N <;> simp_all +decide [ Finset.sum_range_succ ] ; ring;
      have := h_integral_eval ( 3 + ( â†‘â€¹â„•â€º : â„ ) ) ( 4 + ( â†‘â€¹â„•â€º : â„ ) ) ( by linarith ) ( by linarith ) ; norm_num at * ; ring_nf at * ; linarith;
    rw [ summable_iff_not_tendsto_nat_atTop_of_nonneg ];
    Â· exact fun h => absurd ( h.congr h_telescoping ) ( by exact not_tendsto_atTop_of_tendsto_nhds <| by simpa using tendsto_const_nhds.sub <| tendsto_inv_atTop_zero.comp <| Real.tendsto_log_atTop.comp <| Filter.tendsto_atTop_add_const_right _ _ tendsto_natCast_atTop_atTop );
    Â· exact fun n => intervalIntegral.integral_nonneg ( by linarith ) fun x hx => one_div_nonneg.2 ( mul_nonneg ( by linarith [ hx.1 ] ) ( sq_nonneg _ ) );
  -- By comparison, it suffices to show that the integral of $\frac{1}{x (\log x)^2}$ over $[n+3, n+4]$ is bounded above by $\frac{1}{(n+3) (\log (n+3))^2}$.
  have h_integral_bound : âˆ€ n : â„•, âˆ« x in (n + 3 : â„)..((n + 4) : â„), (1 / (x * (Real.log x)^2)) â‰¥ (1 / ((n + 4 : â„) * (Real.log (n + 4))^2)) := by
    intros n
    have h_integral_bound : âˆ« x in (n + 3 : â„)..((n + 4) : â„), (1 / (x * (Real.log x)^2)) â‰¥ âˆ« x in (n + 3 : â„)..((n + 4) : â„), (1 / ((n + 4 : â„) * (Real.log (n + 4))^2)) := by
      refine' intervalIntegral.integral_mono_on _ _ _ _ <;> norm_num;
      Â· apply_rules [ ContinuousOn.intervalIntegrable ];
        exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.mul ( ContinuousAt.invâ‚€ ( ContinuousAt.pow ( Real.continuousAt_log ( by cases Set.mem_uIcc.mp hx <;> linarith ) ) _ ) ( ne_of_gt ( sq_pos_of_pos ( Real.log_pos ( by cases Set.mem_uIcc.mp hx <;> linarith ) ) ) ) ) ( ContinuousAt.invâ‚€ ( continuousAt_id ) ( ne_of_gt ( by cases Set.mem_uIcc.mp hx <;> linarith ) ) );
      Â· bound;
    norm_num at * ; linarith;
  exact summable_nat_add_iff 1 |>.1 <| h_integral_converges.of_nonneg_of_le ( fun n => by positivity ) ( fun n => by exact_mod_cast h_integral_bound n )

/-
The integral of solution_f from 0 to infinity converges. This corresponds to the case Î± = 1.
-/
lemma integral_solution_f_converges : âˆƒ L, Tendsto (Î» b â†¦ âˆ« x in 0..b, solution_f x) atTop (ğ“ L) := by
  -- We'll use the fact that if the integral of $f$ over $[0, b]$ is bounded and converges as $b$ approaches infinity, then the limit of the integral over $[0, b]$ as $b$ approaches infinity is the integral over $[0, \infty)$.
  have h_bounded : âˆ€ b : â„, 0 â‰¤ b â†’ âˆ« x in (0 : â„)..b, solution_f x â‰¤ âˆ‘' n : â„•, (seq_a (n + 1)) + âˆ‘' n : â„•, (seq_a (n + 1)) ^ (2 - 1) := by
    intros b hb
    have h_integral_bound : âˆ« x in (0 : â„)..b, solution_f x â‰¤ âˆ‘ n âˆˆ Finset.range (Nat.floor b + 1), (âˆ« x in (n : â„)..(n + 1), solution_f x) := by
      -- The integral over $[0, b]$ can be split into the sum of integrals over $[n, n+1]$ for $n = 0, 1, \ldots, \lfloor b \rfloor$.
      have h_split : âˆ« x in (0 : â„)..b, solution_f x â‰¤ âˆ« x in (0 : â„)..(Nat.floor b + 1), solution_f x := by
        apply_rules [ intervalIntegral.integral_mono_interval ];
        Â· norm_num;
        Â· linarith [ Nat.lt_floor_add_one b ];
        Â· filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx using le_of_lt ( solution_f_pos x hx.1.le );
        Â· apply_rules [ solution_f_intervalIntegrable ] ; linarith [ Nat.lt_floor_add_one b ] ;
          positivity;
      convert h_split using 1;
      convert intervalIntegral.sum_integral_adjacent_intervals _ <;> norm_num;
      exact fun k hk => solution_f_intervalIntegrable _ _ ( by positivity ) ( by linarith );
    -- By definition of $solution_f$, we know that $\int_{n}^{n+1} solution_f(x) \, dx = a_{n+1} (1 - a_{n+1}^2) + a_{n+1}^{2 - 1}$.
    have h_integral_def : âˆ€ n : â„•, âˆ« x in (n : â„)..(n + 1), solution_f x = (seq_a (n + 1)) * (1 - (seq_a (n + 1))^2) + (seq_a (n + 1)) ^ (2 - 1) := by
      intro n; convert integral_solution_f_pow_on_interval ( n + 1 ) ( by linarith ) 1 using 1 <;> norm_num;
    have h_sum_bound : âˆ‘ n âˆˆ Finset.range (Nat.floor b + 1), (seq_a (n + 1)) * (1 - (seq_a (n + 1))^2) â‰¤ âˆ‘' n : â„•, (seq_a (n + 1)) := by
      have h_sum_bound : âˆ€ n : â„•, (seq_a (n + 1)) * (1 - (seq_a (n + 1))^2) â‰¤ (seq_a (n + 1)) := by
        exact fun n => mul_le_of_le_one_right ( le_of_lt ( seq_a_pos _ ) ) ( sub_le_self _ ( sq_nonneg _ ) );
      exact le_trans ( Finset.sum_le_sum fun _ _ => h_sum_bound _ ) ( Summable.sum_le_tsum ( Finset.range ( âŒŠbâŒ‹â‚Š + 1 ) ) ( fun _ _ => seq_a_pos _ |> le_of_lt ) ( by simpa using summable_nat_add_iff 1 |>.2 <| summable_seq_a ) );
    have h_sum_bound : âˆ‘ n âˆˆ Finset.range (Nat.floor b + 1), (seq_a (n + 1)) ^ (2 - 1) â‰¤ âˆ‘' n : â„•, (seq_a (n + 1)) ^ (2 - 1) := by
      norm_num;
      exact Summable.sum_le_tsum ( Finset.range ( âŒŠbâŒ‹â‚Š + 1 ) ) ( fun _ _ => le_of_lt ( seq_a_pos _ ) ) ( by simpa using summable_nat_add_iff 1 |>.2 <| summable_seq_a );
    simp_all +decide [ Finset.sum_add_distrib ];
    linarith;
  have h_monotone : MonotoneOn (fun b => âˆ« x in (0 : â„)..b, solution_f x) (Set.Ici 0) := by
    intro a ha b hb hab; apply_rules [ intervalIntegral.integral_mono_interval, zero_le_one ] ; aesop;
    Â· filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx using le_of_lt ( solution_f_pos x hx.1.le );
    Â· apply_rules [ solution_f_intervalIntegrable ] ; aesop;
  have h_converge : Filter.Tendsto (fun b : â„ => âˆ« x in (0 : â„)..b, solution_f x) Filter.atTop (nhds (sSup (Set.image (fun b => âˆ« x in (0 : â„)..b, solution_f x) (Set.Ici 0)))) := by
    apply_rules [ tendsto_order.2 âŸ¨ _, _ âŸ© ];
    Â· intro a ha;
      contrapose! ha;
      exact csSup_le ( Set.Nonempty.image _ <| Set.nonempty_Ici ) <| Set.forall_mem_image.2 fun x hx => le_of_not_gt fun hx' => ha <| Filter.eventually_atTop.2 âŸ¨ x, fun y hy => hx'.trans_le <| h_monotone hx ( show 0 â‰¤ y by linarith [ Set.mem_Ici.1 hx ] ) hy âŸ©;
    Â· exact fun x hx => Filter.eventually_atTop.mpr âŸ¨ 0, fun y hy => lt_of_le_of_lt ( le_csSup ( show BddAbove ( ( fun b => âˆ« x in ( 0 : â„ )..b, solution_f x ) '' Set.Ici 0 ) from âŸ¨ _, Set.forall_mem_image.mpr fun b hb => h_bounded b hb âŸ© ) <| Set.mem_image_of_mem _ hy ) hx âŸ©;
  exact âŸ¨ _, h_converge âŸ©

/-
The series sum((a_n)^Î²) diverges if Î² < 1.
-/
lemma not_summable_seq_a_pow_of_lt_one (Î² : â„) (hÎ² : Î² < 1) : Â¬ Summable (fun n => (seq_a n) ^ Î²) := by
  -- By comparison, it suffices to show that $\sum_{n=3}^{\infty} \frac{1}{n^{\beta} (\log n)^{2\beta}}$ diverges.
  suffices h_comp : Â¬ Summable (fun n : â„• => 1 / (n : â„) ^ Î² * (1 / (Real.log n) ^ (2 * Î²))) by
    -- Since $seq_a n = \frac{1}{n (\log n)^2}$ for $n \geq 3$, we have $(seq_a n)^\beta = \frac{1}{n^\beta (\log n)^{2\beta}}$ for $n \geq 3$.
    have h_eq : âˆ€ n â‰¥ 3, (seq_a n) ^ Î² = 1 / (n : â„) ^ Î² * (1 / (Real.log n) ^ (2 * Î²)) := by
      intros n hn
      have h_eq : seq_a n = 1 / (n * (Real.log n)^2) := by
        exact if_neg ( by linarith );
      rw [ h_eq, Real.div_rpow ] <;> norm_num;
      Â· rw [ Real.mul_rpow ( by positivity ) ( by positivity ), â† Real.rpow_natCast, â† Real.rpow_mul ( by positivity ) ] ; ring;
      Â· positivity;
    rw [ â† summable_nat_add_iff 3 ] at * ; aesop;
  -- Since $\beta < 1$, we have $(Real.log n)^{2\beta} \leq n^{1-\beta}$ for sufficiently large $n$.
  have h_log_bound : âˆƒ N : â„•, âˆ€ n â‰¥ N, (Real.log n) ^ (2 * Î²) â‰¤ n ^ (1 - Î²) := by
    -- Taking the logarithm of both sides, we need to show that $2\beta \log(\log n) \leq (1 - \beta) \log n$ for sufficiently large $n$.
    suffices h_log_bound : âˆƒ N : â„•, âˆ€ n â‰¥ N, 2 * Î² * Real.log (Real.log n) â‰¤ (1 - Î²) * Real.log n by
      obtain âŸ¨ N, hN âŸ© := h_log_bound;
      use N + 3; intro n hn; rw [ Real.rpow_def_of_pos ( Real.log_pos <| by norm_cast; linarith ), Real.rpow_def_of_pos ( by norm_cast; linarith ) ] ; norm_num ; linarith [ hN n <| by linarith ] ;
    -- We can divide both sides by $\log n$ (which is positive for $n \geq 3$) to get $2\beta \frac{\log(\log n)}{\log n} \leq 1 - \beta$.
    suffices h_div_bound : âˆƒ N : â„•, âˆ€ n â‰¥ N, 2 * Î² * (Real.log (Real.log n) / Real.log n) â‰¤ 1 - Î² by
      obtain âŸ¨ N, hN âŸ© := h_div_bound; use N + 3; intro n hn; have := hN n ( by linarith ) ; rw [ mul_div, div_le_iffâ‚€ ] at this <;> nlinarith [ Real.log_pos <| show ( n :â„ ) > 1 by norm_cast; linarith ] ;
    -- We know that $\frac{\log(\log n)}{\log n}$ tends to $0$ as $n$ tends to infinity.
    have h_log_log_div_log_zero : Filter.Tendsto (fun n : â„• => Real.log (Real.log n) / Real.log n) Filter.atTop (nhds 0) := by
      -- Let $y = \log n$, therefore the limit becomes $\lim_{y \to \infty} \frac{\log y}{y}$.
      suffices h_log_y : Filter.Tendsto (fun y : â„ => Real.log y / y) Filter.atTop (nhds 0) by
        exact h_log_y.comp ( Real.tendsto_log_atTop.comp tendsto_natCast_atTop_atTop );
      -- Let $z = \frac{1}{y}$, therefore the limit becomes $\lim_{z \to 0^+} z \log \left(\frac{1}{z}\right)$.
      suffices h_log_recip : Filter.Tendsto (fun z : â„ => z * Real.log (1 / z)) (Filter.map (fun y => 1 / y) Filter.atTop) (nhds 0) by
        exact h_log_recip.congr ( by simp +contextual [ div_eq_inv_mul ] );
      norm_num;
      exact tendsto_nhdsWithin_of_tendsto_nhds ( by simpa using Real.continuous_mul_log.neg.tendsto 0 );
    simpa using h_log_log_div_log_zero.const_mul ( 2 * Î² ) |> fun h => h.eventually ( ge_mem_nhds <| by linarith );
  -- Using the bound, we can show that $\frac{1}{n^{\beta} (\log n)^{2\beta}} \geq \frac{1}{n}$ for sufficiently large $n$.
  obtain âŸ¨N, hNâŸ© : âˆƒ N : â„•, âˆ€ n â‰¥ N, (1 / (n : â„) ^ Î² * (1 / (Real.log n) ^ (2 * Î²))) â‰¥ (1 / (n : â„)) := by
    field_simp;
    obtain âŸ¨ N, hN âŸ© := h_log_bound; use N + 2; intro n hn; rw [ div_le_div_iffâ‚€ ] <;> norm_num;
    Â· exact le_trans ( mul_le_mul_of_nonneg_left ( hN n ( by linarith ) ) ( by positivity ) ) ( by rw [ â† Real.rpow_add ( by norm_cast; linarith ) ] ; norm_num [ show Î² + ( 1 - Î² ) = 1 by ring ] );
    Â· linarith;
    Â· exact mul_pos ( Real.rpow_pos_of_pos ( by norm_cast; linarith ) _ ) ( Real.rpow_pos_of_pos ( Real.log_pos ( by norm_cast; linarith ) ) _ );
  -- Since $\sum_{n=N}^{\infty} \frac{1}{n}$ diverges, it follows that $\sum_{n=N}^{\infty} \frac{1}{n^{\beta} (\log n)^{2\beta}}$ also diverges.
  have h_div : Â¬ Summable (fun n : â„• => (1 / (n : â„))) := by
    simpa using Real.not_summable_natCast_inv;
  rw [ â† summable_nat_add_iff N ] at *;
  exact fun h => h_div <| h.of_nonneg_of_le ( fun n => by positivity ) fun n => hN _ <| by linarith;

/-
If Î± > 1, the integral of (f(x))^Î± diverges.
-/
lemma integral_diverges_of_alpha_gt_one (Î± : â„) (hÎ± : 1 < Î±) :
  Â¬âˆƒ (L : â„), Tendsto (Î» b â†¦ âˆ« x in 0..b, (solution_f x) ^ Î±) atTop (ğ“ L) := by
  -- By the lemma, $\int_0^\infty (f(x))^\alpha \, dx$ diverges if $\alpha \geq 1$.
  intro h_contra
  obtain âŸ¨L, hLâŸ© := h_contra
  have h_diverge : Filter.Tendsto (fun b => âˆ« x in (0 : â„)..b, (solution_f x) ^ Î±) Filter.atTop Filter.atTop := by
    -- By the properties of the integral, we can break the integral up into a sum of integrals over each interval $[n-1, n]$.
    have h_integral_split : âˆ€ N : â„•, N â‰¥ 3 â†’ âˆ« x in (0 : â„)..N, (solution_f x) ^ Î± â‰¥ âˆ‘ n âˆˆ Finset.Icc 3 N, (seq_a n) ^ Î± * (1 - (seq_a n) ^ 2) + âˆ‘ n âˆˆ Finset.Icc 3 N, (seq_a n) ^ (2 - Î±) := by
      -- By the properties of the integral, we can break the integral up into a sum of integrals over each interval $[n-1, n]$ and apply the result from `integral_solution_f_pow_on_interval`.
      intros N hN
      have h_integral_split : âˆ« x in (0 : â„)..N, (solution_f x) ^ Î± = âˆ‘ n âˆˆ Finset.Icc 1 N, âˆ« x in (n - 1 : â„)..n, (solution_f x) ^ Î± := by
        erw [ Finset.sum_Ico_eq_sum_range ];
        symm;
        convert intervalIntegral.sum_integral_adjacent_intervals _ <;> norm_num;
        Â· ring;
        Â· intro k hk; apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ];
          have h_integrable : MeasureTheory.IntegrableOn (fun x => solution_f x ^ Î±) (Set.Icc (k : â„) (k + 1)) := by
            have h_bounded : âˆƒ M : â„, âˆ€ x âˆˆ Set.Icc (k : â„) (k + 1), |solution_f x ^ Î±| â‰¤ M := by
              have := solution_f_bounded_on_Icc ( k : â„ ) ( k + 1 ) ( by positivity ) ( by linarith );
              obtain âŸ¨ M, hM âŸ© := this;
              use M ^ Î±;
              exact fun x hx => by simpa only [ abs_of_nonneg ( Real.rpow_nonneg ( abs_nonneg _ ) _ ) ] using Real.abs_rpow_le_abs_rpow _ _ |> le_trans <| Real.rpow_le_rpow ( abs_nonneg _ ) ( hM x hx ) <| by positivity;
            refine' MeasureTheory.Integrable.mono' _ _ _;
            refine' fun x => h_bounded.choose;
            Â· norm_num;
            Â· refine' Measurable.aestronglyMeasurable _;
              refine' Measurable.pow_const _ _;
              refine' Measurable.ite _ _ _;
              Â· refine' measurableSet_lt _ _;
                Â· exact measurable_id;
                Â· fun_prop (disch := norm_num);
              Â· exact Measurable.comp ( show Measurable fun n : â„• => seq_a n from by exact Measurable.of_discrete ) ( show Measurable fun x : â„ => âŒŠxâŒ‹â‚Š + 1 from by exact Measurable.add ( measurable_id'.nat_floor ) measurable_const );
              Â· refine' Measurable.div _ _ <;> norm_num;
                exact Measurable.comp ( show Measurable fun n : â„• => seq_a n from by exact Measurable.ite ( by measurability ) ( by measurability ) ( by measurability ) ) ( Nat.measurable_floor.comp measurable_id' |> Measurable.add <| measurable_const );
            Â· filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using h_bounded.choose_spec x hx;
          rwa [ Set.uIcc_of_le ( by norm_num ) ];
      rw [ h_integral_split, â† Finset.sum_add_distrib, Finset.sum_congr rfl fun n hn => integral_solution_f_pow_on_interval n ( by linarith [ Finset.mem_Icc.mp hn ] ) Î± ];
      exact Finset.sum_le_sum_of_subset_of_nonneg ( Finset.Icc_subset_Icc ( by norm_num ) le_rfl ) fun _ _ _ => add_nonneg ( mul_nonneg ( Real.rpow_nonneg ( le_of_lt ( seq_a_pos _ ) ) _ ) ( sub_nonneg.2 ( pow_le_oneâ‚€ ( le_of_lt ( seq_a_pos _ ) ) ( seq_a_le_one _ ) ) ) ) ( Real.rpow_nonneg ( le_of_lt ( seq_a_pos _ ) ) _ );
    -- Since $\sum_{n=3}^\infty (a_n)^{2-\alpha}$ diverges, the integral $\int_0^\infty (f(x))^\alpha \, dx$ also diverges.
    have h_sum_diverge : Filter.Tendsto (fun N : â„• => âˆ‘ n âˆˆ Finset.Icc 3 N, (seq_a n) ^ (2 - Î±)) Filter.atTop Filter.atTop := by
      have h_sum_diverge : Â¬ Summable (fun n : â„• => (seq_a n) ^ (2 - Î±)) := by
        have := not_summable_seq_a_pow_of_lt_one ( 2 - Î± ) ( by linarith ) ; aesop;
      have h_sum_diverge : Filter.Tendsto (fun N : â„• => âˆ‘ n âˆˆ Finset.range (N - 2), (seq_a (n + 3)) ^ (2 - Î±)) Filter.atTop Filter.atTop := by
        exact not_summable_iff_tendsto_nat_atTop_of_nonneg ( fun _ => Real.rpow_nonneg ( le_of_lt ( seq_a_pos _ ) ) _ ) |>.1 ( by exact_mod_cast mt ( summable_nat_add_iff 3 |>.1 ) h_sum_diverge ) |> Filter.Tendsto.comp <| Filter.tendsto_sub_atTop_nat 2;
      exact h_sum_diverge.congr' ( by filter_upwards [ Filter.eventually_ge_atTop 3 ] with N hN using by erw [ Finset.sum_Ico_eq_sum_range ] ; ac_rfl );
    have h_integral_diverge : Filter.Tendsto (fun N : â„• => âˆ« x in (0 : â„)..N, (solution_f x) ^ Î±) Filter.atTop Filter.atTop := by
      refine' Filter.tendsto_atTop_mono' _ _ h_sum_diverge;
      filter_upwards [ Filter.eventually_ge_atTop 3 ] with N hN using le_trans ( le_add_of_nonneg_left <| Finset.sum_nonneg fun _ _ => mul_nonneg ( Real.rpow_nonneg ( le_of_lt <| seq_a_pos _ ) _ ) <| sub_nonneg.2 <| pow_le_oneâ‚€ ( le_of_lt <| seq_a_pos _ ) <| seq_a_le_one _ ) ( h_integral_split N hN );
    exact False.elim <| not_tendsto_atTop_of_tendsto_nhds ( hL.comp <| tendsto_natCast_atTop_atTop ) h_integral_diverge;
  exact not_tendsto_atTop_of_tendsto_nhds hL h_diverge

/-
The series sum((a_n)^p) converges for p >= 1.
-/
lemma summable_seq_a_pow {p : â„} (hp : 1 â‰¤ p) : Summable (fun n => (seq_a n) ^ p) := by
  -- Since $p \geq 1$, we can use the fact that $(a_n)^p \leq a_n$ for all $n \geq 3$.
  have h_bound : âˆ€ n â‰¥ 3, (seq_a n) ^ p â‰¤ seq_a n := by
    intro n hn;
    exact le_trans ( Real.rpow_le_rpow_of_exponent_ge ( seq_a_pos n ) ( seq_a_le_one n ) hp ) ( by norm_num );
  rw [ â† summable_nat_add_iff 3 ];
  exact Summable.of_nonneg_of_le ( fun n => Real.rpow_nonneg ( le_of_lt ( seq_a_pos _ ) ) _ ) ( fun n => h_bound _ ( by linarith ) ) ( summable_nat_add_iff 3 |>.2 <| by exact? )

/-
If Î± < 1, the integral of (f(x))^Î± diverges.
-/
lemma integral_diverges_of_alpha_lt_one (Î± : â„) (hÎ± : Î± < 1) :
  Â¬âˆƒ (L : â„), Tendsto (Î» b â†¦ âˆ« x in 0..b, (solution_f x) ^ Î±) atTop (ğ“ L) := by
  -- Assume by contradiction that the integral converges.
  by_contra h_contra
  obtain âŸ¨L, hLâŸ© := h_contra

  -- Since Î± < 1, the series sum((a_n)^Î±) diverges.
  have h_sum_diverges : Â¬ Summable (fun n => (seq_a n) ^ Î±) := by
    exact?;
  -- Using the integral_split lemma, we can express the integral from 0 to N as a sum of integrals over each interval [n-1, n].
  have h_integral_sum : âˆ€ N : â„•, N â‰¥ 1 â†’ âˆ« x in (0 : â„)..N, (solution_f x) ^ Î± = âˆ‘ n âˆˆ Finset.range N, ((seq_a (n + 1)) ^ Î± * (1 - (seq_a (n + 1)) ^ 2) + (seq_a (n + 1)) ^ (2 - Î±)) := by
    intro N hN;
    have h_integral_split : âˆ€ n : â„•, n â‰¥ 1 â†’ âˆ« x in (n - 1 : â„)..n, (solution_f x) ^ Î± = (seq_a n) ^ Î± * (1 - (seq_a n) ^ 2) + (seq_a n) ^ (2 - Î±) := by
      exact?;
    rw [ â† Finset.sum_congr rfl fun n hn => h_integral_split ( n + 1 ) ( by linarith [ Finset.mem_range.mp hn ] ) ];
    symm;
    convert intervalIntegral.sum_integral_adjacent_intervals _ <;> norm_num;
    intro k hk;
    have := h_integral_split ( k + 1 ) ( by linarith );
    contrapose! this;
    rw [ intervalIntegral.integral_undef ] <;> norm_num [ this ];
    refine' ne_of_lt ( add_pos_of_nonneg_of_pos ( mul_nonneg ( Real.rpow_nonneg ( le_of_lt ( seq_a_pos _ ) ) _ ) ( sub_nonneg.mpr _ ) ) ( Real.rpow_pos_of_pos ( seq_a_pos _ ) _ ) );
    exact pow_le_oneâ‚€ ( le_of_lt ( seq_a_pos _ ) ) ( seq_a_le_one _ );
  -- Since the series sum((a_n)^Î±) diverges, the partial sums of the series also diverge.
  have h_partial_sums_diverge : Filter.Tendsto (fun N : â„• => âˆ‘ n âˆˆ Finset.range N, (seq_a (n + 1)) ^ Î± * (1 - (seq_a (n + 1)) ^ 2) + âˆ‘ n âˆˆ Finset.range N, (seq_a (n + 1)) ^ (2 - Î±)) Filter.atTop Filter.atTop := by
    -- Since $a_n \to 0$, we have $1 - a_n^2 \to 1$. Therefore, for large $n$, $a_n^\alpha (1 - a_n^2) \geq \frac{1}{2} a_n^\alpha$.
    have h_bound : âˆƒ Nâ‚€ : â„•, âˆ€ n â‰¥ Nâ‚€, (seq_a (n + 1)) ^ Î± * (1 - (seq_a (n + 1)) ^ 2) â‰¥ (1 / 2) * (seq_a (n + 1)) ^ Î± := by
      have h_bound : Filter.Tendsto (fun n : â„• => (seq_a (n + 1)) ^ 2) Filter.atTop (nhds 0) := by
        have h_a_n_sq_zero : Filter.Tendsto (fun n : â„• => seq_a n ^ 2) Filter.atTop (nhds 0) := by
          simpa using Filter.Tendsto.pow ( seq_a_tendsto_zero ) 2;
        exact h_a_n_sq_zero.comp ( Filter.tendsto_add_atTop_nat 1 );
      exact Filter.eventually_atTop.mp ( h_bound.eventually ( gt_mem_nhds <| show 0 < 1 / 2 by norm_num ) ) |> fun âŸ¨ Nâ‚€, hNâ‚€ âŸ© â†¦ âŸ¨ Nâ‚€, fun n hn â†¦ by nlinarith [ hNâ‚€ n hn, show 0 < seq_a ( n + 1 ) ^ Î± from Real.rpow_pos_of_pos ( seq_a_pos _ ) _ ] âŸ©;
    -- Since the series sum((a_n)^Î±) diverges, the partial sums of the series also diverge. Therefore, the partial sums of the series sum((a_n)^Î± * (1 - a_n^2)) also diverge.
    have h_partial_sums_diverge : Filter.Tendsto (fun N : â„• => âˆ‘ n âˆˆ Finset.range N, (seq_a (n + 1)) ^ Î± * (1 - (seq_a (n + 1)) ^ 2)) Filter.atTop Filter.atTop := by
      have h_partial_sums_diverge : Filter.Tendsto (fun N : â„• => âˆ‘ n âˆˆ Finset.range N, (1 / 2) * (seq_a (n + 1)) ^ Î±) Filter.atTop Filter.atTop := by
        exact not_summable_iff_tendsto_nat_atTop_of_nonneg ( fun _ => mul_nonneg ( by norm_num ) ( Real.rpow_nonneg ( le_of_lt ( seq_a_pos _ ) ) _ ) ) |>.1 ( by simpa [ summable_mul_left_iff ] using mt ( summable_nat_add_iff 1 |>.1 ) h_sum_diverges );
      obtain âŸ¨ Nâ‚€, hNâ‚€ âŸ© := h_bound;
      have h_partial_sums_diverge : Filter.Tendsto (fun N : â„• => âˆ‘ n âˆˆ Finset.range N, (seq_a (n + 1)) ^ Î± * (1 - (seq_a (n + 1)) ^ 2)) Filter.atTop Filter.atTop := by
        have h_partial_sums_diverge : âˆ€ N â‰¥ Nâ‚€, âˆ‘ n âˆˆ Finset.range N, (seq_a (n + 1)) ^ Î± * (1 - (seq_a (n + 1)) ^ 2) â‰¥ âˆ‘ n âˆˆ Finset.range Nâ‚€, (seq_a (n + 1)) ^ Î± * (1 - (seq_a (n + 1)) ^ 2) + âˆ‘ n âˆˆ Finset.Ico Nâ‚€ N, (1 / 2) * (seq_a (n + 1)) ^ Î± := by
          intro N hN; rw [ â† Finset.sum_range_add_sum_Ico _ hN ] ; exact add_le_add_left ( Finset.sum_le_sum fun n hn => hNâ‚€ n <| Finset.mem_Ico.mp hn |>.1 ) _;
        have h_partial_sums_diverge : Filter.Tendsto (fun N : â„• => âˆ‘ n âˆˆ Finset.Ico Nâ‚€ N, (1 / 2) * (seq_a (n + 1)) ^ Î±) Filter.atTop Filter.atTop := by
          have h_partial_sums_diverge : Filter.Tendsto (fun N : â„• => âˆ‘ n âˆˆ Finset.range N, (1 / 2) * (seq_a (n + 1)) ^ Î± - âˆ‘ n âˆˆ Finset.range Nâ‚€, (1 / 2) * (seq_a (n + 1)) ^ Î±) Filter.atTop Filter.atTop := by
            exact Filter.tendsto_atTop_add_const_right _ _ â€¹_â€º;
          exact h_partial_sums_diverge.congr' ( by filter_upwards [ Filter.eventually_ge_atTop Nâ‚€ ] with N hN using by rw [ Finset.sum_Ico_eq_sub _ hN ] );
        rw [ Filter.tendsto_atTop_atTop ] at *;
        exact fun b => by obtain âŸ¨ i, hi âŸ© := h_partial_sums_diverge ( b - âˆ‘ n âˆˆ Finset.range Nâ‚€, seq_a ( n + 1 ) ^ Î± * ( 1 - seq_a ( n + 1 ) ^ 2 ) ) ; exact âŸ¨ Max.max Nâ‚€ i, fun n hn => by linarith [ hi n ( le_trans ( le_max_right _ _ ) hn ), â€¹âˆ€ N â‰¥ Nâ‚€, âˆ‘ n âˆˆ Finset.range N, seq_a ( n + 1 ) ^ Î± * ( 1 - seq_a ( n + 1 ) ^ 2 ) â‰¥ âˆ‘ n âˆˆ Finset.range Nâ‚€, seq_a ( n + 1 ) ^ Î± * ( 1 - seq_a ( n + 1 ) ^ 2 ) + âˆ‘ n âˆˆ Finset.Ico Nâ‚€ N, 1 / 2 * seq_a ( n + 1 ) ^ Î±â€º n ( le_trans ( le_max_left _ _ ) hn ) ] âŸ© ;
      convert h_partial_sums_diverge using 1;
    exact Filter.tendsto_atTop_mono ( fun N => le_add_of_nonneg_right <| Finset.sum_nonneg fun _ _ => Real.rpow_nonneg ( le_of_lt <| seq_a_pos _ ) _ ) h_partial_sums_diverge;
  simp_all +decide [ Finset.sum_add_distrib ];
  exact not_tendsto_atTop_of_tendsto_nhds ( hL.comp tendsto_natCast_atTop_atTop ) ( Filter.Tendsto.congr' ( by filter_upwards [ Filter.eventually_ge_atTop 1 ] with N hN; aesop ) h_partial_sums_diverge )

/-
The function solution_f satisfies all conditions of Polya-Szego Problem 114.1.
-/
theorem problem_114_1_solution : 
    (âˆ€ x â‰¥ 0, solution_f x > 0) âˆ§ 
    (âˆ€ (a b : â„), 0 â‰¤ a â†’ a â‰¤ b â†’ âˆƒ M : â„, âˆ€ x âˆˆ Set.Icc a b, |solution_f x| â‰¤ M) âˆ§
    (âˆ€ (a b : â„), 0 â‰¤ a â†’ a â‰¤ b â†’ IntervalIntegrable solution_f volume a b) âˆ§
    (âˆƒ (L : â„), Tendsto (Î» b â†¦ âˆ« x in 0..b, solution_f x) atTop (ğ“ L)) âˆ§
    (âˆ€ (Î± : â„), Î± â‰  1 â†’ Â¬âˆƒ (L : â„), Tendsto (Î» b â†¦ âˆ« x in 0..b, (solution_f x) ^ Î±) atTop (ğ“ L)) := by
  refine' âŸ¨ _, _, _, _, _ âŸ©
  Â· exact solution_f_pos
  Â· exact solution_f_bounded_on_Icc
  Â· exact solution_f_intervalIntegrable
  Â· exact integral_solution_f_converges
  Â· intro Î± hÎ±
    rcases lt_trichotomy Î± 1 with h | h | h
    Â· exact integral_diverges_of_alpha_lt_one Î± h
    Â· contradiction
    Â· exact integral_diverges_of_alpha_gt_one Î± h