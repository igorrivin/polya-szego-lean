/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f810a6e4-0c17-4b1c-bf99-3eabf2c993e9
-/

/-
We formalize the problem about computing velocity and acceleration components for planar motion in polar coordinates.

Given:
  r : ℝ → ℝ (radius as function of time)
  θ : ℝ → ℝ (angle as function of time)  
  z(t) = r(t) * Complex.exp (Complex.I * θ(t))

The velocity components are:
  - Radial component: dr/dt (along radius vector)
  - Tangential component: r * dθ/dt (perpendicular to radius vector)

The acceleration components are:
  - Radial: d²r/dt² - r * (dθ/dt)²
  - Tangential: r * d²θ/dt² + 2 * (dr/dt) * (dθ/dt)

We state this as equalities between derivatives and the claimed expressions.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of z(t) in polar coordinates.
-/
noncomputable def z (r θ : ℝ → ℝ) (t : ℝ) : ℂ := (r t : ℂ) * Complex.exp (Complex.I * (θ t : ℂ))

/-
Velocity components in polar coordinates.
-/
theorem problem_10_velocity_components (r θ : ℝ → ℝ) (t : ℝ)
    (hdr : DifferentiableAt ℝ r t) (hdθ : DifferentiableAt ℝ θ t) :
    let v : ℂ := deriv (z r θ) t
    let e_r : ℂ := Complex.exp (Complex.I * (θ t : ℂ))
    let v_r : ℝ := deriv r t
    let v_θ : ℝ := (r t) * deriv θ t
    v = (v_r : ℂ) * e_r + (v_θ : ℂ) * (Complex.I * e_r) := by
      convert HasDerivAt.deriv ( HasDerivAt.mul ( HasDerivAt.ofReal_comp ( hasDerivAt_deriv_iff.mpr hdr ) ) ( HasDerivAt.comp t ( Complex.hasDerivAt_exp _ ) ( HasDerivAt.mul ( hasDerivAt_const _ _ ) ( HasDerivAt.ofReal_comp ( hasDerivAt_deriv_iff.mpr hdθ ) ) ) ) ) using 1 ; norm_num ; ring

/-
Acceleration components in polar coordinates.
-/
theorem problem_10_acceleration_components (r θ : ℝ → ℝ) (t : ℝ)
    (hdr : ContDiffAt ℝ 2 r t) (hdθ : ContDiffAt ℝ 2 θ t) :
    let z : ℝ → ℂ := z r θ
    let a : ℂ := deriv (deriv z) t
    let e_r : ℂ := Complex.exp (Complex.I * (θ t : ℂ))
    let a_r : ℝ := deriv (deriv r) t - r t * (deriv θ t) ^ 2
    let a_θ : ℝ := r t * deriv (deriv θ) t + 2 * deriv r t * deriv θ t
    a = (a_r : ℂ) * e_r + (a_θ : ℂ) * (Complex.I * e_r) := by
      apply_rules [ HasDerivAt.deriv ];
      -- Apply the product rule to differentiate the velocity components.
      have h_deriv1 : HasDerivAt (fun t => (deriv r t) * Complex.exp (Complex.I * (θ t)) + (r t) * Complex.exp (Complex.I * (θ t)) * Complex.I * (deriv θ t))
        ((deriv (deriv r) t) * Complex.exp (Complex.I * (θ t)) + (deriv r t) * Complex.exp (Complex.I * (θ t)) * Complex.I * (deriv θ t) +
         (deriv r t) * Complex.exp (Complex.I * (θ t)) * Complex.I * (deriv θ t) +
         (r t) * Complex.exp (Complex.I * (θ t)) * Complex.I * (deriv (deriv θ) t) -
         (r t) * Complex.exp (Complex.I * (θ t)) * (deriv θ t) ^ 2) t := by
           have h_deriv1 : HasDerivAt (fun t => deriv r t) (deriv (deriv r) t) t ∧ HasDerivAt (fun t => deriv θ t) (deriv (deriv θ) t) t := by
             have h_diff : ContDiffAt ℝ 1 (deriv r) t ∧ ContDiffAt ℝ 1 (deriv θ) t := by
               constructor;
               · have h_diff_r : ∃ ε > 0, ContDiffOn ℝ 2 r (Metric.ball t ε) := by
                   rcases Metric.mem_nhds_iff.mp ( hdr.eventually ( by norm_num ) ) with ⟨ ε, εpos, hε ⟩;
                   exact ⟨ ε, εpos, fun x hx => ( hε hx ) |> ContDiffAt.contDiffWithinAt ⟩;
                 obtain ⟨ ε, ε_pos, hε ⟩ := h_diff_r;
                 have h_diff_r : ContDiffOn ℝ 1 (deriv r) (Metric.ball t ε) := by
                   exact hε.deriv_of_isOpen Metric.isOpen_ball ( by norm_num );
                 exact h_diff_r.contDiffAt ( Metric.isOpen_ball.mem_nhds <| Metric.mem_ball_self ε_pos );
               · have h_cont_diff : ContDiffAt ℝ 2 θ t → ContDiffAt ℝ 1 (deriv θ) t := by
                   intro hθ
                   have h_cont_diff : ∃ U : Set ℝ, IsOpen U ∧ t ∈ U ∧ ContDiffOn ℝ 2 θ U := by
                     have := hθ.eventually;
                     rw [ Metric.eventually_nhds_iff ] at this;
                     exact ⟨ Metric.ball t ( Classical.choose ( this ( by norm_num ) ) ), Metric.isOpen_ball, Metric.mem_ball_self ( Classical.choose_spec ( this ( by norm_num ) ) |>.1 ), fun x hx => ( Classical.choose_spec ( this ( by norm_num ) ) |>.2 hx ) |> ContDiffAt.contDiffWithinAt ⟩;
                   obtain ⟨ U, hU₁, hU₂, hU₃ ⟩ := h_cont_diff;
                   have h_cont_diff : ContDiffOn ℝ 1 (deriv θ) U := by
                     exact hU₃.deriv_of_isOpen hU₁ ( by norm_num );
                   exact h_cont_diff.contDiffAt ( hU₁.mem_nhds hU₂ );
                 exact h_cont_diff hdθ;
             exact ⟨ h_diff.1.differentiableAt le_rfl |> DifferentiableAt.hasDerivAt, h_diff.2.differentiableAt le_rfl |> DifferentiableAt.hasDerivAt ⟩;
           convert HasDerivAt.add ( HasDerivAt.mul ( HasDerivAt.ofReal_comp h_deriv1.1 ) ( HasDerivAt.comp t ( Complex.hasDerivAt_exp _ ) ( HasDerivAt.const_mul Complex.I ( HasDerivAt.ofReal_comp ( hdθ.differentiableAt ( by norm_num ) |> DifferentiableAt.hasDerivAt ) ) ) ) ) ( HasDerivAt.mul ( HasDerivAt.mul ( HasDerivAt.mul ( HasDerivAt.ofReal_comp ( hdr.differentiableAt ( by norm_num ) |> DifferentiableAt.hasDerivAt ) ) ( HasDerivAt.comp t ( Complex.hasDerivAt_exp _ ) ( HasDerivAt.const_mul Complex.I ( HasDerivAt.ofReal_comp ( hdθ.differentiableAt ( by norm_num ) |> DifferentiableAt.hasDerivAt ) ) ) ) ) ( hasDerivAt_const _ _ ) ) ( HasDerivAt.ofReal_comp h_deriv1.2 ) ) using 1 ; norm_num ; ring;
           norm_num ; ring;
      convert h_deriv1.congr_of_eventuallyEq _ using 1;
      · push_cast; ring;
      · filter_upwards [ hdr.eventually ( by norm_num ), hdθ.eventually ( by norm_num ) ] with u hu hu';
        convert HasDerivAt.deriv ( HasDerivAt.mul ( HasDerivAt.ofReal_comp ( hu.differentiableAt ( by norm_num ) |> DifferentiableAt.hasDerivAt ) ) ( HasDerivAt.comp u ( Complex.hasDerivAt_exp _ ) ( HasDerivAt.const_mul Complex.I ( HasDerivAt.ofReal_comp ( hu'.differentiableAt ( by norm_num ) |> DifferentiableAt.hasDerivAt ) ) ) ) ) using 1 ; norm_num ; ring