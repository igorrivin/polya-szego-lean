/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b4f24094-ce1a-46bf-ba56-068605358e39
-/

/-
We have formalized and proved Polya-Szego Problem 108, which states that if a power series converges absolutely at a point on its boundary, then it converges uniformly on the closed disk up to that boundary point. The formalization uses the Cauchy criterion for uniform convergence.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Complex
open scoped ComplexConjugate

#check cauchySeq_finset_of_summable_norm

/-
If a power series converges absolutely at a point on its boundary, then it converges uniformly on the closed disk up to that boundary point.
-/
theorem problem_108 (coeff : ℕ → ℂ) (R : ℝ) (z₀ : ℂ)
    (hR : 0 < R)
    (hz₀ : norm z₀ = R)
    (hsum : Summable fun (n : ℕ) => norm (coeff n * z₀^n)) :
    ∀ (ε : ℝ), 0 < ε →
    ∃ (N : ℕ), ∀ (n m : ℕ), N ≤ n → N ≤ m → ∀ (z : ℂ), norm z ≤ R →
    norm (∑ k ∈ Finset.range n, coeff k * z^k - ∑ k ∈ Finset.range m, coeff k * z^k) < ε := by
      -- By the properties of summability, we can apply the Weierstrass M-test to the power series.
      have h_mtest : Summable (fun n => ‖(coeff n) * R ^ n‖) := by
        aesop;
      intro ε hε
      obtain ⟨N, hN⟩ : ∃ N, ∀ n m, N ≤ n → N ≤ m → ∑ k ∈ Finset.Ico n m, ‖(coeff k) * R ^ k‖ < ε := by
        have := Metric.tendsto_atTop.mp h_mtest.hasSum.tendsto_sum_nat;
        obtain ⟨ N, HN ⟩ := this ( ε / 2 ) ( half_pos hε ) ; refine' ⟨ N, fun n m hn hm => _ ⟩ ; cases le_total n m <;> simp_all +decide [ Finset.sum_Ico_eq_sub _ ];
        linarith [ abs_lt.mp ( HN n hn ), abs_lt.mp ( HN m hm ) ];
      refine' ⟨ N, fun n m hn hm z hz => _ ⟩ ; cases le_total n m <;> simp_all +decide [ ← Finset.sum_range_add_sum_Ico _ ‹_› ];
      · refine' lt_of_le_of_lt ( norm_sum_le _ _ ) _;
        exact lt_of_le_of_lt ( Finset.sum_le_sum fun _ _ => by simpa [ abs_of_pos hR ] using mul_le_mul_of_nonneg_left ( pow_le_pow_left₀ ( norm_nonneg _ ) hz _ ) ( norm_nonneg _ ) ) ( hN _ _ hn hm );
      · exact lt_of_le_of_lt ( norm_sum_le _ _ ) <| lt_of_le_of_lt ( Finset.sum_le_sum fun _ _ => by simpa [ abs_of_nonneg hR.le ] using mul_le_mul_of_nonneg_left ( pow_le_pow_left₀ ( by positivity ) hz _ ) <| norm_nonneg _ ) <| hN _ _ hm hn