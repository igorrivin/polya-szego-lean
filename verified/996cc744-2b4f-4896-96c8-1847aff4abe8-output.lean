/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 996cc744-2b4f-4896-96c8-1847aff4abe8
-/

/-
We formalized and proved Polya-Szego Problem 142.
The main theorem is `problem_142`, which states that if the Laplace transform of a continuous function $\varphi$ vanishes on an arithmetic progression $k_0 + n\alpha$ (with $\alpha > 0$), then $\varphi$ is identically zero.
The proof involves defining an auxiliary function $\Phi(x) = \int_0^x e^{-k_0 t} \varphi(t) dt$, showing it vanishes at infinity, and then using a change of variables $u = e^{-\alpha x}$ to transform the problem into a moment problem on $[0, 1]$. We proved that a continuous function on $[0, 1]$ with all zero moments is identically zero (`continuous_zero_moments`), and used this to show $\Phi$ is zero, which implies $\varphi$ is zero.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Checking if Filter.Tendsto is available.
-/
#check Filter.Tendsto

/-
Checking availability of nhds and intervalIntegral
-/
#check nhds
#check intervalIntegral

/-
Checking availability of Filter.atTop
-/
#check Filter.atTop

/-
Checking availability of MeasureTheory.volume
-/
#check MeasureTheory.volume

/-
If a continuous function on [0,1] has all its moments equal to 0, then the function is identically 0.
-/
theorem continuous_zero_moments {f : ℝ → ℝ} (hf : ContinuousOn f (Set.Icc 0 1))
    (hmoments : ∀ n : ℕ, ∫ x in 0..1, x ^ n * f x = 0) :
    ∀ x ∈ Set.Icc 0 1, f x = 0 := by
  -- Therefore, $f$ must be zero everywhere on $[0,1]$.
  have h_zero : ∫ x in Set.Icc 0 1, f x ^ 2 = 0 := by
    -- By the properties of the Weierstrass approximation theorem, there exists a sequence of polynomials $p_n$ such that $p_n \to f$ uniformly on $[0, 1]$.
    obtain ⟨p_n, hp_n⟩ : ∃ p_n : ℕ → Polynomial ℝ, (∀ n, ∀ x ∈ Set.Icc (0 : ℝ) 1, |(p_n n).eval x - f x| < 1 / (n + 1)) := by
      have h_weierstrass : ∀ ε > 0, ∃ p : Polynomial ℝ, ∀ x ∈ Set.Icc 0 1, |p.eval x - f x| < ε := by
        apply_rules [ exists_polynomial_near_of_continuousOn ];
      exact ⟨ fun n => Classical.choose ( h_weierstrass _ <| by positivity ), fun n x hx => Classical.choose_spec ( h_weierstrass _ <| by positivity ) x hx ⟩;
    -- Since $p_n \to f$ uniformly on $[0, 1]$, we have $\int_0^1 p_n(x) f(x) \, dx \to \int_0^1 f(x)^2 \, dx$.
    have h_integral : Filter.Tendsto (fun n => ∫ x in Set.Icc (0 : ℝ) 1, (p_n n).eval x * f x) Filter.atTop (nhds (∫ x in Set.Icc (0 : ℝ) 1, f x ^ 2)) := by
      refine' MeasureTheory.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _;
      refine' fun x => ( |f x| + 1 ) * |f x|;
      · exact Filter.Eventually.of_forall fun n => ContinuousOn.aestronglyMeasurable ( by exact ContinuousOn.mul ( Polynomial.continuousOn _ ) hf ) measurableSet_Icc;
      · filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn;
        filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using by rw [ Real.norm_eq_abs, abs_le ] ; constructor <;> cases abs_cases ( f x ) <;> nlinarith [ abs_lt.mp ( hp_n n x hx ), show ( 1 : ℝ ) / ( n + 1 ) ≤ 1 by rw [ div_le_iff₀ ] <;> norm_cast <;> linarith ] ;
      · exact ContinuousOn.integrableOn_Icc ( by exact ContinuousOn.mul ( hf.abs.add continuousOn_const ) hf.abs );
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using by simpa [ sq ] using Filter.Tendsto.mul ( show Filter.Tendsto ( fun n => Polynomial.eval x ( p_n n ) ) Filter.atTop ( nhds ( f x ) ) from tendsto_iff_norm_sub_tendsto_zero.mpr <| squeeze_zero ( fun _ => by positivity ) ( fun n => le_of_lt <| hp_n n x hx ) <| tendsto_one_div_add_atTop_nhds_zero_nat ) tendsto_const_nhds;
    -- Since $\int_0^1 x^n f(x) \, dx = 0$ for all $n$, we have $\int_0^1 p_n(x) f(x) \, dx = 0$ for all $n$.
    have h_zero_integral : ∀ n, ∫ x in Set.Icc (0 : ℝ) 1, (p_n n).eval x * f x = 0 := by
      intro n
      have h_poly_integral : ∫ x in Set.Icc (0 : ℝ) 1, (p_n n).eval x * f x = ∑ i ∈ Finset.range (p_n n).natDegree.succ, (p_n n).coeff i * ∫ x in Set.Icc (0 : ℝ) 1, x ^ i * f x := by
        simp +decide [ Polynomial.eval_eq_sum_range, Finset.sum_mul _ _ _, mul_assoc, ← MeasureTheory.integral_const_mul ];
        exact MeasureTheory.integral_finset_sum _ fun i hi => ContinuousOn.integrableOn_Icc <| by exact ContinuousOn.mul ( continuousOn_const ) <| ContinuousOn.mul ( continuousOn_pow _ ) hf;
      simp_all +decide [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le zero_le_one ];
    exact tendsto_nhds_unique h_integral ( by simpa only [ h_zero_integral ] using tendsto_const_nhds );
  intro x hx;
  contrapose! h_zero;
  -- Since $f(x) \neq 0$, there exists an interval $(a, b) \subseteq [0, 1]$ around $x$ where $f$ is non-zero.
  obtain ⟨a, b, hab⟩ : ∃ a b : ℝ, 0 ≤ a ∧ a < b ∧ b ≤ 1 ∧ ∀ y ∈ Set.Ioo a b, f y ≠ 0 := by
    have := Metric.continuousOn_iff.mp hf x hx;
    obtain ⟨ δ, δ_pos, H ⟩ := this ( |f x| ) ( abs_pos.mpr h_zero );
    simp_all +decide [ abs_lt ];
    exact ⟨ Max.max 0 ( x - δ / 2 ), by positivity, Min.min 1 ( x + δ / 2 ), by cases max_cases 0 ( x - δ / 2 ) <;> cases min_cases 1 ( x + δ / 2 ) <;> linarith, by cases max_cases 0 ( x - δ / 2 ) <;> cases min_cases 1 ( x + δ / 2 ) <;> linarith, fun y hy₁ hy₂ => by cases abs_cases ( f x ) <;> linarith [ abs_lt.mp ( H y ( by cases max_cases 0 ( x - δ / 2 ) <;> linarith ) ( by cases min_cases 1 ( x + δ / 2 ) <;> linarith ) ( abs_lt.mpr ⟨ by cases max_cases 0 ( x - δ / 2 ) <;> linarith, by cases min_cases 1 ( x + δ / 2 ) <;> linarith ⟩ ) ) ] ⟩;
  -- Since $f$ is non-zero on $(a, b)$, we have $\int_a^b f(x)^2 \, dx > 0$.
  have h_pos : 0 < ∫ x in Set.Ioo a b, f x ^ 2 := by
    rw [ MeasureTheory.integral_pos_iff_support_of_nonneg_ae ];
    · simp +zetaDelta at *;
      exact lt_of_lt_of_le ( by aesop ) ( MeasureTheory.measure_mono ( show Set.Ioo a b ⊆ Function.support f ∩ Set.Ioo a b from fun x hx => ⟨ hab.2.2.2 x hx.1 hx.2, hx ⟩ ) );
    · exact Filter.Eventually.of_forall fun x => sq_nonneg _;
    · exact ContinuousOn.integrableOn_Icc ( by exact ContinuousOn.pow ( hf.mono ( Set.Icc_subset_Icc ( by linarith ) ( by linarith ) ) ) 2 ) |> fun h => h.mono_set ( Set.Ioo_subset_Icc_self );
  refine' ne_of_gt ( lt_of_lt_of_le h_pos ( MeasureTheory.setIntegral_mono_set _ _ _ ) );
  · exact ContinuousOn.integrableOn_Icc ( hf.pow 2 );
  · exact Filter.Eventually.of_forall fun x => sq_nonneg _;
  · exact MeasureTheory.ae_of_all _ fun x hx => ⟨ by linarith [ hx.1 ], by linarith [ hx.2 ] ⟩

/-
The function Phi tends to 0 at infinity.
-/
def Phi (φ : ℝ → ℝ) (k₀ : ℝ) (x : ℝ) : ℝ := ∫ t in 0..x, Real.exp (-k₀ * t) * φ t

theorem Phi_tendsto_zero {φ : ℝ → ℝ} {k₀ α : ℝ}
    (hzeros : ∀ (n : ℕ),
        let k := k₀ + (n : ℝ) * α
        ∃ (Jn : ℝ), Filter.Tendsto (λ (T : ℝ) ↦ ∫ x in 0..T, Real.exp (-k * x) * φ x) Filter.atTop (nhds Jn) ∧ Jn = 0) :
    Filter.Tendsto (Phi φ k₀) Filter.atTop (nhds 0) := by
  exact hzeros 0 |> fun ⟨ J, hJ₁, hJ₂ ⟩ => hJ₂ ▸ hJ₁.congr ( by intros; simp [Phi] )

/-
Integration by parts formula relating the Laplace transform of φ to the Laplace transform of Φ.
-/
lemma integral_parts_lemma {φ : ℝ → ℝ} {k₀ s : ℝ} (hs : s > 0)
    (hcont : ContinuousOn φ (Set.Ici 0))
    (hPhi_lim : Filter.Tendsto (Phi φ k₀) Filter.atTop (nhds 0)) :
    Filter.Tendsto (λ T ↦ ∫ x in 0..T, Real.exp (-(k₀ + s) * x) * φ x) Filter.atTop (nhds (s * ∫ x in Set.Ioi 0, Real.exp (-s * x) * Phi φ k₀ x)) := by
  -- Let's simplify the integral expression.
  have h_integral_simplified : ∀ T > 0, ∫ x in (0 : ℝ)..T, Real.exp (-(k₀ + s) * x) * φ x = Real.exp (-s * T) * Phi φ k₀ T + s * ∫ x in (0 : ℝ)..T, Real.exp (-s * x) * Phi φ k₀ x := by
    intro T hT_pos
    have h_parts : ∫ x in (0 : ℝ)..T, Real.exp (-(k₀ + s) * x) * φ x = (Real.exp (-s * T) * Phi φ k₀ T) - (Real.exp (-s * 0) * Phi φ k₀ 0) - ∫ x in (0 : ℝ)..T, Phi φ k₀ x * (-s * Real.exp (-s * x)) := by
      rw [ eq_sub_iff_add_eq, ← intervalIntegral.integral_add ];
      · rw [ intervalIntegral.integral_eq_sub_of_hasDeriv_right ];
        · refine' ContinuousOn.mul ( Continuous.continuousOn ( by continuity ) ) _;
          intro x hx; apply_rules [ intervalIntegral.continuousWithinAt_primitive ] ; aesop;
          apply_rules [ ContinuousOn.intervalIntegrable ];
          simpa [ hT_pos.le ] using ContinuousOn.mul ( Continuous.continuousOn ( by continuity ) ) ( hcont.mono ( Set.Icc_subset_Ici_self ) );
        · intro x hx
          have h_deriv : HasDerivAt (fun T => Phi φ k₀ T) (Real.exp (-k₀ * x) * φ x) x := by
            apply_rules [ intervalIntegral.integral_hasDerivAt_right ];
            · apply_rules [ ContinuousOn.intervalIntegrable ];
              exact ContinuousOn.mul ( ContinuousOn.rexp ( continuousOn_const.mul continuousOn_id ) ) ( hcont.mono ( by rw [ Set.uIcc_of_le ( by cases min_cases 0 T <;> cases max_cases 0 T <;> linarith [ hx.1, hx.2 ] ) ] ; exact Set.Icc_subset_Ici_self ) );
            · simp +zetaDelta at *;
              exact ⟨ Set.Ioi 0, Ioi_mem_nhds ( show 0 < x by cases hx.1 <;> linarith ), ContinuousOn.aestronglyMeasurable ( by exact ContinuousOn.mul ( Continuous.continuousOn ( by continuity ) ) ( hcont.mono ( Set.Ioi_subset_Ici_self ) ) ) measurableSet_Ioi ⟩;
            · exact ContinuousAt.mul ( ContinuousAt.rexp ( continuousAt_const.mul continuousAt_id ) ) ( hcont.continuousAt ( Ici_mem_nhds ( by cases min_cases 0 T <;> cases max_cases 0 T <;> linarith [ hx.1, hx.2 ] ) ) );
          convert HasDerivAt.hasDerivWithinAt ( HasDerivAt.mul ( HasDerivAt.exp ( HasDerivAt.const_mul ( -s ) ( hasDerivAt_id x ) ) ) h_deriv ) using 1 ; ring;
          simpa only [ sub_eq_add_neg, Real.exp_add ] using by ring!;
        · apply_rules [ ContinuousOn.intervalIntegrable ];
          refine' ContinuousOn.add _ _;
          · exact ContinuousOn.mul ( ContinuousOn.rexp ( continuousOn_const.mul continuousOn_id ) ) ( hcont.mono ( by rw [ Set.uIcc_of_le hT_pos.le ] ; exact Set.Icc_subset_Ici_self ) );
          · refine' ContinuousOn.mul _ _;
            · intro x hx; apply_rules [ intervalIntegral.continuousWithinAt_primitive ] ; aesop;
              apply_rules [ ContinuousOn.intervalIntegrable ];
              simpa [ hT_pos.le ] using ContinuousOn.mul ( ContinuousOn.rexp ( ContinuousOn.neg ( continuousOn_const.mul continuousOn_id ) ) ) ( hcont.mono ( Set.Icc_subset_Ici_self ) );
            · exact Continuous.continuousOn ( by continuity );
      · apply_rules [ ContinuousOn.intervalIntegrable ];
        exact ContinuousOn.mul ( ContinuousOn.rexp ( continuousOn_const.mul continuousOn_id ) ) ( hcont.mono ( by rw [ Set.uIcc_of_le hT_pos.le ] ; exact Set.Icc_subset_Ici_self ) );
      · apply_rules [ ContinuousOn.intervalIntegrable ];
        field_simp;
        refine' ContinuousOn.neg ( ContinuousOn.mul ( ContinuousOn.mul _ continuousOn_const ) ( ContinuousOn.rexp ( ContinuousOn.neg ( continuousOn_const.mul continuousOn_id ) ) ) );
        intro x hx; apply_rules [ intervalIntegral.continuousWithinAt_primitive ] ; aesop;
        apply_rules [ ContinuousOn.intervalIntegrable ];
        simpa [ hT_pos.le ] using ContinuousOn.mul ( Continuous.continuousOn ( by continuity ) ) ( hcont.mono ( Set.Icc_subset_Ici_self ) )
    simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
    unfold Phi; norm_num;
  -- Using the fact that the integral of a continuous function over an interval is continuous, we can bring the limit inside.
  have h_cont : Filter.Tendsto (fun T => ∫ x in (0 : ℝ)..T, Real.exp (-s * x) * Phi φ k₀ x) Filter.atTop (nhds (∫ x in Set.Ioi 0, Real.exp (-s * x) * Phi φ k₀ x)) := by
    -- To prove the convergence of the integral, we use the fact that the product of continuous functions is integrable.
    have h_integrable : MeasureTheory.IntegrableOn (fun x => Real.exp (-s * x) * Phi φ k₀ x) (Set.Ioi 0) := by
      -- Since $\Phi$ is continuous and tends to $0$, it is bounded. Let $M$ be an upper bound for $|\Phi(x)|$.
      obtain ⟨M, hM⟩ : ∃ M > 0, ∀ x ≥ 0, abs (Phi φ k₀ x) ≤ M := by
        have := hPhi_lim.abs;
        obtain ⟨ M, hM ⟩ := Metric.tendsto_atTop.mp this 1 zero_lt_one;
        -- Since $|\Phi(x)|$ is continuous on $[0, \infty)$ and tends to $0$ as $x \to \infty$, it is bounded on $[0, \infty)$.
        have h_bounded : ∃ C, ∀ x ∈ Set.Icc 0 M, abs (Phi φ k₀ x) ≤ C := by
          have h_bounded : ContinuousOn (fun x => Phi φ k₀ x) (Set.Icc 0 M) := by
            intro x hx; apply_rules [ intervalIntegral.continuousWithinAt_primitive, ContinuousOn.intervalIntegrable ] ; aesop;
            exact ContinuousOn.mul ( ContinuousOn.rexp ( continuousOn_const.mul continuousOn_id ) ) ( hcont.mono ( by intro x hx; aesop ) );
          exact IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) h_bounded;
        exact ⟨ Max.max h_bounded.choose 1, by positivity, fun x hx => if hx' : x ≤ M then le_trans ( h_bounded.choose_spec x ⟨ hx, hx' ⟩ ) ( le_max_left _ _ ) else le_trans ( le_of_lt ( by simpa using hM x ( le_of_not_ge hx' ) ) ) ( le_max_right _ _ ) ⟩;
      have h_integrable : MeasureTheory.IntegrableOn (fun x => Real.exp (-s * x) * M) (Set.Ioi 0) := by
        exact ( MeasureTheory.Integrable.mul_const ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by simpa [ mul_comm ] using ( exp_neg_integrableOn_Ioi 0 hs ) ) ) ) ) ) ) ) ) ) ) ) ) _ );
      refine' h_integrable.mono' _ _;
      · refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
        · exact Continuous.aestronglyMeasurable ( by continuity );
        · refine' ContinuousOn.aestronglyMeasurable _ measurableSet_Ioi;
          have h_cont : ContinuousOn (fun x => ∫ t in (0 : ℝ)..x, Real.exp (-k₀ * t) * φ t) (Set.Ioi 0) := by
            have h_cont_aux : ∀ x > 0, ContinuousOn (fun x => ∫ t in (0 : ℝ)..x, Real.exp (-k₀ * t) * φ t) (Set.Icc 0 x) := by
              intro x hx; intro y hy; apply_rules [ intervalIntegral.continuousWithinAt_primitive, ContinuousOn.intervalIntegrable ] ; aesop;
              simpa [ hx.le ] using ContinuousOn.mul ( ContinuousOn.rexp ( ContinuousOn.neg ( continuousOn_const.mul continuousOn_id ) ) ) ( hcont.mono ( Set.Icc_subset_Ici_self ) )
            exact fun x hx => ContinuousAt.continuousWithinAt ( by have := h_cont_aux ( x + 1 ) ( by linarith [ hx.out ] ) ; exact this.continuousAt ( Icc_mem_nhds ( by linarith [ hx.out ] ) ( by linarith [ hx.out ] ) ) );
          exact h_cont;
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with x hx using by simpa only [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( Real.exp_pos _ |> LT.lt.le ) ] using mul_le_mul_of_nonneg_left ( hM.2 x hx.out.le ) ( Real.exp_pos _ |> LT.lt.le ) ;
    apply_rules [ MeasureTheory.intervalIntegral_tendsto_integral_Ioi ];
    exact Filter.tendsto_id;
  rw [ Filter.tendsto_congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using h_integral_simplified T hT ) ] ; simpa using Filter.Tendsto.add ( Filter.Tendsto.mul ( Real.tendsto_exp_atBot.comp <| Filter.tendsto_neg_atTop_atBot.comp <| Filter.tendsto_id.const_mul_atTop hs ) hPhi_lim ) ( h_cont.const_mul s ) ;

/-
H is continuous on [0, 1].
-/
def H (φ : ℝ → ℝ) (k₀ α : ℝ) (u : ℝ) : ℝ :=
  if u ∈ Set.Ioo 0 1 then Phi φ k₀ (-Real.log u / α) else 0

lemma H_continuous {φ : ℝ → ℝ} {k₀ α : ℝ} (hα : α > 0)
    (hcont : ContinuousOn φ (Set.Ici 0))
    (hPhi_lim : Filter.Tendsto (Phi φ k₀) Filter.atTop (nhds 0)) :
    ContinuousOn (H φ k₀ α) (Set.Icc 0 1) := by
  refine' ContinuousOn.congr _ _;
  exact fun x => if x ∈ Set.Ioo 0 1 then Phi φ k₀ ( -Real.log x / α ) else 0;
  · -- To prove continuity at the endpoints, we need to show that the limit of $H(u)$ as $u$ approaches $0$ from the right is $0$ and the limit as $u$ approaches $1$ from the left is $0$.
    have h_cont_at_0 : Filter.Tendsto (fun u => Phi φ k₀ (-Real.log u / α)) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
      exact hPhi_lim.comp <| Filter.Tendsto.atTop_div_const ( by positivity ) <| Filter.tendsto_neg_atBot_atTop.comp <| Real.tendsto_log_nhdsNE_zero.mono_left <| nhdsWithin_mono _ <| by norm_num;
    have h_cont_at_1 : Filter.Tendsto (fun u => Phi φ k₀ (-Real.log u / α)) (nhdsWithin 1 (Set.Iio 1)) (nhds 0) := by
      convert Filter.Tendsto.comp ( show Filter.Tendsto ( fun u => Phi φ k₀ u ) ( nhdsWithin 0 ( Set.Ioi 0 ) ) ( nhds 0 ) from ?_ ) ( show Filter.Tendsto ( fun u => -Real.log u / α ) ( nhdsWithin 1 ( Set.Iio 1 ) ) ( nhdsWithin 0 ( Set.Ioi 0 ) ) from ?_ ) using 2;
      · have h_cont_at_0 : ContinuousOn (fun u => Phi φ k₀ u) (Set.Icc 0 1) := by
          apply_rules [ ContinuousOn.add, ContinuousOn.mul, continuousOn_const, continuousOn_id, intervalIntegral.continuousOn_primitive ];
          · exact ContinuousOn.integrableOn_Icc ( by exact ContinuousOn.mul ( ContinuousOn.rexp ( continuousOn_const.mul continuousOn_id ) ) ( hcont.mono ( Set.Icc_subset_Ici_self ) ) );
          · exact ContinuousOn.congr ( show ContinuousOn ( fun _ => 0 ) _ from continuousOn_const ) fun x hx => by simp +decide [ hx.1 ] ;
        have := h_cont_at_0 0 ( by norm_num );
        convert this.tendsto.mono_left _ using 2 <;> norm_num;
        · unfold Phi; norm_num;
        · exact nhdsWithin_mono _ <| Set.Ioi_subset_Ici_self;
      · refine' tendsto_nhdsWithin_iff.mpr _;
        exact ⟨ tendsto_nhdsWithin_of_tendsto_nhds ( by simpa using Filter.Tendsto.div_const ( Filter.Tendsto.neg ( Real.continuousAt_log one_ne_zero ) ) α ), mem_nhdsLT_iff_exists_Ioo_subset.mpr ⟨ 0, by norm_num, fun x hx => div_pos ( neg_pos_of_neg ( Real.log_neg hx.1 hx.2 ) ) hα ⟩ ⟩;
    intro x hx; by_cases hx0 : x = 0 <;> by_cases hx1 : x = 1 <;> simp_all +decide [ ContinuousWithinAt ] ;
    · rw [ Metric.tendsto_nhdsWithin_nhds ] at *;
      intro ε hε; rcases h_cont_at_0 ε hε with ⟨ δ, hδ, H ⟩ ; rcases h_cont_at_1 ε hε with ⟨ δ', hδ', H' ⟩ ; use Min.min δ δ'; aesop;
    · rw [ Metric.tendsto_nhdsWithin_nhds ] at *;
      intro ε hε; rcases h_cont_at_1 ε hε with ⟨ δ, hδ, H ⟩ ; use Min.min δ 1; aesop;
    · rw [ if_pos ⟨ lt_of_le_of_ne hx.1 ( Ne.symm hx0 ), lt_of_le_of_ne hx.2 hx1 ⟩ ];
      refine' Filter.Tendsto.congr' _ _;
      use fun u => Phi φ k₀ ( -Real.log u / α );
      · filter_upwards [ eventually_nhdsWithin_of_eventually_nhds ( Ioo_mem_nhds ( lt_of_le_of_ne hx.1 ( Ne.symm hx0 ) ) ( lt_of_le_of_ne hx.2 hx1 ) ) ] with u hu using by aesop;
      · -- Since $\Phi$ is continuous on $[0, \infty)$, the composition $\Phi(\cdot)$ is continuous on $(0, 1)$.
        have h_cont_Phi : ContinuousOn (fun u => Phi φ k₀ (-Real.log u / α)) (Set.Ioo 0 1) := by
          refine' ContinuousOn.comp ( show ContinuousOn ( fun u => ∫ t in ( 0 : ℝ )..u, Real.exp ( -k₀ * t ) * φ t ) ( Set.Ici 0 ) from _ ) _ _;
          · intro u hu;
            -- The integral of a continuous function is continuous, hence the composition is continuous.
            have h_cont_int : ContinuousOn (fun u => ∫ t in (0 : ℝ)..u, Real.exp (-k₀ * t) * φ t) (Set.Icc 0 (u + 1)) := by
              intro u hu; apply_rules [ intervalIntegral.continuousWithinAt_primitive ] ; aesop;
              apply_rules [ ContinuousOn.intervalIntegrable ];
              exact ContinuousOn.mul ( ContinuousOn.rexp ( continuousOn_const.mul continuousOn_id ) ) ( hcont.mono ( by intro x hx; aesop ) );
            have := h_cont_int u ⟨ hu, by linarith [ hu.out ] ⟩;
            rw [ Metric.continuousWithinAt_iff ] at *;
            exact fun ε hε => by obtain ⟨ δ, hδ, H ⟩ := this ε hε; exact ⟨ Min.min δ 1, lt_min hδ zero_lt_one, fun x hx₁ hx₂ => H ⟨ hx₁, by linarith [ abs_lt.mp hx₂, min_le_left δ 1, min_le_right δ 1 ] ⟩ ( by exact lt_of_lt_of_le hx₂ ( min_le_left _ _ ) ) ⟩ ;
          · field_simp;
            exact ContinuousOn.neg ( ContinuousOn.div_const ( Real.continuousOn_log.mono <| by norm_num ) _ );
          · exact fun u hu => div_nonneg ( neg_nonneg_of_nonpos ( Real.log_nonpos hu.1.le hu.2.le ) ) hα.le;
        exact h_cont_Phi.continuousAt ( Ioo_mem_nhds ( lt_of_le_of_ne hx.1 ( Ne.symm hx0 ) ) ( lt_of_le_of_ne hx.2 hx1 ) ) |> fun h => h.mono_left inf_le_left;
  · intro x hx; unfold H; aesop;

/-
The Laplace transform of Phi vanishes at multiples of alpha.
-/
lemma Phi_moments_zero {φ : ℝ → ℝ} {k₀ α : ℝ} (hα : α > 0)
    (hcont : ContinuousOn φ (Set.Ici 0))
    (hPhi_lim : Filter.Tendsto (Phi φ k₀) Filter.atTop (nhds 0))
    (hzeros : ∀ (n : ℕ),
        let k := k₀ + (n : ℝ) * α
        ∃ (Jn : ℝ), Filter.Tendsto (λ (T : ℝ) ↦ ∫ x in 0..T, Real.exp (-k * x) * φ x) Filter.atTop (nhds Jn) ∧ Jn = 0) :
    ∀ (n : ℕ), n ≥ 1 → ∫ x in Set.Ioi 0, Real.exp (-(n * α) * x) * Phi φ k₀ x = 0 := by
  simp +zetaDelta at *;
  intro n hn
  have h_laplace_zero : Filter.Tendsto (λ T ↦ ∫ x in (0 : ℝ)..T, Real.exp (-(k₀ + n * α) * x) * φ x) Filter.atTop (nhds 0) := by
    convert hzeros n using 3 ; ring;
  have := h_laplace_zero.sub ( integral_parts_lemma ( show 0 < ( n : ℝ ) * α by positivity ) hcont hPhi_lim ) ; aesop;

/-
The moments of H are all zero.
-/
lemma H_moments_zero {φ : ℝ → ℝ} {k₀ α : ℝ} (hα : α > 0)
    (hcont : ContinuousOn φ (Set.Ici 0))
    (hPhi_lim : Filter.Tendsto (Phi φ k₀) Filter.atTop (nhds 0))
    (hzeros : ∀ (n : ℕ),
        let k := k₀ + (n : ℝ) * α
        ∃ (Jn : ℝ), Filter.Tendsto (λ (T : ℝ) ↦ ∫ x in 0..T, Real.exp (-k * x) * φ x) Filter.atTop (nhds Jn) ∧ Jn = 0) :
    ∀ (m : ℕ), ∫ u in 0..1, u ^ m * H φ k₀ α u = 0 := by
  -- Perform the substitution $u = e^{-\alpha x}$, which implies $x = -\frac{1}{\alpha} \ln u$ and $dx = -\frac{1}{\alpha u} du$.
  have h_subst : ∀ n : ℕ, n ≥ 1 → ∫ x in (Set.Ioi 0), Real.exp (-(n * α) * x) * Phi φ k₀ x = (1 / α) * ∫ u in (Set.Ioo 0 1), u ^ (n - 1) * H φ k₀ α u := by
    intro n hn
    have h_subst : ∫ x in (Set.Ioi 0), Real.exp (-(n * α) * x) * Phi φ k₀ x = ∫ u in (Set.image (fun x => Real.exp (-α * x)) (Set.Ioi 0)), (u ^ (n - 1)) * (Phi φ k₀ (-Real.log u / α)) * (1 / α) := by
      rw [ MeasureTheory.integral_image_eq_integral_abs_deriv_smul ] <;> norm_num;
      any_goals intro x hx; exact HasDerivAt.hasDerivWithinAt ( by simpa using HasDerivAt.exp ( HasDerivAt.neg ( HasDerivAt.const_mul α ( hasDerivAt_id x ) ) ) );
      · refine' MeasureTheory.setIntegral_congr_fun measurableSet_Ioi fun x hx => _ ; rw [ abs_of_nonpos ] <;> norm_num [ mul_assoc, mul_comm α, hα.ne' ] ; ring;
        · rw [ ← Real.exp_nat_mul ] ; cases n <;> norm_num [ pow_succ, mul_assoc, mul_comm, mul_left_comm ] at * ; ring;
          exact Or.inl ( by rw [ ← Real.exp_add ] ; ring );
        · positivity;
      · exact fun x hx y hy hxy => by simpa [ hα.ne' ] using hxy;
    rw [ h_subst, show ( fun x => Real.exp ( -α * x ) ) '' Set.Ioi 0 = Set.Ioo 0 1 from ?_ ];
    · rw [ ← MeasureTheory.integral_const_mul ];
      exact MeasureTheory.setIntegral_congr_fun measurableSet_Ioo fun x hx => by rw [ show H φ k₀ α x = Phi φ k₀ ( -Real.log x / α ) by rw [ H ] ; aesop ] ; ring;
    · ext;
      field_simp;
      exact ⟨ fun ⟨ x, hx, hx' ⟩ => ⟨ hx'.symm ▸ Real.exp_pos _, hx'.symm ▸ Real.exp_lt_one_iff.mpr ( neg_lt_zero.mpr ( mul_pos hα hx ) ) ⟩, fun hx => ⟨ -Real.log ‹_› / α, by exact div_pos ( neg_pos.mpr ( Real.log_neg hx.1 hx.2 ) ) hα, by simp +decide [ mul_div_cancel₀ _ hα.ne', Real.exp_log hx.1 ] ⟩ ⟩;
  -- Since $\alpha > 0$, we can divide both sides of the equation by $\alpha$.
  have h_div : ∀ n : ℕ, n ≥ 1 → ∫ u in (Set.Ioo 0 1), u ^ (n - 1) * H φ k₀ α u = 0 := by
    intros n hn
    have := h_subst n hn
    have := this ▸ Phi_moments_zero hα hcont hPhi_lim hzeros n hn
    field_simp at this;
    linarith;
  intro m; specialize h_div ( m + 1 ) ; simp_all +decide [ intervalIntegral.integral_of_le zero_le_one, MeasureTheory.integral_Ioc_eq_integral_Ioo ] ;

/-
H is zero on [0, 1].
-/
lemma H_zero_on_Icc {φ : ℝ → ℝ} {k₀ α : ℝ} (hα : α > 0)
    (hcont : ContinuousOn φ (Set.Ici 0))
    (hPhi_lim : Filter.Tendsto (Phi φ k₀) Filter.atTop (nhds 0))
    (hzeros : ∀ (n : ℕ),
        let k := k₀ + (n : ℝ) * α
        ∃ (Jn : ℝ), Filter.Tendsto (λ (T : ℝ) ↦ ∫ x in 0..T, Real.exp (-k * x) * φ x) Filter.atTop (nhds Jn) ∧ Jn = 0) :
    ∀ u ∈ Set.Icc 0 1, H φ k₀ α u = 0 := by
  exact fun u hu ↦ continuous_zero_moments ( H_continuous hα hcont hPhi_lim ) ( H_moments_zero hα hcont hPhi_lim hzeros ) u hu

/-
If the Laplace transform of a continuous function vanishes on an arithmetic progression, the function is zero.
-/
theorem problem_142 {φ : ℝ → ℝ} {k₀ α : ℝ} (hα : α > 0)
    (hcont : ContinuousOn φ (Set.Ici 0))
    (hconv : ∃ (J0 : ℝ), Filter.Tendsto (λ (T : ℝ) ↦ ∫ x in 0..T, Real.exp (-k₀ * x) * φ x) Filter.atTop (nhds J0))
    (hzeros : ∀ (n : ℕ),
        let k := k₀ + (n : ℝ) * α
        ∃ (Jn : ℝ), Filter.Tendsto (λ (T : ℝ) ↦ ∫ x in 0..T, Real.exp (-k * x) * φ x) Filter.atTop (nhds Jn) ∧ Jn = 0) :
    ∀ x ≥ 0, φ x = 0 := by
  intro x hx_nonneg
  by_contra h_nonzero
  have h_Phi_zero : ∀ x ≥ 0, ∫ t in (0 : ℝ)..x, Real.exp (-k₀ * t) * φ t = 0 := by
    -- Next, show that `H` is zero on `[0, 1]` using `H_zero_on_Icc`.
    have h_H_zero_on_Icc : ∀ u ∈ Set.Icc 0 1, H φ k₀ α u = 0 := by
      apply H_zero_on_Icc hα hcont (Phi_tendsto_zero hzeros) hzeros;
    -- This implies `Phi(x) = 0` for all `x > 0`.
    have h_Phi_zero_pos : ∀ x > 0, ∫ t in (0 : ℝ)..x, Real.exp (-k₀ * t) * φ t = 0 := by
      intro x hx_pos
      specialize h_H_zero_on_Icc (Real.exp (-α * x)) ⟨by
      positivity, by
        exact Real.exp_le_one_iff.mpr ( by nlinarith )⟩
      generalize_proofs at *;
      unfold H at h_H_zero_on_Icc;
      unfold Phi at *; norm_num [ hα.ne', hx_pos.ne' ] at *;
      simpa [ mul_div_cancel_left₀ _ hα.ne' ] using h_H_zero_on_Icc ( Real.exp_pos _ ) ( mul_pos hα hx_pos );
    exact fun x hx => if hx' : x = 0 then by norm_num [ hx' ] else h_Phi_zero_pos x ( lt_of_le_of_ne hx ( Ne.symm hx' ) )
  have h_Phi_zero_deriv : ∀ x > 0, deriv (fun x => ∫ t in (0 : ℝ)..x, Real.exp (-k₀ * t) * φ t) x = Real.exp (-k₀ * x) * φ x := by
    intro x hx_pos
    have h_ftc : HasDerivAt (fun x => ∫ t in (0 : ℝ)..x, Real.exp (-k₀ * t) * φ t) (Real.exp (-k₀ * x) * φ x) x := by
      apply_rules [ intervalIntegral.integral_hasDerivAt_right ];
      · apply_rules [ ContinuousOn.intervalIntegrable ];
        exact ContinuousOn.mul ( ContinuousOn.rexp ( continuousOn_const.mul continuousOn_id ) ) ( hcont.mono ( by rw [ Set.uIcc_of_le hx_pos.le ] ; exact Set.Icc_subset_Ici_self ) );
      · exact ⟨ Set.Ioi 0, Ioi_mem_nhds hx_pos, ContinuousOn.aestronglyMeasurable ( by exact ContinuousOn.mul ( ContinuousOn.rexp ( continuousOn_const.mul continuousOn_id ) ) ( hcont.mono ( Set.Ioi_subset_Ici_self ) ) ) measurableSet_Ioi ⟩;
      · exact ContinuousAt.mul ( ContinuousAt.rexp ( continuousAt_const.mul continuousAt_id ) ) ( hcont.continuousAt ( Ici_mem_nhds hx_pos ) );
    exact h_ftc.deriv
  have h_Phi_zero_deriv_zero : ∀ x > 0, Real.exp (-k₀ * x) * φ x = 0 := by
    exact fun x x_pos => h_Phi_zero_deriv x x_pos ▸ by rw [ Filter.EventuallyEq.deriv_eq ( Filter.eventuallyEq_of_mem ( Ioi_mem_nhds x_pos ) fun y hy => h_Phi_zero y hy.out.le ) ] ; norm_num;
  have h_Phi_zero_deriv_zero_all : ∀ x > 0, φ x = 0 := by
    exact fun x hx => eq_zero_of_ne_zero_of_mul_left_eq_zero ( ne_of_gt ( Real.exp_pos _ ) ) ( h_Phi_zero_deriv_zero x hx )
  have h_Phi_zero_deriv_zero_all_zero : φ 0 = 0 := by
    have h_Phi_zero_deriv_zero_all_zero : Filter.Tendsto φ (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
      exact Filter.Tendsto.congr' ( Filter.eventuallyEq_of_mem self_mem_nhdsWithin fun x hx => by rw [ h_Phi_zero_deriv_zero_all x hx ] ) tendsto_const_nhds;
    have := hcont 0 ( by norm_num );
    exact tendsto_nhds_unique ( this.mono_left <| nhdsWithin_mono _ <| Set.Ioi_subset_Ici_self ) h_Phi_zero_deriv_zero_all_zero
  exact h_nonzero (by
  cases lt_or_eq_of_le hx_nonneg <;> aesop)