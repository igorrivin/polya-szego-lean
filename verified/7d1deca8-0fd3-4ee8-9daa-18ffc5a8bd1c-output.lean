/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7d1deca8-0fd3-4ee8-9daa-18ffc5a8bd1c

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open MeasureTheory MeasureTheory.Measure Real

#check RatFunc ℝ
#check RatFunc.eval
#check volume
#check integral

def f : ℝ × ℝ × ℝ → ℝ := λ (x, y, z) => x * y + y * z + z * x

theorem problem_119a_part1 :
    ¬ ∃ (φ : ℝ × ℝ → ℝ) (ψ : ℝ × ℝ → ℝ) (χ : ℝ × ℝ → ℝ),
      ContDiff ℝ ⊤ φ ∧ ContDiff ℝ ⊤ ψ ∧ ContDiff ℝ ⊤ χ ∧
      ∀ (x y z : ℝ), f (x, y, z) = φ (ψ (χ (x, y), z), z) := by
  -- Assume for contradiction that $x*y + y*z + z*x$ can be written as $\varphi(\psi(\chi(x,y),z),z)$ for some smooth functions $\varphi$, $\psi$, and $\chi$.
  by_contra h_contra
  obtain ⟨φ, ψ, χ, hφ, hψ, hχ, h_eq⟩ := h_contra

  -- Consider the partial derivatives of $f$ with respect to $x$ and $y$.
  have h_partials : ∀ x y z, deriv (fun x => f (x, y, z)) x = deriv (fun x => φ (ψ (χ (x, y), z), z)) x ∧ deriv (fun y => f (x, y, z)) y = deriv (fun y => φ (ψ (χ (x, y), z), z)) y := by
    aesop;
  -- Let's denote $\chi(x,y) = g(x,y)$ and $\psi(g(x,y),z) = h(x,y,z)$. Then $f(x,y,z) = \varphi(h(x,y,z),z)$.
  set g : ℝ × ℝ → ℝ := fun p => χ p
  set h : ℝ × ℝ × ℝ → ℝ := fun p => ψ (g (p.1, p.2.1), p.2.2);
  -- Then $f(x,y,z) = \varphi(h(x,y,z),z)$ implies that $\frac{\partial f}{\partial x} = \frac{\partial \varphi}{\partial h} \cdot \frac{\partial h}{\partial x}$ and $\frac{\partial f}{\partial y} = \frac{\partial \varphi}{\partial h} \cdot \frac{\partial h}{\partial y}$.
  have h_partial_derivs : ∀ x y z, deriv (fun x => f (x, y, z)) x = deriv (fun h => φ (h, z)) (h (x, y, z)) * deriv (fun x => h (x, y, z)) x ∧ deriv (fun y => f (x, y, z)) y = deriv (fun h => φ (h, z)) (h (x, y, z)) * deriv (fun y => h (x, y, z)) y := by
    intro x y z;
    rw [ h_partials x y z |>.1, h_partials x y z |>.2 ];
    constructor <;> erw [ deriv ];
    · rw [ show ( fun x => φ ( ψ ( χ ( x, y ), z ), z ) ) = ( fun h => φ ( h, z ) ) ∘ ( fun x => ψ ( χ ( x, y ), z ) ) by ext; rfl, fderiv_comp ] <;> norm_num [ hφ.contDiffAt.differentiableAt, hψ.contDiffAt.differentiableAt, hχ.contDiffAt.differentiableAt ];
      · ring!;
      · exact DifferentiableAt.comp _ ( hφ.contDiffAt.differentiableAt le_top ) ( differentiableAt_id.prodMk ( differentiableAt_const _ ) );
      · exact DifferentiableAt.comp x ( hψ.contDiffAt.differentiableAt le_top ) ( DifferentiableAt.prodMk ( hχ.contDiffAt.differentiableAt le_top |> DifferentiableAt.comp _ <| differentiableAt_id.prodMk <| differentiableAt_const _ ) <| differentiableAt_const _ );
    · convert deriv_comp y ( show DifferentiableAt ℝ ( fun h => φ ( h, z ) ) ( ψ ( χ ( x, y ), z ) ) from DifferentiableAt.comp _ ( hφ.contDiffAt.differentiableAt le_top ) ( differentiableAt_id.prodMk ( differentiableAt_const _ ) ) ) ( show DifferentiableAt ℝ ( fun y => ψ ( χ ( x, y ), z ) ) y from DifferentiableAt.comp _ ( hψ.contDiffAt.differentiableAt le_top ) ( DifferentiableAt.prodMk ( hχ.contDiffAt.differentiableAt le_top |> DifferentiableAt.comp _ <| differentiableAt_const _ |> DifferentiableAt.prodMk <| differentiableAt_id ) <| differentiableAt_const _ ) ) using 1;
  -- Then $\frac{\partial f}{\partial x} \cdot \frac{\partial^2 f}{\partial y \partial z} = \frac{\partial f}{\partial y} \cdot \frac{\partial^2 f}{\partial x \partial z}$.
  have h_cross_partial_derivs : ∀ x y z, deriv (fun x => f (x, y, z)) x * deriv (fun z => deriv (fun y => f (x, y, z)) y) z = deriv (fun y => f (x, y, z)) y * deriv (fun z => deriv (fun x => f (x, y, z)) x) z := by
    intros x y z
    rw [h_partial_derivs x y z |>.left, h_partial_derivs x y z |>.right];
    -- By definition of $h$, we know that $\frac{\partial h}{\partial x} = \frac{\partial \psi}{\partial g} \cdot \frac{\partial g}{\partial x}$ and $\frac{\partial h}{\partial y} = \frac{\partial \psi}{\partial g} \cdot \frac{\partial g}{\partial y}$.
    have h_partial_derivs_h : ∀ x y z, deriv (fun x => h (x, y, z)) x = deriv (fun g => ψ (g, z)) (g (x, y)) * deriv (fun x => g (x, y)) x ∧ deriv (fun y => h (x, y, z)) y = deriv (fun g => ψ (g, z)) (g (x, y)) * deriv (fun y => g (x, y)) y := by
      intro x y z; exact ⟨by
      convert deriv_comp x ( show DifferentiableAt ℝ ( fun g => ψ ( g, z ) ) ( g ( x, y ) ) from DifferentiableAt.comp _ ( hψ.contDiffAt.differentiableAt ( by norm_num ) ) ( differentiableAt_id.prodMk ( differentiableAt_const _ ) ) ) ( show DifferentiableAt ℝ ( fun x => g ( x, y ) ) x from DifferentiableAt.comp _ ( hχ.contDiffAt.differentiableAt ( by norm_num ) ) ( differentiableAt_id.prodMk ( differentiableAt_const _ ) ) ) using 1, by
        convert deriv_comp y ( show DifferentiableAt ℝ ( fun g => ψ ( g, z ) ) ( g ( x, y ) ) from DifferentiableAt.comp _ ( hψ.contDiffAt.differentiableAt le_top ) ( differentiableAt_id.prodMk ( differentiableAt_const _ ) ) ) ( show DifferentiableAt ℝ ( fun y => g ( x, y ) ) y from DifferentiableAt.comp _ ( hχ.contDiffAt.differentiableAt le_top ) ( differentiableAt_const _ |> DifferentiableAt.prodMk <| differentiableAt_id ) ) using 1⟩;
    simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
    field_simp;
    -- Since the derivative of $g(x, y)$ with respect to $y$ is a constant with respect to $z$, we can factor it out of the derivative.
    have h_const : deriv (fun z => deriv (fun h => φ (h, z)) (h (x, y, z)) * deriv (fun g => ψ (g, z)) (g (x, y)) * deriv (fun y => g (x, y)) y) z = deriv (fun y => g (x, y)) y * deriv (fun z => deriv (fun h => φ (h, z)) (h (x, y, z)) * deriv (fun g => ψ (g, z)) (g (x, y))) z := by
      rw [ deriv_mul_const ] ; ring;
      apply_rules [ ContDiff.differentiable ];
      apply_rules [ ContDiff.mul, ContDiff.fderiv_apply ];
      any_goals exact le_top;
      any_goals apply_rules [ ContDiff.fst, ContDiff.snd, contDiff_const, contDiff_id ];
      · fun_prop (disch := norm_num);
      · exact hψ.comp ( ContDiff.prodMk ( hχ.comp ( contDiff_const.prodMk contDiff_const ) ) contDiff_id );
      · fun_prop (disch := norm_num);
    aesop;
  unfold f at h_cross_partial_derivs; norm_num at h_cross_partial_derivs; specialize h_cross_partial_derivs 1 2 3; norm_num at h_cross_partial_derivs;
  norm_num [ add_comm, mul_comm ] at h_cross_partial_derivs;
  -- Compute the derivative of the function inside the derivative.
  have h_inner_deriv : ∀ z : ℝ, deriv (fun x => z * x + (z * 2 + x * 2)) 1 = z + 2 := by
    -- The derivative of $z * x + (z * 2 + x * 2)$ with respect to $x$ is $z + 2$.
    intros z
    simp [mul_comm z, add_assoc, add_comm, add_left_comm];
  norm_num [ h_inner_deriv ] at h_cross_partial_derivs

#check RatFunc.C
#check RatFunc.X
#check RatFunc.eval

noncomputable def evalReal (R : RatFunc ℝ) (x : ℝ) : ℝ :=
  RatFunc.eval (RingHom.id ℝ) x R

def PreservesIntegrals (R : RatFunc ℝ) : Prop :=
  ∀ f : ℝ → ℝ, Integrable f → Integrable (fun x => f (evalReal R x)) ∧ ∫ x, f (evalReal R x) = ∫ x, f x

def IsSpecialForm (R : RatFunc ℝ) : Prop :=
  ∃ (ε : ℝ) (α : ℝ) (n : ℕ) (p : Fin n → ℝ) (a : Fin n → ℝ),
    (ε = 1 ∨ ε = -1) ∧
    (∀ i, p i > 0) ∧
    R = RatFunc.C ε * (RatFunc.X - RatFunc.C α - Finset.sum Finset.univ (fun i => RatFunc.C (p i) / (RatFunc.X - RatFunc.C (a i))))

open BigOperators

def R_special {n : ℕ} (ε : ℝ) (α : ℝ) (p : Fin n → ℝ) (a : Fin n → ℝ) (x : ℝ) : ℝ :=
  ε * (x - α - ∑ i, p i / (x - a i))

/-
The derivative of Q_poly is as stated.
-/
open Polynomial BigOperators

variable {n : ℕ}

def P_poly (a : Fin n → ℝ) : ℝ[X] := ∏ i, (X - C (a i))

def Q_poly (α : ℝ) (p : Fin n → ℝ) (a : Fin n → ℝ) (y : ℝ) : ℝ[X] :=
  (X - C α - C y) * P_poly a - ∑ i, C (p i) * ∏ j ∈ Finset.univ.erase i, (X - C (a j))

lemma Q_poly_deriv_eq (α : ℝ) (p : Fin n → ℝ) (a : Fin n → ℝ) (y : ℝ) :
  derivative (Q_poly α p a y) = P_poly a + (X - C α - C y) * derivative (P_poly a) -
  derivative (∑ i, C (p i) * ∏ j ∈ Finset.univ.erase i, (X - C (a j))) := by
    -- By definition of $Q_poly$, we can write it as the product of $P_poly$ and $(X - C α - C y)$ minus the sum of $C (p i) * ∏ j ∈ Finset.erase Finset.univ i, (X - C (a j))$.
    have hQ_poly : Q_poly α p a y = (Polynomial.X - Polynomial.C α - Polynomial.C y) * P_poly a - ∑ i, Polynomial.C (p i) * ∏ j ∈ Finset.erase Finset.univ i, (Polynomial.X - Polynomial.C (a j)) := by
      exact?;
    aesop

/-
If P and Q are monic polynomials with deg(Q) = deg(P) + 1 and Q has distinct roots, then sum (P(x)/Q'(x)) over roots of Q is 1.
-/
lemma sum_P_div_Q_deriv_eq_one {n : ℕ} (P Q : ℝ[X])
  (hP : P.Monic) (hQ : Q.Monic)
  (hdegP : P.degree = n) (hdegQ : Q.degree = n + 1)
  (hroots : (Q.roots.toFinset).card = n + 1) :
  ∑ x ∈ Q.roots.toFinset, P.eval x / (derivative Q).eval x = 1 := by
    -- Since Q has n+1 distinct roots (implied by card roots = n+1 and degree n+1), Q(x) = product (x - x_i).
    have hQ_factor : Q = Finset.prod Q.roots.toFinset (fun x => Polynomial.X - Polynomial.C x) := by
      convert Polynomial.eq_prod_roots_of_monic_of_splits_id hQ _ using 2;
      · rw [ ← Multiset.toFinset_eq ];
        rfl;
        rw [ Multiset.nodup_iff_ne_cons_cons ];
        intro a t h; have := Polynomial.card_roots' Q; simp_all +decide [ Polynomial.natDegree_eq_of_degree_eq_some hdegQ ] ;
        linarith [ Multiset.toFinset_card_le t, Finset.card_insert_le a t.toFinset ];
      · rw [ Polynomial.splits_iff_card_roots ];
        exact le_antisymm ( Polynomial.card_roots' Q ) ( by simpa [ Polynomial.natDegree_eq_of_degree_eq_some hdegQ, hroots ] using Multiset.toFinset_card_le Q.roots );
    -- By partial fraction decomposition, P(x)/Q(x) = sum (c_i / (x - x_i)) where c_i = P(x_i)/Q'(x_i).
    have h_partial_fractions : P = Finset.sum Q.roots.toFinset (fun x => Polynomial.C (P.eval x / (Polynomial.derivative Q).eval x) * (Finset.prod (Q.roots.toFinset.erase x) (fun y => Polynomial.X - Polynomial.C y))) := by
      refine' Polynomial.eq_of_degree_sub_lt_of_eval_finset_eq _ _ _;
      exact Q.roots.toFinset;
      · refine' lt_of_le_of_lt ( Polynomial.degree_sub_le _ _ ) _ ; norm_num [ hdegP, hdegQ, hroots ];
        refine' ⟨ WithBot.coe_lt_coe.mpr ( Nat.lt_succ_self _ ), lt_of_le_of_lt ( Polynomial.degree_sum_le _ _ ) _ ⟩;
        erw [ Finset.sup_lt_iff ] ; norm_num [ Polynomial.degree_prod, Polynomial.degree_X_sub_C ];
        · intro b _ hb; refine' lt_of_le_of_lt ( add_le_add ( Polynomial.degree_C_le ) le_rfl ) _ ; norm_cast ; simp +decide [ hroots, Finset.card_erase_of_mem ( show b ∈ Q.roots.toFinset from by simpa [ hb ] ) ] ;
        · exact WithBot.bot_lt_coe _;
      · intro x hx; rw [ Polynomial.eval_finset_sum, Finset.sum_eq_single x ] <;> norm_num [ hx ];
        · rw [ show Polynomial.derivative Q = Polynomial.derivative ( ∏ x ∈ Q.roots.toFinset, ( Polynomial.X - Polynomial.C x ) ) by simpa only [ ← hQ_factor ] ] ; norm_num [ Polynomial.eval_prod, Finset.prod_eq_prod_diff_singleton_mul hx ] ; ring;
          rw [ Finset.sdiff_singleton_eq_erase, mul_assoc, inv_mul_cancel₀ ( Finset.prod_ne_zero_iff.mpr fun y hy => sub_ne_zero_of_ne <| by rintro rfl; exact Finset.notMem_erase _ _ hy ), mul_one ];
        · intro y hy₁ hy₂ hy₃; rw [ Polynomial.eval_prod ] ; simp +decide [ Finset.prod_eq_zero_iff, sub_eq_zero, hy₃ ] ;
          exact Or.inr ⟨ Ne.symm hy₃, hy₁, by simpa using Polynomial.isRoot_of_mem_roots ( Multiset.mem_toFinset.mp hx ) ⟩;
    replace h_partial_fractions := congr_arg ( fun q => Polynomial.coeff q ( n : ℕ ) ) h_partial_fractions ; simp +decide [ Polynomial.coeff_monomial, Polynomial.degree_prod, Polynomial.degree_X_sub_C, hP, hQ, hdegP, hdegQ ] at h_partial_fractions ⊢;
    -- The coefficient of $x^n$ in $\prod_{y \in Q.roots.toFinset.erase x} (X - C y)$ is $1$.
    have h_coeff_prod : ∀ x ∈ Q.roots.toFinset, Polynomial.coeff (Finset.prod (Q.roots.toFinset.erase x) (fun y => Polynomial.X - Polynomial.C y)) n = 1 := by
      intro x hx
      have h_coeff_prod : Polynomial.coeff (Finset.prod (Q.roots.toFinset.erase x) (fun y => Polynomial.X - Polynomial.C y)) (Finset.card (Q.roots.toFinset.erase x)) = 1 := by
        have h_coeff_prod : Polynomial.leadingCoeff (Finset.prod (Q.roots.toFinset.erase x) (fun y => Polynomial.X - Polynomial.C y)) = 1 := by
          simp +decide [ Polynomial.leadingCoeff_prod ];
        rw [ Polynomial.leadingCoeff, Polynomial.natDegree_prod _ _ fun y hy => Polynomial.X_sub_C_ne_zero _ ] at h_coeff_prod ; simp +decide [ Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] at h_coeff_prod ⊢ ; tauto;
      simpa [ Finset.card_erase_of_mem hx, hroots ] using h_coeff_prod;
    rw [ Polynomial.Monic.def, Polynomial.leadingCoeff, Polynomial.natDegree_eq_of_degree_eq_some hdegP ] at hP ; simp +decide [ hP ] at h_partial_fractions ⊢ ; rw [ Finset.sum_congr rfl fun x hx => by rw [ h_coeff_prod x hx ] ] at h_partial_fractions ; simp +decide [ hP ] at h_partial_fractions ⊢ ; linarith;