/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b75c716e-1aab-413f-b18e-57110fa37a68
-/

/-
We formalized and proved Polya-Szego Problem 106.
The theorem `problem_106_feier_integral_decomposition` states that for a continuous function f on [0, 2π] and n > 0,
the integral ∫₀²π f(x)|sin n x| dx can be decomposed into a sum of terms involving intermediate values of f.
This confirms the mathematical statement provided in the problem description.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Polya-Szego Problem 106: For a continuous function f on [0, 2π] and any positive integer n, the integral ∫₀²π f(x)|sin n x| dx can be expressed as a sum where each term involves an intermediate value f_{νn} of f on subintervals [(ν-1)(2π/n), ν(2π/n)], multiplied by the integral of |sin n x| over that subinterval.
-/
theorem problem_106_feier_integral_decomposition (f : ℝ → ℝ) (hf : ContinuousOn f (Set.Icc (0 : ℝ) (2 * Real.pi)))
    (n : ℕ) (hn : n > 0) :
    ∃ (f_val : ℕ → ℝ), ∀ (ν : ℕ), ν ∈ Finset.Icc 1 n →
    let a := (ν - 1 : ℝ) * (2 * Real.pi) / n
    let b := (ν : ℝ) * (2 * Real.pi) / n
    f_val ν ∈ Set.Icc (sInf (f '' Set.Icc a b)) (sSup (f '' Set.Icc a b)) ∧
    ∫ x in (0:ℝ)..(2 * Real.pi), f x * |Real.sin (n * x)| =
      ∑ ν ∈ Finset.Icc 1 n,
        f_val ν * ∫ x in a..b, |Real.sin (n * x)| := by
  -- By the properties of integrals, we can rewrite the left-hand side as a sum of integrals over subintervals.
  have h_sum : ∫ x in (0)..2 * Real.pi, f x * |Real.sin (n * x)| = ∑ ν ∈ Finset.Icc 1 n, ∫ x in (((ν - 1) * (2 * Real.pi)) / n)..((ν * (2 * Real.pi)) / n), f x * |Real.sin (n * x)| := by
    have h_split : ∀ m : ℕ, m ≤ n → ∫ x in (0 : ℝ)..((m : ℝ) * (2 * Real.pi) / n), f x * |Real.sin (n * x)| = ∑ ν ∈ Finset.Icc 1 m, ∫ x in ((ν - 1 : ℝ) * (2 * Real.pi) / n)..((ν : ℝ) * (2 * Real.pi) / n), f x * |Real.sin (n * x)| := by
      intro m hm; induction' m with m ih <;> norm_num [ Finset.sum_Ioc_succ_top, Nat.Icc_succ_left ] at *;
      rw [ ← ih ( Nat.le_of_succ_le hm ), intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ ContinuousOn.intervalIntegrable ];
      · exact ContinuousOn.mul ( hf.mono ( by rw [ Set.uIcc_of_le ( by positivity ) ] ; exact Set.Icc_subset_Icc le_rfl ( by rw [ div_le_iff₀ ( by positivity ) ] ; nlinarith [ Real.pi_pos, show ( m : ℝ ) + 1 ≤ n by norm_cast ] ) ) ) ( Continuous.continuousOn ( by continuity ) );
      · exact ContinuousOn.mul ( hf.mono ( by rw [ Set.uIcc_of_le ( by gcongr ; linarith ) ] ; exact Set.Icc_subset_Icc ( by positivity ) ( by rw [ div_le_iff₀ ( by positivity ) ] ; nlinarith [ Real.pi_pos, show ( m : ℝ ) + 1 ≤ n by norm_cast ] ) ) ) ( Continuous.continuousOn ( by continuity ) );
    simpa [ mul_div_cancel_left₀, hn.ne' ] using h_split n le_rfl;
  -- Since $| \sin(nx) |$ is non-negative and integrable on each subinterval, by the properties of integrals, there exists some $c_{\nu n}$ in the interval such that
  have h_exists_f_val : ∀ ν ∈ Finset.Icc 1 n, ∃ c_val ∈ Set.Icc (sInf (f '' Set.Icc (((ν - 1) * (2 * Real.pi)) / n) ((ν * (2 * Real.pi)) / n))) (sSup (f '' Set.Icc (((ν - 1) * (2 * Real.pi)) / n) ((ν * (2 * Real.pi)) / n))), ∫ x in (((ν - 1) * (2 * Real.pi)) / n)..((ν * (2 * Real.pi)) / n), f x * |Real.sin (n * x)| = c_val * ∫ x in (((ν - 1) * (2 * Real.pi)) / n)..((ν * (2 * Real.pi)) / n), |Real.sin (n * x)| := by
    -- Applying the definition of the integral to each term in the sum.
    intro ν hν
    have h_int_def : ∫ x in (((ν - 1) * (2 * Real.pi)) / n)..((ν * (2 * Real.pi)) / n), f x * |Real.sin (n * x)| ≥ (∫ x in (((ν - 1) * (2 * Real.pi)) / n)..((ν * (2 * Real.pi)) / n), (sInf (f '' Set.Icc (((ν - 1) * (2 * Real.pi)) / n) ((ν * (2 * Real.pi)) / n))) * |Real.sin (n * x)|) := by
      apply_rules [ intervalIntegral.integral_mono_on ];
      · bound;
      · exact Continuous.intervalIntegrable ( by exact Continuous.mul continuous_const ( Real.continuous_sin.abs.comp ( by continuity ) ) ) _ _;
      · apply_rules [ ContinuousOn.intervalIntegrable ];
        refine' ContinuousOn.mul ( hf.mono _ ) ( Continuous.continuousOn ( by continuity ) );
        exact fun x hx => ⟨ by cases Set.mem_uIcc.mp hx <;> nlinarith [ Real.pi_pos, show ( ν : ℝ ) ≥ 1 by norm_cast; linarith [ Finset.mem_Icc.mp hν ], show ( ν : ℝ ) ≤ n by norm_cast; linarith [ Finset.mem_Icc.mp hν ], mul_div_cancel₀ ( ( ν - 1 : ℝ ) * ( 2 * Real.pi ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ν : ℝ ) * ( 2 * Real.pi ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ], by cases Set.mem_uIcc.mp hx <;> nlinarith [ Real.pi_pos, show ( ν : ℝ ) ≥ 1 by norm_cast; linarith [ Finset.mem_Icc.mp hν ], show ( ν : ℝ ) ≤ n by norm_cast; linarith [ Finset.mem_Icc.mp hν ], mul_div_cancel₀ ( ( ν - 1 : ℝ ) * ( 2 * Real.pi ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ν : ℝ ) * ( 2 * Real.pi ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ⟩;
      · exact fun x hx => mul_le_mul_of_nonneg_right ( csInf_le ( by exact IsCompact.bddBelow ( isCompact_Icc.image_of_continuousOn ( hf.mono ( Set.Icc_subset_Icc ( by exact div_nonneg ( mul_nonneg ( sub_nonneg.mpr <| Nat.one_le_cast.mpr <| Finset.mem_Icc.mp hν |>.1 ) <| by positivity ) <| Nat.cast_nonneg _ ) <| by exact div_le_of_le_mul₀ ( by positivity ) ( by positivity ) <| by nlinarith [ Real.pi_pos, show ( ν : ℝ ) ≤ n by norm_cast; linarith [ Finset.mem_Icc.mp hν |>.2 ] ] ) ) ) ) <| Set.mem_image_of_mem _ hx ) <| abs_nonneg _;
    have h_int_def_upper : ∫ x in (((ν - 1) * (2 * Real.pi)) / n)..((ν * (2 * Real.pi)) / n), f x * |Real.sin (n * x)| ≤ (∫ x in (((ν - 1) * (2 * Real.pi)) / n)..((ν * (2 * Real.pi)) / n), (sSup (f '' Set.Icc (((ν - 1) * (2 * Real.pi)) / n) ((ν * (2 * Real.pi)) / n))) * |Real.sin (n * x)|) := by
      apply_rules [ intervalIntegral.integral_mono_on ];
      · bound;
      · apply_rules [ ContinuousOn.intervalIntegrable ];
        refine' ContinuousOn.mul ( hf.mono _ ) ( Continuous.continuousOn ( Real.continuous_sin.abs.comp ( by continuity ) ) );
        exact fun x hx => ⟨ by cases Set.mem_uIcc.mp hx <;> nlinarith [ Real.pi_pos, show ( ν : ℝ ) ≥ 1 by norm_cast; linarith [ Finset.mem_Icc.mp hν ], show ( ν : ℝ ) ≤ n by norm_cast; linarith [ Finset.mem_Icc.mp hν ], mul_div_cancel₀ ( ( ν - 1 : ℝ ) * ( 2 * Real.pi ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ν : ℝ ) * ( 2 * Real.pi ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ], by cases Set.mem_uIcc.mp hx <;> nlinarith [ Real.pi_pos, show ( ν : ℝ ) ≥ 1 by norm_cast; linarith [ Finset.mem_Icc.mp hν ], show ( ν : ℝ ) ≤ n by norm_cast; linarith [ Finset.mem_Icc.mp hν ], mul_div_cancel₀ ( ( ν - 1 : ℝ ) * ( 2 * Real.pi ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ν : ℝ ) * ( 2 * Real.pi ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ⟩;
      · exact Continuous.intervalIntegrable ( by exact Continuous.mul continuous_const <| Real.continuous_sin.abs.comp <| by continuity ) _ _;
      · exact fun x hx => mul_le_mul_of_nonneg_right ( le_csSup ( IsCompact.bddAbove ( isCompact_Icc.image_of_continuousOn ( hf.mono ( Set.Icc_subset_Icc ( by exact div_nonneg ( mul_nonneg ( sub_nonneg.mpr <| Nat.one_le_cast.mpr <| Finset.mem_Icc.mp hν |>.1 ) <| by positivity ) <| by positivity ) <| by exact div_le_of_le_mul₀ ( by positivity ) ( by positivity ) <| by nlinarith [ Real.pi_pos, show ( ν : ℝ ) ≤ n by norm_cast; linarith [ Finset.mem_Icc.mp hν |>.2 ] ] ) ) ) ) <| Set.mem_image_of_mem _ hx ) <| abs_nonneg _;
    by_cases h : ∫ x in ( ( ν - 1 ) * ( 2 * Real.pi ) / n ).. ( ν * ( 2 * Real.pi ) / n ), |Real.sin ( n * x )| = 0 <;> simp_all +decide [ intervalIntegral.integral_comp_mul_left ];
    · exact ⟨ ⟨ InfSet.sInf ( f '' Set.Icc ( ( ( ν : ℝ ) - 1 ) * ( 2 * Real.pi ) / n ) ( ( ν : ℝ ) * ( 2 * Real.pi ) / n ) ), le_rfl, by exact le_trans ( csInf_le ( by exact IsCompact.bddBelow ( isCompact_Icc.image_of_continuousOn ( hf.mono ( Set.Icc_subset_Icc ( by exact div_nonneg ( mul_nonneg ( sub_nonneg.mpr <| Nat.one_le_cast.mpr hν.1 ) <| by positivity ) <| by positivity ) <| by exact div_le_of_le_mul₀ ( by positivity ) ( by positivity ) <| by nlinarith [ Real.pi_pos, show ( ν : ℝ ) ≤ n by norm_cast; linarith ] ) ) ) ) <| Set.mem_image_of_mem _ <| Set.left_mem_Icc.mpr <| by exact div_le_div_of_nonneg_right ( by nlinarith [ Real.pi_pos, show ( ν : ℝ ) ≥ 1 by norm_cast; linarith ] ) <| by positivity ) <| le_csSup ( by exact IsCompact.bddAbove ( isCompact_Icc.image_of_continuousOn ( hf.mono ( Set.Icc_subset_Icc ( by exact div_nonneg ( mul_nonneg ( sub_nonneg.mpr <| Nat.one_le_cast.mpr hν.1 ) <| by positivity ) <| by positivity ) <| by exact div_le_of_le_mul₀ ( by positivity ) ( by positivity ) <| by nlinarith [ Real.pi_pos, show ( ν : ℝ ) ≤ n by norm_cast; linarith ] ) ) ) ) <| Set.mem_image_of_mem _ <| Set.left_mem_Icc.mpr <| by exact div_le_div_of_nonneg_right ( by nlinarith [ Real.pi_pos, show ( ν : ℝ ) ≥ 1 by norm_cast; linarith ] ) <| by positivity ⟩, by linarith ⟩;
    · refine' ⟨ ( ∫ x in ( ( ν - 1 ) * ( 2 * Real.pi ) / n ).. ( ν * ( 2 * Real.pi ) / n ), f x * |Real.sin ( n * x )| ) / ( ∫ x in ( ( ν - 1 ) * ( 2 * Real.pi ) / n ).. ( ν * ( 2 * Real.pi ) / n ), |Real.sin ( n * x )| ), _, _ ⟩;
      · exact ⟨ by rw [ le_div_iff₀ ( lt_of_le_of_ne ( intervalIntegral.integral_nonneg ( by exact div_le_div_of_nonneg_right ( by nlinarith [ Real.pi_pos, show ( ν : ℝ ) ≥ 1 by norm_cast; linarith ] ) ( Nat.cast_nonneg _ ) ) fun x hx => abs_nonneg _ ) ( Ne.symm h ) ) ] ; linarith, by rw [ div_le_iff₀ ( lt_of_le_of_ne ( intervalIntegral.integral_nonneg ( by exact div_le_div_of_nonneg_right ( by nlinarith [ Real.pi_pos, show ( ν : ℝ ) ≥ 1 by norm_cast; linarith ] ) ( Nat.cast_nonneg _ ) ) fun x hx => abs_nonneg _ ) ( Ne.symm h ) ) ] ; linarith ⟩;
      · rw [ div_mul_cancel₀ _ h ];
  simp +zetaDelta at *;
  choose! f_val hf_val using h_exists_f_val;
  rw [ h_sum, Finset.sum_congr rfl fun i hi => hf_val i ( Finset.mem_Icc.mp hi |>.1 ) ( Finset.mem_Icc.mp hi |>.2 ) |>.2 ];
  -- By the properties of integrals, we can factor out the constant $| \sin(nx) |$ from the integral.
  have h_integral_factor : ∀ ν ∈ Finset.Icc 1 n, ∫ x in (((ν - 1) * (2 * Real.pi)) / n)..((ν * (2 * Real.pi)) / n), |Real.sin (n * x)| = ∫ x in (0)..(2 * Real.pi / n), |Real.sin (n * x)| := by
    intro ν hν; convert intervalIntegral.integral_comp_sub_right _ ( ( ν - 1 ) * ( 2 * Real.pi ) / n ) using 2 <;> ring;
    norm_num [ mul_assoc, mul_comm, mul_left_comm, hn.ne' ];
    norm_num [ mul_assoc, mul_comm Real.pi ];
  rw [ Finset.sum_congr rfl fun i hi => by rw [ h_integral_factor i hi ] ] ; aesop;