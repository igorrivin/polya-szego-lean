/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7a019761-2ac2-410b-8534-27b8cc482bb2
-/

/-
We have formalized and proven Polya-Szego Problem 114.
The main results are:
1. `problem_114_mapping_properties`: The function $w = \frac{2}{i} \arcsin(iz)$ maps the unit disk to a convex domain contained in the strip $-\pi \le \Im w \le \pi$.
2. `problem_114_support_function`: The support function of the image domain coincides with the support function of the point $\pi i$ for $\varphi \in [\pi/4, 3\pi/4]$.

We defined the complex arcsine and arcsinh functions, and proved several properties of them, including their derivatives and relationship to each other. We also analyzed the geometry of the image domain by relating it to the region defined by $|x| \le \text{arcsinh}(\cos y)$.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Complex Set
open scoped ComplexConjugate

/-
Definition of complex arcsine.
-/
noncomputable def Complex.arcsin (z : ℂ) : ℂ := -I * log (I * z + (1 - z ^ 2) ^ (1 / 2 : ℂ))

#check Convex
#check Real.pi
#check Complex.I

#check π
#check sInf

/-
Definitions for Problem 114.
-/
noncomputable def f_114 (z : ℂ) : ℂ := (2 / I) * Complex.arcsin (I * z)
def unitDisk : Set ℂ := {z | ‖z‖ ≤ 1}
def horizontalStrip : Set ℂ := {w | -Real.pi ≤ w.im ∧ w.im ≤ Real.pi}

/-
sin(arcsin(z)) = z for complex numbers.
-/
lemma Complex.sin_arcsin (z : ℂ) : Complex.sin (Complex.arcsin z) = z := by
  rw [ Complex.sin ];
  rw [ Complex.arcsin ] ; ring;
  by_cases h : Complex.I * z + ( 1 - z ^ 2 ) ^ ( 1 / 2 : ℂ ) = 0 <;> simp_all +decide [ Complex.exp_neg, Complex.exp_log ];
  · -- Squaring both sides of the equation $Complex.I * z + (1 - z ^ 2) ^ (1 / 2 : ℂ) = 0$, we get $1 - z ^ 2 = (-Complex.I * z) ^ 2$.
    have h_sq : 1 - z ^ 2 = (-Complex.I * z) ^ 2 := by
      rw [ add_eq_zero_iff_eq_neg ] at h ; aesop;
    norm_num [ Complex.ext_iff, sq ] at * ; nlinarith;
  · field_simp [h]
    ring;
    rw [ ← Complex.cpow_nat_mul ] ; norm_num ; ring

/-
The real part of arcsin(z) is in [-π/2, π/2].
-/
lemma Complex.arcsin_range (z : ℂ) : (Complex.arcsin z).re ∈ Icc (-(Real.pi/2)) (Real.pi/2) := by
  simp +decide [ Complex.arcsin ];
  norm_num [ Complex.log_im ];
  -- Consider the real part of $w = \mathrm{i}z + \sqrt{1 - z^2}$.
  set w : ℂ := Complex.I * z + (1 - z ^ 2) ^ (1 / 2 : ℂ)
  have h_real_part : w.re ≥ 0 := by
    -- Let $u = \sqrt{1 - z^2}$, then $u^2 = 1 - z^2$.
    set u : ℂ := (1 - z ^ 2) ^ (1 / 2 : ℂ)
    have hu : u^2 = 1 - z^2 := by
      rw [ ← Complex.cpow_nat_mul ] ; norm_num;
    norm_num [ Complex.ext_iff, sq ] at *;
    simp +zetaDelta at *;
    by_contra h_contra;
    -- Since $u.re < z.im$, we have $u.re^2 < z.im^2$.
    have h_u_re_sq_lt_z_im_sq : u.re^2 < z.im^2 := by
      by_cases h_re_neg : ((1 - z ^ 2) ^ (1 / 2 : ℂ)).re < 0;
      · norm_num [ Complex.cpow_def ] at *;
        split_ifs at * <;> norm_num [ Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im ] at *;
        exact False.elim <| h_re_neg.not_le <| mul_nonneg ( Real.exp_nonneg _ ) ( Real.cos_nonneg_of_mem_Icc ⟨ by linarith [ Real.pi_pos, Complex.neg_pi_lt_arg ( 1 - z ^ 2 ) ], by linarith [ Real.pi_pos, Complex.arg_le_pi ( 1 - z ^ 2 ) ] ⟩ );
      · nlinarith;
    nlinarith [ sq_nonneg ( z.re - z.im ), sq_nonneg ( z.re + z.im ) ];
  rw [ Complex.arg_le_pi_div_two_iff, Complex.neg_pi_div_two_le_arg_iff ] ; aesop

/-
The preimage of the unit disk under sin, restricted to the strip.
-/
def problem_114_preimage : Set ℂ := {w | w.re ∈ Icc (-(Real.pi/2)) (Real.pi/2) ∧ ‖Complex.sin w‖ ≤ 1}

/-
sqrt(z^2) = z if Re(z) > 0.
-/
lemma Complex.sqrt_sq_eq_self {z : ℂ} (hz : 0 < z.re) : (z ^ 2) ^ (1 / 2 : ℂ) = z := by
  -- Apply the lemma that states if the real part of z is positive, then (z^2)^(1/2) = z.
  have h_arg : -Real.pi / 2 < Complex.arg z ∧ Complex.arg z < Real.pi / 2 := by
    rw [ neg_div, Complex.arg_lt_pi_div_two_iff, Complex.neg_pi_div_two_lt_arg_iff ] ; aesop;
  rw [ ← Complex.cpow_natCast, ← Complex.cpow_mul ] <;> norm_num [ hz.ne' ];
  · rw [ Complex.log_im ] ; linarith;
  · linarith [ Complex.log_im z ]

/-
|sin(x+iy)|^2 = sin^2(x) + sinh^2(y).
-/
lemma Complex.norm_sin_sq (w : ℂ) : ‖Complex.sin w‖ ^ 2 = Real.sin w.re ^ 2 + Real.sinh w.im ^ 2 := by
  norm_num [ Complex.normSq_apply, Complex.sq_norm, Complex.sin, Complex.exp_re, Complex.exp_im ] ; ring;
  norm_num [ Complex.normSq, Complex.sq_norm, Complex.exp_re, Complex.exp_im, Real.sinh_eq ] ; ring;
  norm_num [ Real.sin_sq, Real.cos_sq, mul_assoc, mul_left_comm, ← Real.exp_add ] ; ring

/-
Definition of complex arcsinh and its relation to arcsin.
-/
noncomputable def Complex.arcsinh (z : ℂ) : ℂ := Complex.log (z + (z ^ 2 + 1) ^ (1 / 2 : ℂ))

lemma Complex.arcsin_mul_I (z : ℂ) : Complex.arcsin (I * z) = I * Complex.arcsinh z := by
  unfold Complex.arcsin Complex.arcsinh; ring;
  field_simp;
  rw [ ← Complex.log_inv ] ; norm_num;
  · rw [ inv_eq_of_mul_eq_one_right ] ; ring;
    rw [ ← Complex.cpow_nat_mul ] ; norm_num;
  · rw [ Ne.eq_def, Complex.arg_eq_pi_iff ] ; norm_num;
    intro h;
    -- If $((1 + z^2)^(1/2)).re < z.re$, then squaring both sides gives $((1 + z^2)^(1/2)).re^2 < z.re^2$.
    have h_sq : ((1 + z^2)^(1 / 2 : ℂ)).re^2 < z.re^2 := by
      have h_sq : 0 ≤ ((1 + z^2)^(1 / 2 : ℂ)).re := by
        rw [ Complex.cpow_def ];
        split_ifs <;> norm_num [ Complex.exp_re, Complex.log_re ];
        exact mul_nonneg ( Real.exp_nonneg _ ) ( Real.cos_nonneg_of_mem_Icc ⟨ by linarith [ Real.pi_pos, Complex.neg_pi_lt_arg ( 1 + z ^ 2 ), Complex.arg_le_pi ( 1 + z ^ 2 ), Complex.log_im ( 1 + z ^ 2 ) ], by linarith [ Real.pi_pos, Complex.neg_pi_lt_arg ( 1 + z ^ 2 ), Complex.arg_le_pi ( 1 + z ^ 2 ), Complex.log_im ( 1 + z ^ 2 ) ] ⟩ );
      gcongr;
    -- Since $((1 + z^2)^(1/2))^2 = 1 + z^2$, we have $((1 + z^2)^(1/2)).re^2 - ((1 + z^2)^(1/2)).im^2 = 1 + z.re^2 - z.im^2$.
    have h_sq_eq : ((1 + z^2)^(1 / 2 : ℂ)).re^2 - ((1 + z^2)^(1 / 2 : ℂ)).im^2 = 1 + z.re^2 - z.im^2 := by
      have h_sq_eq : ((1 + z^2)^(1 / 2 : ℂ))^2 = 1 + z^2 := by
        rw [ ← Complex.cpow_nat_mul ] ; norm_num;
      norm_num [ sq, Complex.ext_iff ] at * ; linarith;
    grind

/-
f(z) = 2 * arcsinh(z).
-/
lemma problem_114_f_eq_two_arcsinh (z : ℂ) : f_114 z = 2 * Complex.arcsinh z := by
  -- By definition of $f_114$, we have $f_114 z = (2 / Complex.I) * Complex.arcsin (Complex.I * z)$.
  have h_def : f_114 z = (2 / Complex.I) * Complex.arcsin (Complex.I * z) := by
    exact?;
  -- Substitute h_arcsin into h_def and simplify.
  rw [h_def, Complex.arcsin_mul_I]
  field_simp [Complex.I_ne_zero]

/-
Definition of real arcsinh.
-/
noncomputable def Real.arcsinh (x : ℝ) : ℝ := Real.log (x + Real.sqrt (x ^ 2 + 1))

/-
Real arcsinh is non-negative for non-negative arguments.
-/
lemma Real.arcsinh_nonneg {x : ℝ} (hx : 0 ≤ x) : 0 ≤ Real.arcsinh x := by
  exact Real.log_nonneg ( by nlinarith [ Real.sqrt_nonneg ( x^2 + 1 ), Real.mul_self_sqrt ( by nlinarith : 0 ≤ x^2 + 1 ) ] )

/-
Define g(v) = arcsinh(cos v).
-/
noncomputable def problem_114_g (v : ℝ) : ℝ := Real.arcsinh (Real.cos v)

/-
The derivative of arcsinh(x) is 1/sqrt(x^2+1).
-/
lemma Real.deriv_arcsinh (x : ℝ) : deriv Real.arcsinh x = 1 / Real.sqrt (x ^ 2 + 1) := by
  field_simp;
  rw [ show Real.arcsinh = fun x => Real.log ( x + Real.sqrt ( x^2 + 1 ) ) by ext; rw [ Real.arcsinh ] ];
  norm_num [ DifferentiableAt.mul, DifferentiableAt.sqrt, show x ^ 2 + 1 ≠ 0 by positivity, show x + Real.sqrt ( x ^ 2 + 1 ) ≠ 0 by nlinarith [ Real.sqrt_nonneg ( x ^ 2 + 1 ), Real.sq_sqrt ( show 0 ≤ x ^ 2 + 1 by positivity ) ] ];
  rw [ div_mul_eq_mul_div, div_eq_iff ] <;> nlinarith [ Real.mul_self_sqrt ( show 0 ≤ x ^ 2 + 1 by positivity ), Real.sqrt_nonneg ( x ^ 2 + 1 ), mul_div_cancel₀ ( 2 * x ) ( show ( 2 * Real.sqrt ( x ^ 2 + 1 ) ) ≠ 0 by positivity ) ]

/-
The second derivative of arcsinh(x) is -x/(x^2+1)^(3/2).
-/
lemma Real.deriv2_arcsinh (x : ℝ) : deriv (deriv Real.arcsinh) x = -x / (x ^ 2 + 1) ^ (3 / 2 : ℝ) := by
  rw [ show deriv Real.arcsinh = fun x => 1 / Real.sqrt ( x^2 + 1 ) from funext fun x => by simpa using Real.deriv_arcsinh x ] ; norm_num [ Real.sqrt_eq_rpow, Real.rpow_neg ] ; ring;
  norm_num [ show 1 + x ^ 2 ≠ 0 by positivity, show ( 1 + x ^ 2 ) ^ ( 1 / 2 : ℝ ) ≠ 0 by positivity ] ; ring;
  norm_num [ sq, mul_assoc, ← Real.rpow_add ( by positivity : 0 < 1 + x ^ 2 ) ];
  norm_num [ ← mul_assoc, ← Real.rpow_neg ( by nlinarith : 0 ≤ 1 + x * x ), ← Real.rpow_add ( by nlinarith : 0 < 1 + x * x ) ]

/-
The derivative of g(v) = arcsinh(cos v) is -sin v / sqrt(1 + cos^2 v).
-/
lemma problem_114_g_deriv (v : ℝ) : deriv problem_114_g v = -Real.sin v / Real.sqrt (1 + Real.cos v ^ 2) := by
  field_simp;
  rw [ show problem_114_g = fun x => Real.arcsinh ( Real.cos x ) from rfl, deriv ] ; ring;
  erw [ fderiv_deriv, deriv_comp v ( show DifferentiableAt ℝ Real.arcsinh _ from by exact differentiableAt_of_deriv_ne_zero ( by rw [ show deriv Real.arcsinh = _ from funext fun x => Real.deriv_arcsinh x ] ; positivity ) ) ( Real.differentiableAt_cos ) ] ; norm_num [ Real.differentiableAt_sin, Real.differentiableAt_cos ];
  rw [ show deriv Real.arcsinh = fun x => 1 / Real.sqrt ( x^2 + 1 ) from funext fun x => ?_ ] ; norm_num ; ring;
  · rw [ mul_inv_cancel₀ ( by positivity ), one_mul ];
  · simpa [ add_comm ] using Real.deriv_arcsinh x

/-
The second derivative of g(v) is -2 cos v / (1 + cos^2 v)^(3/2).
-/
lemma problem_114_g_deriv2 (v : ℝ) : deriv (deriv problem_114_g) v = -2 * Real.cos v / (1 + Real.cos v ^ 2) ^ (3 / 2 : ℝ) := by
  rw [ show deriv problem_114_g = _ from funext fun v => problem_114_g_deriv v ];
  norm_num [ Real.sqrt_eq_rpow, Real.differentiableAt_sin, Real.differentiableAt_cos, ne_of_gt ( show 0 < 1 + Real.cos v ^ 2 from by positivity ) ] ; ring;
  norm_num [ Real.differentiableAt_sin, Real.differentiableAt_cos, ne_of_gt ( show 0 < 1 + Real.cos v ^ 2 by positivity ), ne_of_gt ( show 0 < ( 1 + Real.cos v ^ 2 ) ^ ( 1 / 2 : ℝ ) by positivity ) ] ; ring;
  norm_num [ Real.sin_sq, Real.rpow_neg ( by positivity : 0 ≤ 1 + Real.cos v ^ 2 ) ] ; ring;
  rw [ show ( 3 / 2 : ℝ ) = 1 + 1 / 2 by norm_num, Real.rpow_add ( by positivity ), Real.rpow_one ] ; ring;
  -- Combine like terms and simplify the expression.
  field_simp
  ring;
  rw [ ← Real.sqrt_eq_rpow ] ; rw [ Real.sq_sqrt <| by positivity ] ; ring;

/-
The second derivative of g(v) is non-positive on [-π/2, π/2].
-/
lemma problem_114_g_deriv2_nonpos (v : ℝ) (hv : v ∈ Icc (-(Real.pi/2)) (Real.pi/2)) : deriv (deriv problem_114_g) v ≤ 0 := by
  rw [problem_114_g_deriv2]
  apply div_nonpos_of_nonpos_of_nonneg
  · apply mul_nonpos_of_nonpos_of_nonneg
    · norm_num
    · exact Real.cos_nonneg_of_mem_Icc hv
  · apply Real.rpow_nonneg
    apply add_nonneg
    · exact zero_le_one
    · apply sq_nonneg

#check concaveOn_of_deriv2_nonpos

/-
The function g(v) = arcsinh(cos v) is concave on [-π/2, π/2].
-/
lemma Real.arcsinh_cos_concave : ConcaveOn ℝ (Icc (-(Real.pi/2)) (Real.pi/2)) problem_114_g := by
  apply_rules [ concaveOn_of_deriv2_nonpos ];
  · exact convex_Icc _ _;
  · refine' Continuous.continuousOn _;
    exact Continuous.comp ( show Continuous fun x => Real.arcsinh x from by exact ( by exact ( by exact ( by exact ( by exact by rw [ show Real.arcsinh = fun x => Real.log ( x + Real.sqrt ( x^2 + 1 ) ) from funext fun x => rfl ] ; exact Continuous.log ( by continuity ) fun x => by nlinarith [ Real.sqrt_nonneg ( x^2 + 1 ), Real.mul_self_sqrt ( by nlinarith : 0 ≤ x^2 + 1 ) ] ) ) ) ) ) ( Real.continuous_cos );
  · exact DifferentiableOn.congr ( show DifferentiableOn ℝ ( fun x => Real.log ( Real.cos x + Real.sqrt ( Real.cos x ^ 2 + 1 ) ) ) ( interior ( Set.Icc ( - ( Real.pi / 2 ) ) ( Real.pi / 2 ) ) ) from DifferentiableOn.log ( DifferentiableOn.add ( DifferentiableOn.cos ( differentiableOn_id ) ) ( DifferentiableOn.sqrt ( DifferentiableOn.add ( differentiableOn_id.cos.pow 2 ) ( differentiableOn_const _ ) ) fun x hx => by positivity ) ) fun x hx => by nlinarith [ Real.sqrt_nonneg ( Real.cos x ^ 2 + 1 ), Real.mul_self_sqrt ( by positivity : 0 ≤ Real.cos x ^ 2 + 1 ) ] ) fun x hx => rfl;
  · refine' DifferentiableOn.congr _ _;
    exact fun x => -Real.sin x / Real.sqrt ( 1 + Real.cos x ^ 2 );
    · exact DifferentiableOn.div ( DifferentiableOn.neg ( Real.differentiable_sin.differentiableOn ) ) ( DifferentiableOn.sqrt ( by exact DifferentiableOn.add ( differentiableOn_const _ ) ( Real.differentiable_cos.differentiableOn.pow 2 ) ) fun x hx => by positivity ) fun x hx => by positivity;
    · exact?;
  · simp +zetaDelta at *;
    exact fun x hx₁ hx₂ => problem_114_g_deriv2_nonpos x ⟨ hx₁.le, hx₂.le ⟩

/-
The target region is the set of w such that |sinh w| ≤ 1 and |Im w| ≤ π/2.
-/
def target_region : Set ℂ := {w | ‖Complex.sinh w‖ ≤ 1 ∧ |w.im| ≤ Real.pi / 2}

/-
|sinh(x+iy)|^2 = sinh^2(x) + sin^2(y).
-/
lemma Complex.norm_sinh_sq (w : ℂ) : ‖Complex.sinh w‖ ^ 2 = Real.sinh w.re ^ 2 + Real.sin w.im ^ 2 := by
  -- By definition of complex hyperbolic sine, we have $\sinh(w) = \sinh(x) \cos(y) + i \cosh(x) \sin(y)$.
  have h_sinh_def : Complex.sinh w = Complex.sinh w.re * Complex.cos w.im + Complex.I * Complex.cosh w.re * Complex.sin w.im := by
    simp +decide [ Complex.ext_iff, Complex.sinh, Complex.cosh, Complex.exp_re, Complex.exp_im ];
    constructor <;> norm_cast <;> ring;
  norm_num [ h_sinh_def, Complex.normSq, Complex.sq_norm ];
  norm_cast; ring;
  rw [ Real.cos_sq' ] ; rw [ Real.sinh_sq ] ; ring

/-
The target region is equivalent to the region bounded by g(Im w).
-/
lemma target_region_eq_bound : target_region = {w : ℂ | |w.re| ≤ problem_114_g w.im ∧ w.im ∈ Icc (-(Real.pi/2)) (Real.pi/2)} := by
  ext w
  simp [target_region, problem_114_g];
  constructor;
  · intro h;
    have h_abs_re : |w.re| ≤ Real.arcsinh (Real.sqrt (1 - Real.sin w.im ^ 2)) := by
      have h_abs_re : |Real.sinh w.re| ≤ Real.sqrt (1 - Real.sin w.im ^ 2) := by
        have h_abs_re : Real.sinh w.re ^ 2 + Real.sin w.im ^ 2 ≤ 1 := by
          have h_sinh_sq : ‖Complex.sinh w‖ ^ 2 = Real.sinh w.re ^ 2 + Real.sin w.im ^ 2 := by
            exact?;
          exact h_sinh_sq ▸ pow_le_one₀ ( norm_nonneg _ ) h.1;
        exact Real.abs_le_sqrt ( by linarith );
      rw [ Real.arcsinh ];
      rw [ Real.le_log_iff_exp_le ];
      · cases abs_cases w.re <;> simp +decide [ *, Real.sinh_eq ] at *;
        · nlinarith [ abs_le.mp h_abs_re, Real.sqrt_nonneg ( 1 - Real.sin w.im ^ 2 ), Real.sqrt_nonneg ( Real.sqrt ( 1 - Real.sin w.im ^ 2 ) ^ 2 + 1 ), Real.mul_self_sqrt ( show 0 ≤ 1 - Real.sin w.im ^ 2 by nlinarith [ Real.sin_sq_le_one w.im ] ), Real.mul_self_sqrt ( show 0 ≤ Real.sqrt ( 1 - Real.sin w.im ^ 2 ) ^ 2 + 1 by positivity ), Real.exp_pos w.re, Real.exp_neg w.re, mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos w.re ) ) ];
        · nlinarith [ abs_le.mp h_abs_re, Real.sqrt_nonneg ( 1 - Real.sin w.im ^ 2 ), Real.sqrt_nonneg ( Real.sqrt ( 1 - Real.sin w.im ^ 2 ) ^ 2 + 1 ), Real.mul_self_sqrt ( show 0 ≤ 1 - Real.sin w.im ^ 2 by nlinarith [ Real.sin_sq_le_one w.im ] ), Real.mul_self_sqrt ( show 0 ≤ Real.sqrt ( 1 - Real.sin w.im ^ 2 ) ^ 2 + 1 by positivity ), Real.exp_pos w.re, Real.exp_pos ( -w.re ), Real.exp_neg w.re, mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos w.re ) ) ];
      · positivity;
    rw [ ← Real.cos_sq' ] at *;
    rw [ Real.sqrt_sq_eq_abs ] at h_abs_re ; cases abs_cases ( Real.cos w.im ) <;> simp_all +decide [ abs_le ];
    linarith [ Real.cos_nonneg_of_mem_Icc ⟨ by linarith, h.2.2 ⟩ ];
  · rintro ⟨ h₁, h₂, h₃ ⟩;
    -- Since $|w.re| \leq \text{arcsinh}(\cos(w.im))$, we have $\sinh^2(w.re) \leq \sinh^2(\text{arcsinh}(\cos(w.im))) = \cos^2(w.im)$.
    have h_sinh_sq : Real.sinh w.re ^ 2 ≤ Real.cos w.im ^ 2 := by
      have h_sinh_sq : Real.sinh (|w.re|) ≤ Real.cos w.im := by
        rw [ Real.arcsinh ] at h₁;
        rw [ Real.sinh_eq ];
        rw [ Real.le_log_iff_exp_le ] at h₁;
        · nlinarith [ Real.exp_pos |w.re|, Real.exp_neg |w.re|, mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos |w.re| ) ), Real.add_one_le_exp |w.re|, Real.add_one_le_exp ( -|w.re| ), Real.sqrt_nonneg ( Real.cos w.im ^ 2 + 1 ), Real.mul_self_sqrt ( show 0 ≤ Real.cos w.im ^ 2 + 1 by positivity ) ];
        · nlinarith [ Real.sqrt_nonneg ( Real.cos w.im ^ 2 + 1 ), Real.mul_self_sqrt ( show 0 ≤ Real.cos w.im ^ 2 + 1 by positivity ), Real.cos_sq' w.im ];
      cases abs_cases w.re <;> simp +decide [ * ] at *;
      · exact pow_le_pow_left₀ ( Real.sinh_nonneg_iff.mpr ‹_› ) h_sinh_sq 2;
      · nlinarith [ Real.sinh_nonpos_iff.mpr ( by linarith : w.re ≤ 0 ), Real.sinh_neg w.re, Real.sinh_neg ( -w.re ) ];
    norm_num [ Complex.normSq, Complex.norm_def ];
    norm_num [ Complex.sinh, Complex.exp_re, Complex.exp_im ];
    norm_num [ Real.sinh_eq, Real.exp_neg ] at *;
    exact ⟨ by nlinarith [ Real.sin_sq_add_cos_sq w.im, Real.exp_pos w.re, mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos w.re ) ) ], by cases abs_cases w.im <;> linarith ⟩

/-
sinh(arcsinh(x)) = x.
-/
lemma Real.sinh_arcsinh (x : ℝ) : Real.sinh (Real.arcsinh x) = x := by
  unfold Real.arcsinh;
  rw [ Real.sinh_log ];
  · cases le_or_gt x 0 <;> nlinarith [ Real.sqrt_nonneg ( x^2 + 1 ), Real.mul_self_sqrt ( show 0 ≤ x^2 + 1 by positivity ), inv_mul_cancel₀ ( show x + Real.sqrt ( x^2 + 1 ) ≠ 0 by nlinarith [ Real.sqrt_nonneg ( x^2 + 1 ), Real.mul_self_sqrt ( show 0 ≤ x^2 + 1 by positivity ) ] ) ];
  · nlinarith [ Real.sqrt_nonneg ( x^2 + 1 ), Real.sq_sqrt ( by nlinarith : 0 ≤ x^2 + 1 ) ]

/-
If g is concave and non-negative on I, then the region defined by |Re w| ≤ g(Im w) is convex.
-/
lemma convex_of_concave_bound {g : ℝ → ℝ} {I : Set ℝ} (h_concave : ConcaveOn ℝ I g) (h_nonneg : ∀ y ∈ I, 0 ≤ g y) :
    Convex ℝ {w : ℂ | |w.re| ≤ g w.im ∧ w.im ∈ I} := by
      rw [ convex_iff_forall_pos ];
      norm_num +zetaDelta at *;
      intro x hx₁ hx₂ y hy₁ hy₂ a b ha hb hab;
      have := h_concave.2 hx₂ hy₂ ha.le hb.le hab;
      exact ⟨ by simpa using abs_le.mpr ⟨ by norm_num at *; nlinarith [ abs_le.mp hx₁, abs_le.mp hy₁ ], by norm_num at *; nlinarith [ abs_le.mp hx₁, abs_le.mp hy₁ ] ⟩, h_concave.1 hx₂ hy₂ ha.le hb.le hab ⟩

/-
g is non-negative and the target region is convex.
-/
lemma problem_114_g_nonneg (y : ℝ) (hy : y ∈ Icc (-(Real.pi/2)) (Real.pi/2)) : 0 ≤ problem_114_g y := by
  rw [problem_114_g]
  apply Real.arcsinh_nonneg
  exact Real.cos_nonneg_of_mem_Icc hy

lemma target_region_convex : Convex ℝ target_region := by
  rw [target_region_eq_bound]
  apply convex_of_concave_bound
  · exact Real.arcsinh_cos_concave
  · exact problem_114_g_nonneg

/-
The imaginary part of arcsinh(z) is bounded by pi/2.
-/
lemma Complex.arcsinh_range (z : ℂ) : |(Complex.arcsinh z).im| ≤ Real.pi / 2 := by
  -- The imaginary part of arcsinh(z) is bounded by π/2 because the logarithm function's imaginary part is bounded by π.
  have h_im_arcsinh : ∀ z : ℂ, |(Complex.log (z + (z ^ 2 + 1) ^ (1 / 2 : ℂ))).im| ≤ Real.pi / 2 := by
    norm_num [ Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im, Complex.cpow_def ];
    intro z; split_ifs <;> simp_all +decide [ Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im ];
    · norm_num [ sq, Complex.ext_iff ] at * ; nlinarith;
    · field_simp;
      rw [ Real.exp_half, Real.exp_log ( norm_pos_iff.mpr ‹_› ) ];
      -- We'll use that $|z^2 + 1| \geq 0$ and $\cos(\arg(z^2 + 1)/2) \geq 0$ to show the inequality.
      have h_cos_nonneg : 0 ≤ Real.cos ((z^2 + 1).arg / 2) := by
        exact Real.cos_nonneg_of_mem_Icc ⟨ by linarith [ Real.pi_pos, Complex.neg_pi_lt_arg ( z ^ 2 + 1 ) ], by linarith [ Real.pi_pos, Complex.arg_le_pi ( z ^ 2 + 1 ) ] ⟩;
      have h_cos_nonneg : z.re ^ 2 ≤ ‖z ^ 2 + 1‖ * Real.cos ((z ^ 2 + 1).arg / 2) ^ 2 := by
        have h_cos_nonneg : z.re ^ 2 ≤ (‖z ^ 2 + 1‖ + (z ^ 2 + 1).re) / 2 := by
          norm_num [ Complex.normSq, Complex.norm_def, sq ];
          nlinarith [ Real.sqrt_nonneg ( ( z.re * z.re - z.im * z.im + 1 ) * ( z.re * z.re - z.im * z.im + 1 ) + ( z.re * z.im + z.im * z.re ) * ( z.re * z.im + z.im * z.re ) ), Real.mul_self_sqrt ( by nlinarith : 0 ≤ ( z.re * z.re - z.im * z.im + 1 ) * ( z.re * z.re - z.im * z.im + 1 ) + ( z.re * z.im + z.im * z.re ) * ( z.re * z.im + z.im * z.re ) ) ];
        rw [ Real.cos_sq ] ; ring_nf at * ; aesop;
      nlinarith [ show 0 ≤ Real.sqrt ‖z ^ 2 + 1‖ * Real.cos ( ( z ^ 2 + 1 |> Complex.arg ) / 2 ) by positivity, Real.mul_self_sqrt ( show 0 ≤ ‖z ^ 2 + 1‖ by positivity ) ];
  exact h_im_arcsinh z

#check Real.sinh_le_sinh

/-
Real arcsinh is strictly monotonic.
-/
lemma Real.strictMono_arcsinh : StrictMono Real.arcsinh := by
  -- The derivative of $\text{arcsinh}(x)$ is $\frac{1}{\sqrt{x^2 + 1}}$, which is always positive.
  have h_arcsinh_deriv_pos : ∀ x : ℝ, deriv Real.arcsinh x > 0 := by
    intro x; rw [ Real.deriv_arcsinh ] ; positivity;
  exact strictMono_of_deriv_pos h_arcsinh_deriv_pos

/-
Continuity and differentiability of real arcsinh.
-/
lemma Real.continuous_arcsinh : Continuous Real.arcsinh := by
  exact Continuous.log ( by continuity ) fun x => by nlinarith [ Real.sqrt_nonneg ( x^2 + 1 ), Real.mul_self_sqrt ( by nlinarith : 0 ≤ x^2 + 1 ) ] ;

lemma Real.differentiableAt_arcsinh (x : ℝ) : DifferentiableAt ℝ Real.arcsinh x := by
  exact DifferentiableAt.log ( differentiableAt_id.add ( DifferentiableAt.sqrt ( differentiableAt_id.pow 2 |> DifferentiableAt.add <| differentiableAt_const 1 ) <| by positivity ) ) <| by nlinarith [ Real.sqrt_nonneg ( x ^ 2 + 1 ), Real.mul_self_sqrt ( by positivity : 0 ≤ x ^ 2 + 1 ) ] ;

#check Real.abs_sinh

#check Real.abs_sinh

/-
sinh(arcsinh(z)) = z for complex numbers.
-/
lemma Complex.sinh_arcsinh (z : ℂ) : Complex.sinh (Complex.arcsinh z) = z := by
  rw [ show Complex.arcsinh z = Complex.log ( z + ( z^2 + 1 ) ^ ( 1 / 2 : ℂ ) ) from rfl ];
  rw [ Complex.sinh, Complex.exp_log ];
  · rw [ Complex.exp_neg, Complex.exp_log ] <;> norm_num;
    · field_simp;
      rw [ div_eq_iff ] <;> ring;
      · rw [ ← Complex.cpow_nat_mul ] ; norm_num ; ring;
      · by_contra h_contra;
        rw [ add_eq_zero_iff_eq_neg ] at h_contra;
        have := congr_arg ( · ^ 2 ) h_contra ; norm_num [ ← Complex.cpow_nat_mul ] at this;
    · by_contra h_contra
      have h_eq : (z^2 + 1)^(1 / 2 : ℂ) = -z := by
        linear_combination' h_contra;
      have := congr_arg ( · ^ 2 ) h_eq ; norm_num [ ← Complex.cpow_nat_mul ] at this;
  · by_contra h;
    rw [ add_eq_zero_iff_eq_neg ] at h;
    have := congr_arg ( · ^ 2 ) h ; norm_num [ ← Complex.cpow_nat_mul ] at this

#check Complex.smul_re
#check Complex.smul_im
#check Complex.add_re
#check Complex.add_im

/-
The target region is equivalent to the region bounded by g(Im w).
-/
lemma target_region_eq_bound' : target_region = {w : ℂ | |w.re| ≤ problem_114_g w.im ∧ w.im ∈ Icc (-(Real.pi/2)) (Real.pi/2)} := by
  exact?

/-
Expansion of complex cosh into real and imaginary parts.
-/
lemma Complex.cosh_eq_re_im (z : ℂ) : Complex.cosh z = Complex.cosh z.re * Complex.cos z.im + Complex.I * Complex.sinh z.re * Complex.sin z.im := by
  norm_num [ Complex.ext_iff, Complex.cosh, Complex.sinh ];
  norm_num [ Complex.exp_re, Complex.exp_im, Complex.cos, Complex.sin ] ; ring ; norm_num

/-
Real and imaginary parts of complex cosh.
-/
lemma Complex.cosh_re_eq (z : ℂ) : (Complex.cosh z).re = Real.cosh z.re * Real.cos z.im := by
  simp +decide [ Complex.cosh, Complex.exp_re, Complex.exp_im ];
  rw [ Real.cosh_eq ] ; ring

lemma Complex.cosh_im_eq (z : ℂ) : (Complex.cosh z).im = Real.sinh z.re * Real.sin z.im := by
  norm_num [ Complex.cosh, Complex.exp_re, Complex.exp_im ];
  rw [ Real.sinh_eq ] ; ring

#check target_region_eq_bound

/-
The real part of cosh(u) is non-negative in the target region.
-/
lemma Complex.cosh_re_nonneg {u : ℂ} (hu : u ∈ target_region) : 0 ≤ (Complex.cosh u).re := by
  rw [target_region_eq_bound] at hu
  rw [Complex.cosh_re_eq]
  apply mul_nonneg
  · apply le_of_lt
    apply Real.cosh_pos
  · apply Real.cos_nonneg_of_mem_Icc hu.2

/-
In the target region, Re(cosh u) > 0 or cosh u = 0.
-/
lemma Complex.cosh_re_pos_or_eq_zero {u : ℂ} (hu : u ∈ target_region) : 0 < (Complex.cosh u).re ∨ Complex.cosh u = 0 := by
  by_cases h_cos : (Complex.cosh u).re = 0;
  · have := Complex.cosh_sq_sub_sinh_sq u; simp_all +decide [ Complex.ext_iff, sq ] ;
    nlinarith [ hu.1, hu.2, norm_nonneg ( Complex.sinh u ), Complex.normSq_apply ( Complex.sinh u ), Complex.normSq_apply ( Complex.cosh u ), Complex.normSq_eq_norm_sq ( Complex.sinh u ), Complex.normSq_eq_norm_sq ( Complex.cosh u ) ];
  · exact Or.inl ( lt_of_le_of_ne ( Complex.cosh_re_nonneg hu ) ( Ne.symm h_cos ) )

/-
If u is in the target region and cos(Im u) = 0, then Re u = 0.
-/
lemma target_region_cos_zero_implies_re_zero {u : ℂ} (hu : u ∈ target_region) (h_cos : Real.cos u.im = 0) : u.re = 0 := by
  have h_u_re_zero : problem_114_g u.im = 0 := by
    unfold problem_114_g;
    norm_num [ h_cos ];
    norm_num [ Real.arcsinh ];
  have h_u_re_zero : u ∈ {w : ℂ | |w.re| ≤ problem_114_g w.im ∧ w.im ∈ Icc (-(Real.pi/2)) (Real.pi/2)} := by
    exact target_region_eq_bound'.subset hu;
  aesop

/-
sqrt(cosh^2 u) = cosh u for u in the target region.
-/
lemma Complex.sqrt_cosh_sq_eq_cosh {u : ℂ} (hu : u ∈ target_region) : (Complex.cosh u ^ 2) ^ (1 / 2 : ℂ) = Complex.cosh u := by
  have h_sqrt : ∀ z : ℂ, 0 < z.re ∨ z = 0 → (z ^ 2) ^ (1 / 2 : ℂ) = z := by
    intro z hz
    cases' hz with hz_pos hz_zero
    exact?
    norm_num [ hz_zero ];
  exact h_sqrt _ <| by simpa using Complex.cosh_re_pos_or_eq_zero hu;

#check problem_114_g_nonneg
#check target_region_convex

/-
sqrt(cosh^2 u) = cosh u for u in the target region.
-/
lemma Complex.sqrt_cosh_sq_eq_cosh' {u : ℂ} (hu : u ∈ target_region) : (Complex.cosh u ^ 2) ^ (1 / 2 : ℂ) = Complex.cosh u := by
  exact?

/-
The preimage is a rotation of the target region.
-/
lemma problem_114_preimage_eq_rotate_target : problem_114_preimage = (fun w => -I * w) '' target_region := by
  -- To prove equality of sets, we show each set is a subset of the other.
  apply Set.eq_of_subset_of_subset;
  · intro w hw;
    use -w * Complex.I⁻¹;
    field_simp;
    simp_all +decide [ problem_114_preimage, target_region ];
    simp_all +decide [ Complex.sinh, Complex.sin ];
    exact ⟨ by rw [ norm_sub_rev ] ; exact hw.2, abs_le.mpr hw.1 ⟩;
  · intro w
    rintro ⟨u, hu, rfl⟩
    simp [problem_114_preimage, target_region] at *;
    simp_all +decide [ Complex.sinh, Complex.sin ];
    exact ⟨ abs_le.mp hu.2, by convert hu.1 using 2; ring_nf; norm_num ⟩

/-
arcsinh(sinh(v)) = v for v in the target region.
-/
lemma Complex.arcsinh_sinh {v : ℂ} (hv : v ∈ target_region) : Complex.arcsinh (Complex.sinh v) = v := by
  unfold Complex.arcsinh;
  -- Using the identity $\sqrt{a^2 + 1} = \cosh(\text{arcsinh}(a))$, we can simplify the expression.
  have h_sqrt : (Complex.sinh v ^ 2 + 1) ^ (1 / 2 : ℂ) = Complex.cosh v := by
    rw [ show Complex.sinh v ^ 2 + 1 = Complex.cosh v ^ 2 by rw [ Complex.sinh_sq ] ; ring ];
    exact?;
  -- Since $\sinh v + \cosh v = e^v$, we can simplify the expression inside the logarithm.
  have h_exp : Complex.sinh v + Complex.cosh v = Complex.exp v := by
    rw [ Complex.sinh, Complex.cosh, add_comm ] ; ring;
  rw [ h_sqrt, h_exp, Complex.log_exp ];
  · linarith [ Real.pi_pos, abs_le.mp hv.2 ];
  · linarith [ abs_le.mp hv.2, Real.pi_pos ]

/-
sqrt(cosh^2 u) = cosh u for u in the target region.
-/
lemma Complex.sqrt_cosh_sq_eq_cosh_target {u : ℂ} (hu : u ∈ target_region) : (Complex.cosh u ^ 2) ^ (1 / 2 : ℂ) = Complex.cosh u := by
  exact?

/-
sqrt(cosh^2 u) = cosh u for u in the target region.
-/
lemma Complex.sqrt_cosh_sq_eq_cosh_final {u : ℂ} (hu : u ∈ target_region) : (Complex.cosh u ^ 2) ^ (1 / 2 : ℂ) = Complex.cosh u := by
  exact?

/-
The image of the unit disk under f is a scaled rotation of the preimage.
-/
lemma problem_114_image_eq : f_114 '' unitDisk = (fun w => -2 * I * w) '' problem_114_preimage := by
  -- By definition of $f_114$, we know that $f_114(z) = 2 \cdot \text{arcsinh}(z)$ for any $z \in \mathbb{C}$.
  have h_f_114_eq_arcsinh : ∀ z : ℂ, f_114 z = 2 * Complex.arcsinh z := by
    exact?;
  ext w;
  constructor <;> rintro ⟨ z, hz, rfl ⟩ <;> simp_all +decide [ Set.mem_setOf_eq ];
  · use -Complex.arcsinh z / Complex.I;
    field_simp;
    unfold problem_114_preimage; norm_num [ div_eq_mul_inv ];
    constructor;
    · have := Complex.arcsinh_range z;
      constructor <;> linarith [ abs_le.mp this ];
    · rw [ Complex.sin_mul_I ];
      rw [ Complex.sinh_arcsinh ] ; aesop;
  · use Complex.sinh (-Complex.I * z);
    unfold problem_114_preimage at hz;
    -- By definition of $f_114$, we know that $f_114(z) = 2 \cdot \text{arcsinh}(z)$ for any $z \in \mathbb{C}$. Therefore, the image of the unit disk under $f_114$ is the set of all $2 \cdot \text{arcsinh}(z)$ where $z$ is in the unit disk. Hence, we need to show that $Complex.sinh (-Complex.I * z)$ is in the unit disk and $2 * (Complex.sinh (-Complex.I * z)).arcsinh = -(2 * Complex.I * z)$.
    apply And.intro;
    · simp_all +decide [ Complex.sinh, Complex.exp_re, Complex.exp_im ];
      simp_all +decide [ Complex.sin, unitDisk ];
      simpa only [ mul_comm ] using hz.2;
    · have h_arcsinh_sinh : Complex.arcsinh (Complex.sinh (-Complex.I * z)) = -Complex.I * z := by
        apply Complex.arcsinh_sinh;
        unfold target_region;
        simp_all +decide [ Complex.sinh, Complex.exp_re, Complex.exp_im ];
        simp_all +decide [ Complex.sin, Complex.exp_re, Complex.exp_im ];
        exact ⟨ by simpa only [ mul_comm ] using hz.2, abs_le.mpr ⟨ by linarith, by linarith ⟩ ⟩;
      linear_combination' h_arcsinh_sinh * 2

/-
The image of the unit disk is the target region scaled by -2.
-/
lemma problem_114_image_eq_scale_target : f_114 '' unitDisk = (fun w => -2 * w) '' target_region := by
  -- Apply the lemma that relates the image of the unit disk under f to the image of the preimage under a different function.
  rw [problem_114_image_eq];
  -- Apply the lemma that relates the preimage to the target region.
  have h_preimage_eq_rotate_target : problem_114_preimage = (fun w => -I * w) '' target_region := by
    exact?;
  ext; simp [h_preimage_eq_rotate_target];
  constructor <;> rintro ⟨ x, hx, rfl ⟩ <;> use x <;> ring_nf at * <;> aesop

/-
The function w = (2/i) arcsin(iz) maps the unit disk to a convex domain contained in the strip -π ≤ Im(w) ≤ π.
-/
theorem problem_114_mapping_properties :
    let f : ℂ → ℂ := fun z => (2 / I) * Complex.arcsin (I * z)
    let unitDisk : Set ℂ := {z | ‖z‖ ≤ 1}
    let horizontalStrip : Set ℂ := {w | -Real.pi ≤ w.im ∧ w.im ≤ Real.pi}
    Convex ℝ (f '' unitDisk) ∧ f '' unitDisk ⊆ horizontalStrip := by
      constructor;
      · -- The image of the unit disk under $f$ is a scaled rotation of the target region, which is convex.
        have h_image_convex : Convex ℝ (f_114 '' unitDisk) := by
          rw [ problem_114_image_eq_scale_target ];
          apply_rules [ Convex.is_linear_image ];
          · exact?;
          · constructor <;> intros <;> simp +decide [ mul_add, add_mul ];
            ring;
        convert h_image_convex using 1;
      · intro w hw
        obtain ⟨z, hz, rfl⟩ := hw
        simp [hz];
        have := Complex.arcsin_range ( Complex.I * z );
        constructor <;> linarith [ this.1, this.2 ]

/-
Definitions of the domain D and its support function h_D, and the support function of the point πi.
-/
def problem_114_D : Set ℂ := f_114 '' unitDisk

noncomputable def h_D (φ : ℝ) : ℝ := sInf {r | ∀ w ∈ problem_114_D, (w * Complex.exp (-I * φ)).re ≤ r}

noncomputable def h_point (φ : ℝ) : ℝ := ((π * I) * Complex.exp (-I * φ)).re

/-
arcsinh(cos y) ≤ π/2 + y for y in [-π/2, π/2].
-/
lemma Real.arcsinh_cos_le_pi_div_two_add_id (y : ℝ) (hy : y ∈ Icc (-(Real.pi/2)) (Real.pi/2)) :
    Real.arcsinh (Real.cos y) ≤ Real.pi / 2 + y := by
      have h_g_le : problem_114_g y ≤ problem_114_g (-Real.pi / 2) + (y - (-Real.pi / 2)) * deriv problem_114_g (-Real.pi / 2) := by
        -- Apply the concavity condition with $x = y$ and $a = -\frac{\pi}{2}$.
        have h_concavity : ∀ x ∈ Set.Icc (-(Real.pi/2)) (Real.pi/2), ∀ a ∈ Set.Icc (-(Real.pi/2)) (Real.pi/2), problem_114_g x ≤ problem_114_g a + (x - a) * deriv problem_114_g a := by
          intros x hx a ha
          have h_concavity : ∀ t ∈ Set.Icc 0 1, problem_114_g (t * x + (1 - t) * a) ≥ t * problem_114_g x + (1 - t) * problem_114_g a := by
            have := Real.arcsinh_cos_concave.2 hx ha; aesop;
          -- By definition of derivative, we know that
          have h_deriv : Filter.Tendsto (fun t => (problem_114_g (a + t * (x - a)) - problem_114_g a) / t) (nhdsWithin 0 (Set.Ioi 0)) (nhds (deriv problem_114_g a * (x - a))) := by
            have h_deriv : HasDerivAt (fun t => problem_114_g (a + t * (x - a))) (deriv problem_114_g a * (x - a)) 0 := by
              convert HasDerivAt.comp 0 ( show HasDerivAt problem_114_g _ _ from hasDerivAt_deriv_iff.mpr ?_ ) ( HasDerivAt.add ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( hasDerivAt_id 0 ) ( hasDerivAt_const _ _ ) ) ) using 1 <;> norm_num;
              apply_rules [ DifferentiableAt.sub, DifferentiableAt.mul, DifferentiableAt.log, DifferentiableAt.sqrt ] <;> norm_num;
              · exact DifferentiableAt.sqrt ( by norm_num [ Real.differentiableAt_cos ] ) ( by positivity );
              · nlinarith [ Real.sqrt_nonneg ( Real.cos a ^ 2 + 1 ), Real.mul_self_sqrt ( show 0 ≤ Real.cos a ^ 2 + 1 by positivity ) ];
            simpa [ div_eq_inv_mul ] using h_deriv.tendsto_slope_zero_right;
          -- Applying the definition of derivative, we know that
          have h_deriv_le : ∀ᶠ t in nhdsWithin 0 (Set.Ioi 0), (problem_114_g (a + t * (x - a)) - problem_114_g a) / t ≥ problem_114_g x - problem_114_g a := by
            filter_upwards [ Ioo_mem_nhdsGT_of_mem ⟨ le_rfl, zero_lt_one ⟩ ] with t ht using by have := h_concavity t ⟨ ht.1.le, ht.2.le ⟩ ; rw [ ge_iff_le ] at *; rw [ le_div_iff₀ ht.1 ] ; ring_nf at *; linarith;
          have := le_of_tendsto_of_tendsto tendsto_const_nhds h_deriv h_deriv_le; norm_num at *; linarith;
        exact h_concavity y hy ( -Real.pi / 2 ) ⟨ by linarith [ Real.pi_pos ], by linarith [ Real.pi_pos ] ⟩;
      field_simp;
      convert mul_le_mul_of_nonneg_right h_g_le zero_le_two using 1 ; ring;
      rw [ show deriv problem_114_g ( Real.pi * ( -1 / 2 ) ) = -Real.sin ( Real.pi * ( -1 / 2 ) ) / Real.sqrt ( 1 + Real.cos ( Real.pi * ( -1 / 2 ) ) ^ 2 ) by rw [ problem_114_g_deriv ] ] ; norm_num [ mul_div ] ; ring;
      unfold problem_114_g; norm_num [ mul_div ] ;
      norm_num [ Real.arcsinh ]

/-
1 + sin(y)/sqrt(1+cos^2(y)) ≥ 0.
-/
lemma Real.one_add_sin_div_sqrt_nonneg (y : ℝ) : 0 ≤ 1 + Real.sin y / Real.sqrt (1 + Real.cos y ^ 2) := by
  rw [ add_div', le_div_iff₀ ] <;> nlinarith [ Real.sqrt_nonneg ( 1 + Real.cos y ^ 2 ), Real.mul_self_sqrt ( by nlinarith : 0 ≤ 1 + Real.cos y ^ 2 ), Real.sin_sq_add_cos_sq y ]

/-
arcsinh(0) = 0.
-/
lemma Real.arcsinh_zero : Real.arcsinh 0 = 0 := by
  norm_num [ Real.arcsinh ]

/-
arcsinh(cos y) + y ≤ π/2 for y in [0, π/2].
-/
lemma Real.arcsinh_cos_add_id_le_pi_div_two (y : ℝ) (hy : y ∈ Icc 0 (Real.pi/2)) :
    Real.arcsinh (Real.cos y) + y ≤ Real.pi / 2 := by
      -- Apply the lemma Real.arcsinh_cos_le_pi_div_two_add_id with the adjusted y' = -y.
      have h_apply_lemma : Real.arcsinh (Real.cos (-y)) ≤ Real.pi / 2 + (-y) := by
        apply Real.arcsinh_cos_le_pi_div_two_add_id;
        constructor <;> linarith [ hy.1, hy.2 ];
      norm_num at * ; linarith

/-
|cos φ| ≤ sin φ for φ in [π/4, 3π/4].
-/
lemma abs_cos_le_sin_of_mem_Icc_pi_div_four {φ : ℝ} (hφ : φ ∈ Icc (Real.pi/4) (3*Real.pi/4)) : |Real.cos φ| ≤ Real.sin φ := by
  rw [ abs_le ];
  constructor;
  · by_cases h₂ : φ ≤ Real.pi / 2;
    · linarith [ Real.sin_nonneg_of_nonneg_of_le_pi ( show 0 ≤ φ by linarith [ Real.pi_pos, hφ.1 ] ) ( by linarith [ Real.pi_pos, hφ.2 ] ), Real.cos_nonneg_of_mem_Icc ⟨ by linarith [ Real.pi_pos, hφ.1 ], h₂ ⟩ ];
    · rw [ ← Real.cos_sub_pi_div_two ];
      rw [ ← Real.cos_pi_sub ] ; exact Real.cos_le_cos_of_nonneg_of_le_pi ( by linarith [ Set.mem_Icc.mp hφ ] ) ( by linarith [ Set.mem_Icc.mp hφ ] ) ( by linarith [ Set.mem_Icc.mp hφ ] );
  · by_cases h₂ : φ ≤ Real.pi / 2;
    · rw [ ← Real.cos_pi_div_two_sub ] ; exact Real.cos_le_cos_of_nonneg_of_le_pi ( by linarith [ Set.mem_Icc.mp hφ ] ) ( by linarith [ Set.mem_Icc.mp hφ ] ) ( by linarith [ Set.mem_Icc.mp hφ ] );
    · rw [ ← Real.cos_sub_pi_div_two ] ; exact Real.cos_le_cos_of_nonneg_of_le_pi ( by linarith [ Set.mem_Icc.mp hφ ] ) ( by linarith [ Set.mem_Icc.mp hφ ] ) ( by linarith [ Set.mem_Icc.mp hφ ] )

/-
Inequality for the support function proof.
-/
lemma support_inequality (y : ℝ) (hy : y ∈ Icc (-(Real.pi/2)) (Real.pi/2)) (φ : ℝ) (hφ : Real.pi/4 ≤ φ ∧ φ ≤ 3*Real.pi/4) :
    Real.arcsinh (Real.cos y) * |Real.cos φ| ≤ (y + Real.pi / 2) * Real.sin φ := by
  have h_ineq := Real.arcsinh_cos_le_pi_div_two_add_id y hy
  rw [add_comm] at h_ineq
  have h_nonneg : 0 ≤ y + Real.pi / 2 := by linarith [hy.1, Real.pi_pos]
  have h_sin_pos : 0 < Real.sin φ := by
    apply Real.sin_pos_of_mem_Ioo
    constructor <;> linarith [Real.pi_pos]
  have h_cos_le_sin : |Real.cos φ| ≤ Real.sin φ := abs_cos_le_sin_of_mem_Icc_pi_div_four (Set.mem_Icc.mpr hφ)
  by_cases h_arcsinh : 0 ≤ Real.arcsinh (Real.cos y)
  · apply le_trans (mul_le_mul_of_nonneg_right h_ineq (abs_nonneg _))
    apply mul_le_mul_of_nonneg_left h_cos_le_sin h_nonneg
  · apply le_trans (mul_nonpos_of_nonpos_of_nonneg (le_of_lt (not_le.mp h_arcsinh)) (abs_nonneg _))
    apply mul_nonneg h_nonneg (le_of_lt h_sin_pos)

/-
The function F(v) is maximized at pi/2.
-/
lemma max_F_val (ψ : ℝ) (hψ : ψ ∈ Icc (Real.pi/4) (3*Real.pi/4)) :
    IsMaxOn (fun v => Real.arcsinh (Real.cos v) * |Real.cos ψ| + v * Real.sin ψ) (Icc (-(Real.pi/2)) (Real.pi/2)) (Real.pi/2) := by
      intro v hv
      have h_support : Real.arcsinh (Real.cos v) * |Real.cos ψ| ≤ (Real.pi / 2 - v) * Real.sin ψ := by
        convert support_inequality ( -v ) ⟨ by linarith [ hv.1, hv.2 ], by linarith [ hv.1, hv.2 ] ⟩ ψ hψ using 1 ; norm_num;
        ring;
      norm_num at *;
      rw [ Real.arcsinh_zero ] ; norm_num ; nlinarith [ Real.sin_nonneg_of_nonneg_of_le_pi ( by linarith : 0 ≤ ψ ) ( by linarith ) ]

/-
The point πi is in the domain D.
-/
lemma pi_I_mem_problem_114_D : π * I ∈ problem_114_D := by
  -- By definition of $problem_114_D$, we need to show that there exists $z \in \{z : ℂ | ‖z‖ ≤ 1\}$ such that $f_114 z = π * Complex.I$.
  have h_exists_z : ∃ z : ℂ, ‖z‖ ≤ 1 ∧ (2 / Complex.I) * Complex.arcsin (Complex.I * z) = Real.pi * Complex.I := by
    use Complex.I;
    norm_num [ div_eq_mul_inv, Complex.ext_iff, Complex.arcsin ];
    norm_num [ Complex.log_re, Complex.log_im ];
    ring;
  exact h_exists_z.imp fun z hz => ⟨ hz.1, hz.2 ⟩

/-
Auxiliary function G(v) = arcsinh(cos v) * |cos φ| - v * sin φ.
-/
noncomputable def aux_G (φ : ℝ) (v : ℝ) : ℝ := Real.arcsinh (Real.cos v) * |Real.cos φ| - v * Real.sin φ

/-
The support function of the domain equals the support function of the point πi for φ in [π/4, 3π/4].
-/
theorem problem_114_support_function :
    ∀ φ, Real.pi/4 ≤ φ ∧ φ ≤ 3*Real.pi/4 → h_D φ = h_point φ := by
      intros φ hφ
      have h_max : ∀ w ∈ problem_114_D, (w * Complex.exp (-I * φ)).re ≤ ((Real.pi * I) * Complex.exp (-I * φ)).re := by
        intro w hw;
        -- By definition of $problem_114_D$, we know that $w = -2 * (x + I * y)$ for some $x, y$ such that $|x| \leq problem_114_g(y)$ and $y \in [-\pi/2, \pi/2]$.
        obtain ⟨x, y, hx, hy⟩ : ∃ x y : ℝ, w = -2 * (x + Complex.I * y) ∧ |x| ≤ problem_114_g y ∧ y ∈ Set.Icc (-(Real.pi / 2)) (Real.pi / 2) := by
          -- By definition of $problem_114_D$, we know that $w = -2 * u$ for some $u$ in the target region.
          obtain ⟨u, hu⟩ : ∃ u : ℂ, w = -2 * u ∧ u ∈ target_region := by
            have h_w_in_target : w ∈ (fun w => -2 * w) '' target_region := by
              exact problem_114_image_eq_scale_target.subset hw;
            aesop;
          use u.re, u.im;
          exact ⟨ by rw [ hu.1 ] ; simp [ Complex.ext_iff ], by simpa [ abs_le ] using target_region_eq_bound'.subset hu.2 |>.1, by simpa [ abs_le ] using target_region_eq_bound'.subset hu.2 |>.2 ⟩;
        -- Using the inequality from the support function proof, we have:
        have h_support : Real.arcsinh (Real.cos y) * |Real.cos φ| ≤ (y + Real.pi / 2) * Real.sin φ := by
          apply support_inequality y hy.2 φ ⟨by linarith, by linarith⟩;
        norm_num [ Complex.exp_re, Complex.exp_im, hx ];
        -- Using the fact that $|x| \leq \text{arcsinh}(\cos y)$ and $\text{arcsinh}(\cos y) \leq \frac{\pi}{2} + y$, we get:
        have h_abs_x : |x| ≤ Real.arcsinh (Real.cos y) := by
          exact hy.1;
        cases abs_cases x <;> cases abs_cases ( Real.cos φ ) <;> nlinarith [ Real.neg_one_le_sin φ, Real.sin_le_one φ, Real.neg_one_le_cos φ, Real.cos_le_one φ ];
      refine' le_antisymm _ _;
      · exact csInf_le ⟨ _, fun x hx => hx _ <| pi_I_mem_problem_114_D ⟩ h_max;
      · apply le_csInf;
        · exact ⟨ _, h_max ⟩;
        · intro b hb;
          exact hb _ ( pi_I_mem_problem_114_D )

/-
Helper lemma for the support function inequality.
-/
lemma problem_114_support_inequality_aux (φ : ℝ) (hφ : Real.pi/4 ≤ φ ∧ φ ≤ 3*Real.pi/4) :
    ∀ w ∈ problem_114_D, (w * Complex.exp (-I * φ)).re ≤ Real.pi * Real.sin φ := by
      intro w hw;
      have := problem_114_support_function φ hφ;
      unfold h_D h_point at this;
      norm_num [ Complex.exp_re, Complex.exp_im ] at *;
      refine' this ▸ le_csInf _ _;
      · contrapose! this;
        rw [ this, Real.sInf_empty ] ; nlinarith [ Real.pi_pos, Real.sin_pos_of_pos_of_lt_pi ( show 0 < φ by linarith [ Real.pi_pos ] ) ( by linarith [ Real.pi_pos ] ) ];
      · exact fun r hr => hr w hw