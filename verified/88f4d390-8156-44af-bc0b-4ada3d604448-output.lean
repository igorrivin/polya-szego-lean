/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 88f4d390-8156-44af-bc0b-4ada3d604448

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Filter Asymptotics Metric MeasureTheory Real Set Topology

#check MeasureTheory.Measure.dirac

#check MeasureTheory.integral

/-
A sequence u_n is equidistributed on I if for every continuous function f on I, the average value of f(u_n) converges to the integral of f over I.
-/
def EquidistribOn (u : â„• â†’ â„) (I : Set â„) : Prop :=
  âˆ€ f : â„ â†’ â„‚, ContinuousOn f I â†’
  Tendsto (fun n : â„• => (1 / (n : â„‚)) * âˆ‘ k âˆˆ Finset.range n, f (u k)) atTop (ğ“ (âˆ« x in I, f x))

/-
The integral $\int_1^N e^{i a x^\sigma} dx$ is bounded by $C N^{1-\sigma}$ for some constant $C$.
-/
lemma norm_integral_oscillatory_power_le (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    âˆƒ C > 0, âˆ€ N : â„, N â‰¥ 1 â†’ â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€– â‰¤ C * N ^ (1 - Ïƒ) := by
  field_simp;
  use ( 1 + 1 / ( |a| * Ïƒ ) ) * 2;
  constructor;
  Â· exact mul_pos ( add_pos_of_pos_of_nonneg zero_lt_one ( one_div_nonneg.mpr ( mul_nonneg ( abs_nonneg a ) hÏƒ.1.le ) ) ) zero_lt_two;
  Â· -- Apply integration by parts to the integral.
    have h_parts : âˆ€ N : â„, 1 â‰¤ N â†’ âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * a * Real.rpow x Ïƒ) = (1 / (Complex.I * a * Ïƒ)) * (Complex.exp (Complex.I * a * Real.rpow N Ïƒ) / Real.rpow N (Ïƒ - 1) - Complex.exp (Complex.I * a * Real.rpow 1 Ïƒ) / Real.rpow 1 (Ïƒ - 1)) - (1 / (Complex.I * a * Ïƒ)) * âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * a * Real.rpow x Ïƒ) * (1 - Ïƒ) / Real.rpow x Ïƒ := by
      intro N hN
      have h_parts : âˆ€ x âˆˆ Set.Icc (1 : â„) N, deriv (fun x => Complex.exp (Complex.I * a * Real.rpow x Ïƒ) / (Complex.I * a * Ïƒ * Real.rpow x (Ïƒ - 1))) x = Complex.exp (Complex.I * a * Real.rpow x Ïƒ) + Complex.exp (Complex.I * a * Real.rpow x Ïƒ) * (1 - Ïƒ) / (Complex.I * a * Ïƒ * Real.rpow x Ïƒ) := by
        intro x hx;
        convert HasDerivAt.deriv ( HasDerivAt.div ( HasDerivAt.comp x ( Complex.hasDerivAt_exp _ ) <| HasDerivAt.const_mul _ <| HasDerivAt.ofReal_comp <| HasDerivAt.rpow_const ( hasDerivAt_id' x ) _ ) ( HasDerivAt.const_mul _ <| HasDerivAt.ofReal_comp <| HasDerivAt.rpow_const ( hasDerivAt_id' x ) _ ) _ ) using 1 <;> norm_num [ show x â‰  0 by linarith [ hx.1 ], hÏƒ.1.ne', hÏƒ.2.ne' ] ; ring;
        Â· norm_num [ Real.rpow_add ( by linarith [ hx.1 ] : 0 < x ), Real.rpow_neg ( by linarith [ hx.1 ] : 0 â‰¤ x ) ] ; ring;
          by_cases hx : x = 0 <;> simp_all +decide [ sq, mul_assoc, mul_comm, mul_left_comm ];
          Â· linarith;
          Â· field_simp;
            rw [ div_add_one, div_eq_div_iff ] <;> norm_cast <;> simp +decide [ *, ne_of_gt, Real.rpow_pos_of_pos ( by linarith : 0 < x ) ] ; ring;
        Â· exact âŸ¨ ha, ne_of_gt ( Real.rpow_pos_of_pos ( by linarith [ hx.1 ] ) _ ) âŸ©;
      have h_parts : âˆ« x in (1 : â„)..N, deriv (fun x => Complex.exp (Complex.I * a * Real.rpow x Ïƒ) / (Complex.I * a * Ïƒ * Real.rpow x (Ïƒ - 1))) x = (Complex.exp (Complex.I * a * Real.rpow N Ïƒ) / (Complex.I * a * Ïƒ * Real.rpow N (Ïƒ - 1))) - (Complex.exp (Complex.I * a * Real.rpow 1 Ïƒ) / (Complex.I * a * Ïƒ * Real.rpow 1 (Ïƒ - 1))) := by
        rw [ intervalIntegral.integral_deriv_eq_sub' ];
        Â· rfl;
        Â· intro x hx;
          norm_num +zetaDelta at *;
          exact DifferentiableAt.div ( Complex.differentiableAt_exp.comp x <| DifferentiableAt.mul ( differentiableAt_const _ ) <| Complex.ofRealCLM.differentiableAt.comp x <| DifferentiableAt.rpow ( differentiableAt_id ) ( by norm_num ) <| by cases Set.mem_uIcc.mp hx <;> linarith ) ( DifferentiableAt.mul ( differentiableAt_const _ ) <| Complex.ofRealCLM.differentiableAt.comp x <| DifferentiableAt.rpow ( differentiableAt_id ) ( by norm_num ) <| by cases Set.mem_uIcc.mp hx <;> linarith ) <| mul_ne_zero ( mul_ne_zero ( mul_ne_zero Complex.I_ne_zero <| Complex.ofReal_ne_zero.mpr ha ) <| Complex.ofReal_ne_zero.mpr <| by linarith ) <| Complex.ofReal_ne_zero.mpr <| ne_of_gt <| Real.rpow_pos_of_pos ( by cases Set.mem_uIcc.mp hx <;> linarith ) _;
        Â· rw [ Set.uIcc_of_le hN ];
          refine' ContinuousOn.congr _ fun x hx => h_parts x hx;
          refine' ContinuousOn.add _ _;
          Â· exact continuousOn_of_forall_continuousAt fun x hx => Complex.continuous_exp.continuousAt.comp <| ContinuousAt.mul continuousAt_const <| Complex.continuous_ofReal.continuousAt.comp <| ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by linarith [ hx.1 ];
          Â· refine' ContinuousOn.div _ _ _;
            Â· exact ContinuousOn.mul ( Complex.continuous_exp.comp_continuousOn <| ContinuousOn.mul continuousOn_const <| Complex.continuous_ofReal.comp_continuousOn <| ContinuousOn.rpow continuousOn_id continuousOn_const <| by continuity ) continuousOn_const;
            Â· exact ContinuousOn.mul ( continuousOn_const ) ( Complex.continuous_ofReal.comp_continuousOn ( continuousOn_id.rpow_const fun x hx => Or.inr <| by linarith [ hÏƒ.1, hÏƒ.2 ] ) );
            Â· exact fun x hx => mul_ne_zero ( mul_ne_zero ( mul_ne_zero Complex.I_ne_zero ( Complex.ofReal_ne_zero.mpr ha ) ) ( Complex.ofReal_ne_zero.mpr hÏƒ.1.ne' ) ) ( Complex.ofReal_ne_zero.mpr ( ne_of_gt ( Real.rpow_pos_of_pos ( by linarith [ hx.1 ] ) _ ) ) );
      rw [ intervalIntegral.integral_congr fun x hx => â€¹âˆ€ x âˆˆ Set.Icc 1 N, deriv ( fun x : â„ => Complex.exp ( Complex.I * ( a : â„‚ ) * ( x.rpow Ïƒ : â„‚ ) ) / ( Complex.I * ( a : â„‚ ) * ( Ïƒ : â„‚ ) * ( x.rpow ( Ïƒ - 1 ) : â„‚ ) ) ) x = Complex.exp ( Complex.I * ( a : â„‚ ) * ( x.rpow Ïƒ : â„‚ ) ) + Complex.exp ( Complex.I * ( a : â„‚ ) * ( x.rpow Ïƒ : â„‚ ) ) * ( 1 - ( Ïƒ : â„‚ ) ) / ( Complex.I * ( a : â„‚ ) * ( Ïƒ : â„‚ ) * ( x.rpow Ïƒ : â„‚ ) ) â€º x <| by simpa [ hN ] using hx ] at h_parts;
      rw [ intervalIntegral.integral_add ] at h_parts;
      Â· simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, â† intervalIntegral.integral_const_mul ];
        linear_combination h_parts;
      Â· exact Continuous.intervalIntegrable ( by exact Complex.continuous_exp.comp <| by exact Continuous.mul ( continuous_const ) <| by exact Continuous.comp ( Complex.continuous_ofReal ) <| by exact Continuous.rpow continuous_id' continuous_const <| by continuity ) _ _;
      Â· apply_rules [ ContinuousOn.intervalIntegrable ];
        refine' ContinuousOn.div _ _ _;
        Â· exact ContinuousOn.mul ( Complex.continuous_exp.comp_continuousOn <| ContinuousOn.mul continuousOn_const <| Complex.continuous_ofReal.comp_continuousOn <| ContinuousOn.rpow continuousOn_id continuousOn_const <| by aesop ) continuousOn_const;
        Â· exact ContinuousOn.mul ( continuousOn_const ) ( Complex.continuous_ofReal.comp_continuousOn ( continuousOn_id.rpow_const fun x hx => Or.inr <| by linarith [ hÏƒ.1, hÏƒ.2 ] ) );
        Â· exact fun x hx => mul_ne_zero ( mul_ne_zero ( mul_ne_zero Complex.I_ne_zero ( Complex.ofReal_ne_zero.mpr ha ) ) ( Complex.ofReal_ne_zero.mpr hÏƒ.1.ne' ) ) ( Complex.ofReal_ne_zero.mpr ( ne_of_gt ( Real.rpow_pos_of_pos ( by cases Set.mem_uIcc.mp hx <;> linarith ) _ ) ) );
    -- Apply the triangle inequality to the integral.
    have h_triangle : âˆ€ N : â„, 1 â‰¤ N â†’ â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * a * Real.rpow x Ïƒ)â€– â‰¤ (1 / (|a| * Ïƒ)) * (1 / N ^ (Ïƒ - 1) + 1) + (1 / (|a| * Ïƒ)) * âˆ« x in (1 : â„)..N, (1 - Ïƒ) / x ^ Ïƒ := by
      intro N hN
      rw [h_parts N hN];
      refine' le_trans ( norm_sub_le _ _ ) ( add_le_add _ _ );
      Â· norm_num [ Complex.norm_exp, abs_mul, abs_inv, abs_of_nonneg hÏƒ.1.le ];
        gcongr;
        Â· exact mul_nonneg ( inv_nonneg.2 hÏƒ.1.le ) ( inv_nonneg.2 ( abs_nonneg a ) );
        Â· refine' le_trans ( norm_sub_le _ _ ) _ ; norm_num [ Complex.norm_exp ];
          rw [ abs_of_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ];
      Â· norm_num [ abs_of_nonneg hÏƒ.1.le ];
        refine' mul_le_mul_of_nonneg_left _ ( by exact mul_nonneg ( inv_nonneg.2 hÏƒ.1.le ) ( inv_nonneg.2 ( abs_nonneg a ) ) );
        refine' le_trans ( intervalIntegral.norm_integral_le_integral_norm _ ) _;
        Â· linarith;
        Â· norm_num [ Complex.norm_exp ];
          norm_cast ; norm_num [ abs_of_nonneg, Real.rpow_nonneg, hÏƒ.1.le, hÏƒ.2.le ];
          exact le_of_eq ( intervalIntegral.integral_congr fun x hx => by rw [ abs_of_nonneg ( Real.rpow_nonneg ( by linarith [ Set.mem_Icc.mp ( by simpa [ hN ] using hx ) ] ) _ ) ] );
    -- Evaluate the remaining integral.
    have h_remaining : âˆ€ N : â„, 1 â‰¤ N â†’ âˆ« x in (1 : â„)..N, (1 - Ïƒ) / x ^ Ïƒ = (1 - Ïƒ) * (N ^ (1 - Ïƒ) - 1) / (1 - Ïƒ) := by
      intro N hN; norm_num [ div_eq_mul_inv, integral_rpow, hÏƒ.1.ne', hÏƒ.2.ne ] ; ring;
      rw [ intervalIntegral.integral_congr fun x hx => by rw [ â† Real.rpow_neg ( by linarith [ Set.mem_Icc.mp ( by simpa [ hN ] using hx ) ] ) ] ] ; rw [ integral_rpow ] <;> norm_num ; ring;
      exact Or.inl hÏƒ.2;
    intro N hN; specialize h_triangle N hN; specialize h_remaining N hN; simp_all +decide [ ne_of_gt, division_def ];
    refine le_trans h_triangle ?_;
    rw [ show ( N ^ ( Ïƒ - 1 ) ) â»Â¹ = N ^ ( 1 - Ïƒ ) by rw [ â† Real.rpow_neg ( by positivity ), neg_sub ] ];
    nlinarith [ show 0 < Ïƒâ»Â¹ * |a|â»Â¹ by exact mul_pos ( inv_pos.mpr hÏƒ.1 ) ( inv_pos.mpr ( abs_pos.mpr ha ) ), show 0 < N ^ ( 1 - Ïƒ ) by positivity, show 0 < Ïƒâ»Â¹ * |a|â»Â¹ * N ^ ( 1 - Ïƒ ) by exact mul_pos ( mul_pos ( inv_pos.mpr hÏƒ.1 ) ( inv_pos.mpr ( abs_pos.mpr ha ) ) ) ( Real.rpow_pos_of_pos ( by positivity ) _ ), mul_inv_cancel_leftâ‚€ ( by linarith : ( 1 - Ïƒ ) â‰  0 ) ( N ^ ( 1 - Ïƒ ) ) ]

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      -- We use the bound from `norm_integral_oscillatory_power_le`:
      obtain âŸ¨C, hC_pos, hC_boundâŸ© := norm_integral_oscillatory_power_le a Ïƒ ha hÏƒ;
      -- Then $\frac{1}{N} \|\int_1^N e^{i a x^\sigma} dx\| \le C N^{-\sigma}$.
      have h_div_bound : âˆ€ N : â„, N â‰¥ 1 â†’ (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€– â‰¤ C * N ^ (-Ïƒ) := by
        intro N hN; convert mul_le_mul_of_nonneg_left ( hC_bound N hN ) ( one_div_nonneg.mpr <| zero_le_one.trans hN ) using 1 ; ring;
        rw [ mul_assoc, â† Real.rpow_neg_one, â† Real.rpow_add ( by positivity ) ] ; ring;
      refine' squeeze_zero_norm' _ _;
      exacts [ fun N => C * N ^ ( -Ïƒ ), Filter.eventually_atTop.mpr âŸ¨ 1, fun N hN => by simpa [ abs_of_nonneg ( show 0 â‰¤ N by linarith ) ] using h_div_bound N hN âŸ©, by simpa using tendsto_const_nhds.mul ( tendsto_rpow_neg_atTop hÏƒ.1 ) ]

/-
The difference between the Weyl sum and the integral is bounded by $C N^\sigma$.
-/
lemma weyl_sum_diff_integral_le (a : â„) (Ïƒ : â„) (ha : a > 0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) (k : â„¤) (hk : k â‰  0) :
    âˆƒ C > 0, âˆ€ N : â„•, N â‰¥ 1 â†’ â€–(âˆ‘ n âˆˆ Finset.range N, Complex.exp (2 * Real.pi * Complex.I * (k : â„‚) * (a * Real.rpow n Ïƒ : â„‚))) - âˆ« x in (0 : â„)..N, Complex.exp (2 * Real.pi * Complex.I * (k : â„‚) * (a * Real.rpow x Ïƒ : â„‚))â€– â‰¤ C * (N : â„) ^ Ïƒ := by
  use 2 * Real.pi * |k| * a + 1;
  refine' âŸ¨ by positivity, fun N hN => _ âŸ©;
  -- We'll use the fact that |exp(iÎ¸)| = 1 for any real Î¸.
  have h_exp_bound : âˆ€ n âˆˆ Finset.range N, â€–Complex.exp (2 * Real.pi * Complex.I * k * (a * (n : â„).rpow Ïƒ)) - âˆ« x in (n : â„).. (n + 1 : â„), Complex.exp (2 * Real.pi * Complex.I * k * (a * (x : â„).rpow Ïƒ))â€– â‰¤ âˆ« x in (n : â„).. (n + 1 : â„), â€–Complex.exp (2 * Real.pi * Complex.I * k * (a * (n : â„).rpow Ïƒ)) - Complex.exp (2 * Real.pi * Complex.I * k * (a * (x : â„).rpow Ïƒ))â€– := by
    intro n hn;
    convert intervalIntegral.norm_integral_le_integral_norm _ using 2;
    rw [ intervalIntegral.integral_sub ] <;> norm_num;
    Â· apply_rules [ ContinuousOn.intervalIntegrable ];
      exact continuousOn_of_forall_continuousAt fun x hx => Complex.continuous_exp.continuousAt.comp <| ContinuousAt.mul continuousAt_const <| ContinuousAt.mul continuousAt_const <| Complex.continuous_ofReal.continuousAt.comp <| ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inr <| by linarith [ hÏƒ.1, hÏƒ.2 ];
    Â· norm_num;
  -- Applying the bound to each term in the sum, we get:
  have h_sum_bound : â€–âˆ‘ n âˆˆ Finset.range N, Complex.exp (2 * Real.pi * Complex.I * k * (a * (n : â„).rpow Ïƒ)) - âˆ« x in (0 : â„)..N, Complex.exp (2 * Real.pi * Complex.I * k * (a * (x : â„).rpow Ïƒ))â€– â‰¤ âˆ‘ n âˆˆ Finset.range N, âˆ« x in (n : â„).. (n + 1 : â„), â€–Complex.exp (2 * Real.pi * Complex.I * k * (a * (n : â„).rpow Ïƒ)) - Complex.exp (2 * Real.pi * Complex.I * k * (a * (x : â„).rpow Ïƒ))â€– := by
    convert le_trans ( norm_sum_le _ _ ) ( Finset.sum_le_sum h_exp_bound ) using 1;
    congr! 1;
    induction hN <;> simp_all +decide [ Finset.sum_range_succ ];
    rename_i m hm ih; rw [ â† ih ( fun n hn => h_exp_bound n ( by linarith ) ), intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ ContinuousOn.intervalIntegrable ];
    Â· exact continuousOn_of_forall_continuousAt fun x hx => Complex.continuous_exp.continuousAt.comp <| ContinuousAt.mul ( continuousAt_const ) <| ContinuousAt.mul ( continuousAt_const ) <| Complex.continuous_ofReal.continuousAt.comp <| ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inr <| by linarith;
    Â· exact continuousOn_of_forall_continuousAt fun x hx => Complex.continuous_exp.continuousAt.comp <| ContinuousAt.mul continuousAt_const <| ContinuousAt.mul continuousAt_const <| Complex.continuous_ofReal.continuousAt.comp <| ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inr <| by linarith;
  -- We'll use the fact that |exp(iÎ¸) - exp(iÏ†)| â‰¤ |Î¸ - Ï†| for any real Î¸ and Ï†.
  have h_exp_diff_bound : âˆ€ n âˆˆ Finset.range N, âˆ€ x âˆˆ Set.Icc (n : â„) (n + 1 : â„), â€–Complex.exp (2 * Real.pi * Complex.I * k * (a * (n : â„).rpow Ïƒ)) - Complex.exp (2 * Real.pi * Complex.I * k * (a * (x : â„).rpow Ïƒ))â€– â‰¤ 2 * Real.pi * |k| * a * |(x : â„).rpow Ïƒ - (n : â„).rpow Ïƒ| := by
    -- We'll use the fact that |exp(iÎ¸) - exp(iÏ†)| â‰¤ |Î¸ - Ï†| for any real Î¸ and Ï†. This follows from the triangle inequality and the fact that |exp(iÎ¸)| = 1.
    have h_exp_diff_bound : âˆ€ Î¸ Ï† : â„, â€–Complex.exp (Î¸ * Complex.I) - Complex.exp (Ï† * Complex.I)â€– â‰¤ |Î¸ - Ï†| := by
      -- We'll use the fact that |exp(iÎ¸) - exp(iÏ†)| = 2 |sin((Î¸ - Ï†)/2)|.
      have h_exp_diff_bound : âˆ€ Î¸ Ï† : â„, â€–Complex.exp (Î¸ * Complex.I) - Complex.exp (Ï† * Complex.I)â€– = 2 * |Real.sin ((Î¸ - Ï†) / 2)| := by
        norm_num [ Complex.norm_def, Complex.normSq, Complex.exp_re, Complex.exp_im ];
        intro Î¸ Ï†; rw [ Real.sqrt_eq_iff_mul_self_eq ] <;> norm_num <;> ring <;> norm_num [ Real.sin_sq, Real.cos_sq ] <;> ring;
        Â· rw [ Real.cos_sub ] ; ring;
        Â· nlinarith [ sq_nonneg ( Real.cos Î¸ - Real.cos Ï† ), sq_nonneg ( Real.sin Î¸ - Real.sin Ï† ), Real.cos_sq_add_sin_sq Î¸, Real.cos_sq_add_sin_sq Ï† ];
      -- We'll use the fact that |sin(x)| â‰¤ |x| for any real x.
      have h_sin_bound : âˆ€ x : â„, |Real.sin x| â‰¤ |x| := by
        exact?;
      exact fun Î¸ Ï† => by rw [ h_exp_diff_bound Î¸ Ï† ] ; exact le_trans ( mul_le_mul_of_nonneg_left ( h_sin_bound _ ) zero_le_two ) ( by cases abs_cases ( ( Î¸ - Ï† ) / 2 ) <;> cases abs_cases ( Î¸ - Ï† ) <;> linarith ) ;
    intros n hn x hx
    specialize h_exp_diff_bound (2 * Real.pi * k * a * (n : â„).rpow Ïƒ) (2 * Real.pi * k * a * (x : â„).rpow Ïƒ);
    convert h_exp_diff_bound using 1 <;> norm_num [ abs_mul, abs_sub_comm ] ; ring;
    rw [ show ( 2 * Real.pi * k * a * x ^ Ïƒ - 2 * Real.pi * k * a * ( n : â„ ) ^ Ïƒ ) = ( 2 * Real.pi * k * a ) * ( x ^ Ïƒ - ( n : â„ ) ^ Ïƒ ) by ring, abs_mul, abs_mul, abs_mul, abs_of_nonneg ( by positivity : ( 0 : â„ ) â‰¤ 2 * Real.pi ), abs_of_nonneg ( by positivity : ( 0 : â„ ) â‰¤ a ) ];
  -- Applying the bound to each term in the sum, we get the desired inequality.
  have h_integral_bound : âˆ€ n âˆˆ Finset.range N, âˆ« x in (n : â„).. (n + 1 : â„), |(x : â„).rpow Ïƒ - (n : â„).rpow Ïƒ| â‰¤ (n + 1 : â„) ^ Ïƒ - (n : â„) ^ Ïƒ := by
    intros n hn
    have h_integral_bound : âˆ« x in (n : â„).. (n + 1 : â„), |(x : â„).rpow Ïƒ - (n : â„).rpow Ïƒ| â‰¤ âˆ« x in (n : â„).. (n + 1 : â„), (x : â„).rpow Ïƒ - (n : â„).rpow Ïƒ := by
      refine' intervalIntegral.integral_mono_on _ _ _ _ <;> norm_num;
      Â· exact ContinuousOn.intervalIntegrable ( by exact ContinuousOn.abs ( ContinuousOn.sub ( continuousOn_id.rpow_const fun x hx => Or.inr <| by linarith [ hÏƒ.1, hÏƒ.2 ] ) continuousOn_const ) ) ..;
      Â· exact Continuous.intervalIntegrable ( by exact Continuous.sub ( continuous_id.rpow_const fun x => Or.inr <| by linarith [ hÏƒ.1, hÏƒ.2 ] ) continuous_const ) _ _;
      Â· exact fun x hxâ‚ hxâ‚‚ => by rw [ abs_of_nonneg ( sub_nonneg_of_le <| Real.rpow_le_rpow ( by linarith ) hxâ‚ <| by linarith [ hÏƒ.1, hÏƒ.2 ] ) ] ;
    refine le_trans h_integral_bound ?_;
    rw [ intervalIntegral.integral_sub ] <;> norm_num [ hÏƒ.1.ne', hÏƒ.2.ne' ];
    Â· rw [ intervalIntegral.integral_of_le ( by norm_num ) ];
      exact le_trans ( MeasureTheory.setIntegral_mono_on ( by exact ContinuousOn.integrableOn_Icc ( by exact continuousOn_of_forall_continuousAt fun x hx => by exact ContinuousAt.rpow ( continuousAt_id ) continuousAt_const <| Or.inr <| by linarith [ hÏƒ.1, hÏƒ.2 ] ) |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self ) ( by exact Continuous.integrableOn_Ioc <| by continuity ) measurableSet_Ioc fun x hx => Real.rpow_le_rpow ( by linarith [ hx.1 ] ) hx.2 <| by linarith [ hÏƒ.1, hÏƒ.2 ] ) <| by norm_num;
    Â· exact intervalIntegral.intervalIntegrable_rpow' ( by linarith [ hÏƒ.1, hÏƒ.2 ] );
  -- Applying the bound to each term in the sum, we get the desired inequality for the integral.
  have h_integral_bound_sum : âˆ‘ n âˆˆ Finset.range N, âˆ« x in (n : â„).. (n + 1 : â„), â€–Complex.exp (2 * Real.pi * Complex.I * k * (a * (n : â„).rpow Ïƒ)) - Complex.exp (2 * Real.pi * Complex.I * k * (a * (x : â„).rpow Ïƒ))â€– â‰¤ âˆ‘ n âˆˆ Finset.range N, 2 * Real.pi * |k| * a * ((n + 1 : â„) ^ Ïƒ - (n : â„) ^ Ïƒ) := by
    refine Finset.sum_le_sum fun n hn => le_trans ( intervalIntegral.integral_mono_on ?_ ?_ ?_ fun x hx => h_exp_diff_bound n hn x <| by simpa using hx ) ?_;
    Â· norm_num;
    Â· apply_rules [ ContinuousOn.intervalIntegrable ];
      exact ContinuousOn.norm ( ContinuousOn.sub continuousOn_const <| Complex.continuous_exp.comp_continuousOn <| ContinuousOn.mul continuousOn_const <| ContinuousOn.mul continuousOn_const <| Complex.continuous_ofReal.comp_continuousOn <| ContinuousOn.rpow continuousOn_id continuousOn_const <| by aesop );
    Â· exact ContinuousOn.intervalIntegrable ( by exact ContinuousOn.mul ( continuousOn_const ) ( ContinuousOn.abs ( ContinuousOn.sub ( continuousOn_id.rpow_const fun x hx => Or.inr <| by linarith [ hÏƒ.1, hÏƒ.2 ] ) continuousOn_const ) ) );
    Â· rw [ intervalIntegral.integral_const_mul ] ; exact mul_le_mul_of_nonneg_left ( h_integral_bound n hn ) ( by positivity );
  -- Notice that $\sum_{n=0}^{N-1} ((n+1)^\sigma - n^\sigma)$ is a telescoping series.
  have h_telescope : âˆ‘ n âˆˆ Finset.range N, ((n + 1 : â„) ^ Ïƒ - (n : â„) ^ Ïƒ) = (N : â„) ^ Ïƒ := by
    convert Finset.sum_range_sub ( fun n => ( n : â„ ) ^ Ïƒ ) N using 1 ; norm_num;
    norm_num [ hÏƒ.1.ne' ];
  exact h_sum_bound.trans <| h_integral_bound_sum.trans <| by rw [ â† Finset.mul_sum _ _ _, h_telescope ] ; nlinarith [ show 0 â‰¤ 2 * Real.pi * |k| * a by positivity, show 0 â‰¤ ( N : â„ ) ^ Ïƒ by positivity ] ;

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power' (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      exact?

#check squeeze_zero
#check squeeze_zero_norm

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power_v2 (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      exact?

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power_v3 (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      exact?

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power_v4 (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      convert integral_oscillatory_power_v3 a Ïƒ ha hÏƒ using 1

#check tendsto_rpow_neg_atTop

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power_v5 (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      have := @integral_oscillatory_power_v4;
      exact this a Ïƒ ha hÏƒ

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power_v6 (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      exact?

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power_v7 (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      have := integral_oscillatory_power a Ïƒ ha hÏƒ;
      convert this using 1

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power_final (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      exact?

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power_proven (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      exact?

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power_correct (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      exact?

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power_final_v2 (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      exact?

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power_v8 (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      convert integral_oscillatory_power_final a Ïƒ ha hÏƒ using 1

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power_final_v3 (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      convert integral_oscillatory_power_final_v2 a Ïƒ ha hÏƒ using 1

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power_final_v4 (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      exact?

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power_final_v5 (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      exact?

/-
The average of the oscillatory integral $\int_1^N e^{i a x^\sigma} dx$ tends to 0 as $N \to \infty$.
-/
lemma integral_oscillatory_power_final_v6 (a : â„) (Ïƒ : â„) (ha : a â‰  0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) :
    Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (Complex.I * (a * Real.rpow x Ïƒ : â„‚))â€–) atTop (ğ“ 0) := by
      exact?

/-
The Weyl sums for the sequence $a n^\sigma$ tend to 0.
-/
lemma problem_175_weyl_criterion (a : â„) (Ïƒ : â„) (ha : a > 0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) (k : â„¤) (hk : k â‰  0) :
    Tendsto (fun N : â„• => (1 / (N : â„‚)) * âˆ‘ n âˆˆ Finset.range N, Complex.exp (2 * Real.pi * Complex.I * (k : â„‚) * (a * Real.rpow n Ïƒ : â„‚))) atTop (ğ“ 0) := by
      -- The difference between the sum and the integral is bounded by $C N^\sigma$.
      have h_diff : âˆƒ C > 0, âˆ€ N : â„•, N â‰¥ 1 â†’ â€–(âˆ‘ n âˆˆ Finset.range N, Complex.exp (2 * Real.pi * Complex.I * k * (a * Real.rpow n Ïƒ))) - (âˆ« x in (0 : â„)..N, Complex.exp (2 * Real.pi * Complex.I * k * (a * Real.rpow x Ïƒ)))â€– â‰¤ C * (N : â„) ^ Ïƒ := by
        exact?;
      -- The integral divided by $N$ tends to 0 by `integral_oscillatory_power_final_v5`.
      have h_integral : Filter.Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (0 : â„)..N, Complex.exp (2 * Real.pi * Complex.I * k * (a * Real.rpow x Ïƒ))â€–) Filter.atTop (ğ“ 0) := by
        refine' squeeze_zero_norm' _ _;
        use fun N => ( 1 / N ) * â€–âˆ« x in ( 1 : â„ )..N, Complex.exp ( 2 * Real.pi * Complex.I * k * ( a * Real.rpow x Ïƒ ) )â€– + ( 1 / N ) * â€–âˆ« x in ( 0 : â„ )..1, Complex.exp ( 2 * Real.pi * Complex.I * k * ( a * Real.rpow x Ïƒ ) )â€–;
        Â· -- By the properties of integrals, we can split the integral into two parts:
          have h_split : âˆ€ n : â„, 1 â‰¤ n â†’ âˆ« x in (0 : â„)..n, Complex.exp (2 * Real.pi * Complex.I * k * (a * Real.rpow x Ïƒ)) = (âˆ« x in (0 : â„)..1, Complex.exp (2 * Real.pi * Complex.I * k * (a * Real.rpow x Ïƒ))) + (âˆ« x in (1 : â„)..n, Complex.exp (2 * Real.pi * Complex.I * k * (a * Real.rpow x Ïƒ))) := by
            intro n hn; rw [ intervalIntegral.integral_add_adjacent_intervals ] ; all_goals apply_rules [ Continuous.intervalIntegrable ];
            Â· exact Complex.continuous_exp.comp <| Continuous.mul ( continuous_const ) <| Continuous.mul ( continuous_const ) <| Complex.continuous_ofReal.comp <| continuous_id'.rpow_const fun x => Or.inr <| by linarith [ hÏƒ.1, hÏƒ.2 ] ;
            Â· exact Complex.continuous_exp.comp <| Continuous.mul ( continuous_const ) <| Continuous.mul ( continuous_const ) <| Complex.continuous_ofReal.comp <| continuous_id'.rpow_const fun x => Or.inr <| by linarith [ hÏƒ.1, hÏƒ.2 ] ;
          filter_upwards [ Filter.eventually_ge_atTop 1 ] with n hn using by rw [ h_split n hn ] ; rw [ Real.norm_of_nonneg ( by positivity ) ] ; exact by rw [ â† mul_add ] ; exact mul_le_mul_of_nonneg_left ( by simpa [ add_comm ] using norm_add_le ( âˆ« x in ( 1 : â„ )..n, Complex.exp ( 2 * Real.pi * Complex.I * k * ( a * Real.rpow x Ïƒ ) ) ) ( âˆ« x in ( 0 : â„ )..1, Complex.exp ( 2 * Real.pi * Complex.I * k * ( a * Real.rpow x Ïƒ ) ) ) ) ( by positivity ) ;
        Â· have h_integral : Filter.Tendsto (fun N : â„ => (1 / N) * â€–âˆ« x in (1 : â„)..N, Complex.exp (2 * Real.pi * Complex.I * k * (a * Real.rpow x Ïƒ))â€–) Filter.atTop (ğ“ 0) := by
            convert integral_oscillatory_power_final_v6 ( 2 * Real.pi * k * a ) Ïƒ ( show 2 * Real.pi * k * a â‰  0 from mul_ne_zero ( mul_ne_zero ( mul_ne_zero two_ne_zero Real.pi_ne_zero ) ( Int.cast_ne_zero.mpr hk ) ) ha.ne' ) hÏƒ using 2 ; norm_num [ mul_assoc, mul_comm, mul_left_comm ];
          simpa using h_integral.add ( tendsto_inv_atTop_zero.mul_const ( â€–âˆ« x in ( 0 : â„ )..1, Complex.exp ( 2 * Real.pi * Complex.I * k * ( a * Real.rpow x Ïƒ ) )â€– : â„ ) );
      -- Dividing by $N$, this tends to 0 since $\sigma < 1$.
      have h_div : Filter.Tendsto (fun N : â„• => (1 / (N : â„)) * â€–(âˆ‘ n âˆˆ Finset.range N, Complex.exp (2 * Real.pi * Complex.I * k * (a * Real.rpow n Ïƒ))) - (âˆ« x in (0 : â„)..N, Complex.exp (2 * Real.pi * Complex.I * k * (a * Real.rpow x Ïƒ)))â€–) Filter.atTop (ğ“ 0) := by
        -- Using the bound from `h_diff`, we can show that the difference divided by $N$ tends to 0.
        obtain âŸ¨C, hC_pos, hC_boundâŸ© := h_diff;
        have h_div : Filter.Tendsto (fun N : â„• => (1 / (N : â„)) * (C * (N : â„) ^ Ïƒ)) Filter.atTop (ğ“ 0) := by
          -- Simplify the expression inside the limit.
          suffices h_simplify : Filter.Tendsto (fun N : â„• => C * (N : â„) ^ (Ïƒ - 1)) Filter.atTop (ğ“ 0) by
            refine h_simplify.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with N hN using by rw [ Real.rpow_sub_one ( by positivity ) ] ; ring );
          simpa using tendsto_const_nhds.mul ( tendsto_rpow_neg_atTop ( sub_pos.mpr hÏƒ.2 ) |> Filter.Tendsto.comp <| tendsto_natCast_atTop_atTop );
        exact squeeze_zero_norm' ( Filter.eventually_atTop.mpr âŸ¨ 1, fun N hN => by rw [ Real.norm_of_nonneg ( by positivity ) ] ; exact mul_le_mul_of_nonneg_left ( hC_bound N hN ) ( by positivity ) âŸ© ) h_div;
      have h_sum : Filter.Tendsto (fun N : â„• => (1 / (N : â„)) * â€–âˆ‘ n âˆˆ Finset.range N, Complex.exp (2 * Real.pi * Complex.I * k * (a * Real.rpow n Ïƒ))â€–) Filter.atTop (ğ“ 0) := by
        have h_sum : Filter.Tendsto (fun N : â„• => (1 / (N : â„)) * (â€–âˆ‘ n âˆˆ Finset.range N, Complex.exp (2 * Real.pi * Complex.I * k * (a * Real.rpow n Ïƒ)) - âˆ« x in (0 : â„)..N, Complex.exp (2 * Real.pi * Complex.I * k * (a * Real.rpow x Ïƒ))â€– + â€–âˆ« x in (0 : â„)..N, Complex.exp (2 * Real.pi * Complex.I * k * (a * Real.rpow x Ïƒ))â€–)) Filter.atTop (ğ“ 0) := by
          convert h_div.add ( h_integral.comp tendsto_natCast_atTop_atTop ) using 2 <;> norm_num ; ring;
        refine' squeeze_zero ( fun N => by positivity ) ( fun N => mul_le_mul_of_nonneg_left ( by simpa using norm_add_le ( âˆ‘ n âˆˆ Finset.range N, Complex.exp ( 2 * Real.pi * Complex.I * k * ( a * Real.rpow n Ïƒ ) ) - âˆ« x in ( 0 : â„ )..N, Complex.exp ( 2 * Real.pi * Complex.I * k * ( a * Real.rpow x Ïƒ ) ) ) ( âˆ« x in ( 0 : â„ )..N, Complex.exp ( 2 * Real.pi * Complex.I * k * ( a * Real.rpow x Ïƒ ) ) ) ) ( by positivity ) ) h_sum;
      rw [ tendsto_zero_iff_norm_tendsto_zero ] at * ; aesop

/-
The Weyl sums for the sequence $a n^\sigma$ tend to 0.
-/
lemma problem_175_weyl_sum_limit (a : â„) (Ïƒ : â„) (ha : a > 0) (hÏƒ : Ïƒ âˆˆ Set.Ioo (0 : â„) 1) (k : â„¤) (hk : k â‰  0) :
    Tendsto (fun N : â„• => (1 / (N : â„‚)) * âˆ‘ n âˆˆ Finset.range N, Complex.exp (2 * Real.pi * Complex.I * (k : â„‚) * (a * Real.rpow n Ïƒ : â„‚))) atTop (ğ“ 0) := by
      convert problem_175_weyl_criterion a Ïƒ ha hÏƒ k hk using 1

/-
If the Weyl sums tend to 0, then the average of any trigonometric polynomial tends to its integral.
-/
lemma weyl_sums_implies_trig_polynomials (u : â„• â†’ â„) (hu : âˆ€ n, u n âˆˆ Set.Icc 0 1)
    (h_weyl : âˆ€ k : â„¤, k â‰  0 â†’ Tendsto (fun N : â„• => (1 / (N : â„‚)) * âˆ‘ n âˆˆ Finset.range N, Complex.exp (2 * Real.pi * Complex.I * k * (u n))) atTop (ğ“ 0)) :
    âˆ€ (p : â„¤ â†’â‚€ â„‚), Tendsto (fun N : â„• => (1 / (N : â„‚)) * âˆ‘ n âˆˆ Finset.range N, âˆ‘ k âˆˆ p.support, p k * Complex.exp (2 * Real.pi * Complex.I * k * (u n))) atTop (ğ“ (âˆ« x in (0 : â„)..1, âˆ‘ k âˆˆ p.support, p k * Complex.exp (2 * Real.pi * Complex.I * k * x))) := by
  intro p
  have h_integral : âˆ€ k : â„¤, k â‰  0 â†’ (âˆ« x in (0 : â„)..1, Complex.exp (2 * Real.pi * Complex.I * k * x)) = 0 := by
    intro k hk_ne; have := @integral_exp_mul_complex 0 1; simp_all +decide [ Complex.exp_ne_zero, intervalIntegral.integral_comp_mul_left ] ;
    exact sub_eq_zero_of_eq ( Complex.exp_eq_one_iff.mpr âŸ¨ k, by ring âŸ© );
  -- By definition of $p$, we can rewrite the sum as a finite sum over its support.
  have h_sum_support : Filter.Tendsto (fun N : â„• => (1 / (N : â„‚)) * âˆ‘ k âˆˆ p.support, p k * âˆ‘ n âˆˆ Finset.range N, Complex.exp (2 * Real.pi * Complex.I * k * (u n))) Filter.atTop (ğ“ (âˆ‘ k âˆˆ p.support, p k * (âˆ« x in (0 : â„)..1, Complex.exp (2 * Real.pi * Complex.I * k * x)))) := by
    have h_sum_support : âˆ€ k âˆˆ p.support, Filter.Tendsto (fun N : â„• => (1 / (N : â„‚)) * âˆ‘ n âˆˆ Finset.range N, Complex.exp (2 * Real.pi * Complex.I * k * (u n))) Filter.atTop (ğ“ (âˆ« x in (0 : â„)..1, Complex.exp (2 * Real.pi * Complex.I * k * x))) := by
      intro k hk; by_cases hk0 : k = 0 <;> simp_all +decide ;
      exact tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_ne_atTop 0 ] with N hN; simp +decide [ hN ] );
    simpa [ mul_assoc, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul ] using tendsto_finset_sum _ fun k hk => h_sum_support k hk |> Filter.Tendsto.const_mul ( p k );
  convert h_sum_support using 2;
  Â· rw [ Finset.sum_comm, Finset.sum_congr rfl fun _ _ => Finset.mul_sum _ _ _ ];
  Â· rw [ intervalIntegral.integral_finset_sum ] ; aesop;
    exact fun _ _ => Continuous.intervalIntegrable ( by continuity ) _ _

#check UnitAddTorus

#check Function.Periodic