/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5f417d26-1c4d-4844-92e4-2d0e3fa2817c
-/

/-
Verified Polya-Szego Problem 177.
The series ∑_{n=1}^∞ sin(n^σ ξ)/n^ϱ is absolutely convergent if and only if ϱ > 1, for 0 < σ < 1 and ξ ≠ 0.
The proof is split into two directions:
1. Convergence for ϱ > 1 follows from comparison with the p-series ∑ 1/n^ϱ.
2. Divergence for ϱ ≤ 1 is shown by constructing disjoint intervals I_k where |sin(n^σ ξ)| ≥ 1/2, and showing that the sum over these intervals diverges.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
If r > 1, the series converges absolutely.
-/
theorem problem_177_converges (σ r ξ : ℝ) (hσpos : 0 < σ) (hσlt1 : σ < 1) (hξ_ne_zero : ξ ≠ 0) (hr : r > 1) :
    Summable fun (n : ℕ) ↦ |Real.sin (((n : ℝ) ^ σ) * ξ) / ((n : ℝ) ^ r)| := by
  simp_rw +decide [ abs_div ];
  exact Summable.of_nonneg_of_le ( fun n => by positivity ) ( fun n => mul_le_of_le_one_left ( by positivity ) ( Real.abs_sin_le_one _ ) ) ( by simpa [ abs_of_nonneg ( Real.rpow_nonneg ( Nat.cast_nonneg _ ) _ ) ] using Real.summable_one_div_nat_rpow.2 hr )

/-
Definitions of the interval endpoints for the divergence proof.
-/
noncomputable def ak (σ ξ : ℝ) (k : ℕ) : ℝ := ((2 * k * Real.pi + Real.pi / 6) / |ξ|) ^ (1 / σ)
noncomputable def bk (σ ξ : ℝ) (k : ℕ) : ℝ := ((2 * k * Real.pi + 5 * Real.pi / 6) / |ξ|) ^ (1 / σ)

/-
Definition of Ik and proof that it contains exactly the integers in [ak, bk].
-/
noncomputable def Ik (σ ξ : ℝ) (k : ℕ) : Finset ℕ :=
  Finset.Icc (Nat.ceil (ak σ ξ k)) (Nat.floor (bk σ ξ k))

lemma mem_Ik_iff (σ ξ : ℝ) (k n : ℕ) :
    n ∈ Ik σ ξ k ↔ ak σ ξ k ≤ n ∧ n ≤ bk σ ξ k := by
      simp +decide [ Ik ];
      exact fun _ => Nat.le_floor_iff ( by exact Real.rpow_nonneg ( div_nonneg ( by positivity ) ( abs_nonneg ξ ) ) _ )

/-
The intervals Ik are disjoint for distinct k.
-/
lemma Ik_disjoint (σ ξ : ℝ) (hσpos : 0 < σ) (hξ_ne_zero : ξ ≠ 0) :
    ∀ k m, k < m → Disjoint (Ik σ ξ k) (Ik σ ξ m) := by
      -- By definition of $ak$ and $bk$, we know that $bk k < ak m$ for $k < m$.
      have h_disjoint : ∀ k m : ℕ, k < m → bk σ ξ k < ak σ ξ m := by
        intro k m hkm; unfold bk ak; (
        exact Real.rpow_lt_rpow ( by positivity ) ( by rw [ div_lt_div_iff_of_pos_right ( by positivity ) ] ; nlinarith [ Real.pi_pos, show ( k : ℝ ) + 1 ≤ m by norm_cast ] ) ( by positivity ));
      intros k m hkm; rw [ Finset.disjoint_left ] ; intros n hn hn'; have := h_disjoint k m hkm; norm_num +zetaDelta at *;
      linarith [ mem_Ik_iff σ ξ k n |>.1 hn, mem_Ik_iff σ ξ m n |>.1 hn' ]

/-
The length of the interval [ak, bk] grows at least as fast as k^(1/σ - 1).
-/
lemma len_interval_ge (σ ξ : ℝ) (hσpos : 0 < σ) (hσlt1 : σ < 1) (hξ_ne_zero : ξ ≠ 0) :
    ∃ C > 0, ∀ᶠ k in Filter.atTop, bk σ ξ k - ak σ ξ k ≥ C * (k : ℝ) ^ (1 / σ - 1) := by
  -- We can factor out $(k : ℝ)^{1 / σ}$ from the expression for the length of the interval.
  have h_length_factor : ∃ C > 0, ∀ᶠ k in Filter.atTop, (bk σ ξ k - ak σ ξ k) ≥ C * (k : ℝ) ^ (1 / σ - 1) := by
    have h_length_factor : ∀ᶠ k in Filter.atTop, (bk σ ξ k - ak σ ξ k) ≥ (2 * Real.pi / 3) / |ξ| ^ (1 / σ) * (k : ℝ) ^ (1 / σ - 1) := by
      -- By simplifying, we can see that the difference between the upper and lower bounds is at least $(2 * \pi / 3) / |\xi|^{1/\sigma} * k^{1/\sigma - 1}$ for sufficiently large $k$.
      have h_diff_simplified : ∀ᶠ k in Filter.atTop, (2 * k * Real.pi + 5 * Real.pi / 6) ^ (1 / σ) - (2 * k * Real.pi + Real.pi / 6) ^ (1 / σ) ≥ (2 * Real.pi / 3) * (2 * k * Real.pi) ^ (1 / σ - 1) := by
        -- We'll use the fact that $(a + b)^c - a^c \geq c b a^{c-1}$ for $a > 0$, $b > 0$, and $c > 1$.
        have h_ineq : ∀ a b : ℝ, 0 < a → 0 < b → 1 < 1 / σ → (a + b) ^ (1 / σ) - a ^ (1 / σ) ≥ (1 / σ) * b * a ^ (1 / σ - 1) := by
          -- We'll use the mean value theorem to show that there exists some $c$ in the interval $(a, a + b)$ such that $(a + b)^{1/\sigma} - a^{1/\sigma} = (1/\sigma) * b * c^{1/\sigma - 1}$.
          intro a b ha hb hpos
          obtain ⟨c, hc⟩ : ∃ c ∈ Set.Ioo a (a + b), (a + b) ^ (1 / σ) - a ^ (1 / σ) = (1 / σ) * b * c ^ (1 / σ - 1) := by
            have := exists_deriv_eq_slope ( f := fun x => x ^ ( 1 / σ ) ) ( show a < a + b by linarith );
            norm_num +zetaDelta at *;
            exact this ( continuousOn_of_forall_continuousAt fun x hx => by exact ContinuousAt.rpow ( continuousAt_id ) continuousAt_const <| Or.inr <| by linarith ) ( fun x hx => by exact DifferentiableAt.differentiableWithinAt <| by exact DifferentiableAt.rpow ( differentiableAt_id ) ( by norm_num ) <| by linarith [ hx.1 ] ) |> fun ⟨ c, hc₁, hc₂ ⟩ => ⟨ c, hc₁, by rw [ eq_div_iff <| by linarith ] at hc₂; norm_num [ show c ≠ 0 by linarith ] at *; linarith ⟩;
          exact hc.2.symm ▸ mul_le_mul_of_nonneg_left ( Real.rpow_le_rpow ( by linarith ) ( by linarith [ hc.1.1 ] ) ( by linarith ) ) ( by positivity );
        filter_upwards [ Filter.eventually_gt_atTop 0 ] with k hk;
        have := h_ineq ( 2 * k * Real.pi + Real.pi / 6 ) ( 2 * Real.pi / 3 ) ( by positivity ) ( by positivity ) ( by rw [ lt_div_iff₀ hσpos ] ; linarith );
        ring_nf at this ⊢;
        refine le_trans ?_ this;
        field_simp;
        exact le_trans ( mul_le_of_le_one_left ( by positivity ) ( by linarith ) ) ( Real.rpow_le_rpow ( by positivity ) ( by nlinarith [ Real.pi_gt_three ] ) ( by exact div_nonneg ( by linarith ) ( by positivity ) ) );
      -- By dividing both sides of the inequality by $|ξ|^{1/σ}$, we obtain the desired result.
      have h_divided : ∀ᶠ k in Filter.atTop, (bk σ ξ k - ak σ ξ k) ≥ (2 * Real.pi / 3) / |ξ| ^ (1 / σ) * (2 * k * Real.pi) ^ (1 / σ - 1) := by
        have h_divided : ∀ᶠ k in Filter.atTop, (bk σ ξ k - ak σ ξ k) = ((2 * k * Real.pi + 5 * Real.pi / 6) ^ (1 / σ) - (2 * k * Real.pi + Real.pi / 6) ^ (1 / σ)) / |ξ| ^ (1 / σ) := by
          simp [bk, ak];
          exact ⟨ 1, fun n hn => by rw [ Real.div_rpow ( by positivity ) ( by positivity ), Real.div_rpow ( by positivity ) ( by positivity ) ] ; ring ⟩;
        filter_upwards [ h_divided, h_diff_simplified.natCast_atTop ] with k hk₁ hk₂ using by rw [ hk₁ ] ; exact by rw [ div_mul_eq_mul_div ] ; exact div_le_div_of_nonneg_right ( by linarith ) ( by positivity ) ;
      filter_upwards [ h_divided, Filter.eventually_gt_atTop 0 ] with k hk₁ hk₂;
      exact le_trans ( mul_le_mul_of_nonneg_left ( Real.rpow_le_rpow ( by positivity ) ( by nlinarith [ Real.pi_gt_three, show ( k : ℝ ) ≥ 1 by norm_cast ] ) ( by exact sub_nonneg_of_le <| by rw [ le_div_iff₀ <| by positivity ] ; linarith ) ) <| by positivity ) hk₁
    exact ⟨ _, by positivity, h_length_factor ⟩;
  exact h_length_factor

/-
The number of integers in Ik grows at least as fast as k^(1/σ - 1).
-/
lemma card_Ik_ge (σ ξ : ℝ) (hσpos : 0 < σ) (hσlt1 : σ < 1) (hξ_ne_zero : ξ ≠ 0) :
    ∃ C > 0, ∀ᶠ k in Filter.atTop, (Ik σ ξ k).card ≥ C * (k : ℝ) ^ (1 / σ - 1) := by
  -- By Lemma~\ref{lem:len_interval_ge}, $bk - ak \geq C k^{1/\sigma - 1}$ for some $C > 0$.
  obtain ⟨C, hC_pos, hC⟩ : ∃ C > 0, ∀ᶠ k in Filter.atTop, bk σ ξ k - ak σ ξ k ≥ C * (k : ℝ) ^ (1 / σ - 1) := by
    exact?;
  -- Let $N_k$ be the number of integers in the interval $[ak, bk]$.
  set Nk := fun k => Finset.card (Ik σ ξ k);
  -- Since $N_k \geq bk - ak - 1$, we have $N_k \geq C k^{1/\sigma - 1} - 1$.
  have hNk_ge : ∀ᶠ k in Filter.atTop, (Nk k : ℝ) ≥ (bk σ ξ k - ak σ ξ k) - 1 := by
    have hNk_ge : ∀ᶠ k in Filter.atTop, (Nk k : ℝ) ≥ (Nat.floor (bk σ ξ k) - Nat.ceil (ak σ ξ k) + 1 : ℝ) := by
      simp +zetaDelta at *;
      use 0; intro k hk; rw [ show Ik σ ξ k = Finset.Icc ( Nat.ceil ( ak σ ξ k ) ) ( Nat.floor ( bk σ ξ k ) ) from rfl ] ; norm_num;
      rw [ Nat.cast_sub ] <;> norm_num;
      · linarith;
      · exact le_trans ( show ak σ ξ k ≤ bk σ ξ k from by exact Real.rpow_le_rpow ( by positivity ) ( by gcongr ; linarith [ Real.pi_pos ] ) ( by positivity ) ) ( Nat.lt_floor_add_one _ |> le_of_lt );
    filter_upwards [ hNk_ge ] with k hk using by linarith [ Nat.floor_le ( show 0 ≤ bk σ ξ k from by exact Real.rpow_nonneg ( div_nonneg ( by nlinarith [ Real.pi_pos ] ) ( abs_nonneg ξ ) ) _ ), Nat.lt_floor_add_one ( bk σ ξ k ), Nat.le_ceil ( ak σ ξ k ), Nat.ceil_lt_add_one ( show 0 ≤ ak σ ξ k from by exact Real.rpow_nonneg ( div_nonneg ( by nlinarith [ Real.pi_pos ] ) ( abs_nonneg ξ ) ) _ ) ] ;
  -- Since $C k^{1/\sigma - 1} - 1 \geq \frac{C}{2} k^{1/\sigma - 1}$ for sufficiently large $k$, we can choose $C' = \frac{C}{2}$.
  obtain ⟨k₀, hk₀⟩ : ∃ k₀ : ℕ, ∀ k ≥ k₀, C * (k : ℝ) ^ (1 / σ - 1) - 1 ≥ (C / 2) * (k : ℝ) ^ (1 / σ - 1) := by
    have h_lim_inf : Filter.Tendsto (fun k : ℕ => C * (k : ℝ) ^ (1 / σ - 1)) Filter.atTop Filter.atTop := by
      exact Filter.Tendsto.const_mul_atTop hC_pos ( tendsto_rpow_atTop ( by nlinarith [ one_div_mul_cancel hσpos.ne' ] ) |> Filter.Tendsto.comp <| tendsto_natCast_atTop_atTop );
    exact Filter.eventually_atTop.mp ( h_lim_inf.eventually_gt_atTop 2 ) |> fun ⟨ k₀, hk₀ ⟩ ↦ ⟨ k₀, fun k hk ↦ by linarith [ hk₀ k hk ] ⟩;
  exact ⟨ C / 2, half_pos hC_pos, by filter_upwards [ hC, hNk_ge, Filter.eventually_ge_atTop k₀ ] with k hk₁ hk₂ hk₃ using by linarith [ hk₀ k hk₃ ] ⟩

/-
On Ik, |sin(n^σ ξ)| ≥ 1/2.
-/
lemma sin_bound_on_Ik (σ ξ : ℝ) (hσpos : 0 < σ) (hξ_ne_zero : ξ ≠ 0) (k : ℕ) (n : ℕ) (hn : n ∈ Ik σ ξ k) :
    1 / 2 ≤ |Real.sin ((n : ℝ) ^ σ * ξ)| := by
      -- Since $a_k \leq n \leq b_k$, we have $\alpha_k \leq n^\sigma |\xi| \leq \beta_k$.
      have h_bounds : (2 * k * Real.pi + Real.pi / 6) ≤ |ξ| * (n : ℝ) ^ σ ∧ |ξ| * (n : ℝ) ^ σ ≤ (2 * k * Real.pi + 5 * Real.pi / 6) := by
        have h_bounds : (ak σ ξ k) ^ σ * |ξ| ≤ (n : ℝ) ^ σ * |ξ| ∧ (n : ℝ) ^ σ * |ξ| ≤ (bk σ ξ k) ^ σ * |ξ| := by
          constructor <;> gcongr;
          · exact Real.rpow_nonneg ( div_nonneg ( by positivity ) ( abs_nonneg ξ ) ) _;
          · exact Nat.ceil_le.mp ( Finset.mem_Icc.mp hn |>.1 );
          · exact Nat.floor_le ( by exact Real.rpow_nonneg ( div_nonneg ( by positivity ) ( abs_nonneg _ ) ) _ ) |> le_trans ( Nat.cast_le.mpr <| Finset.mem_Icc.mp hn |>.2 );
        unfold ak bk at *;
        rw [ ← Real.rpow_mul ( by positivity ), ← Real.rpow_mul ( by positivity ) ] at * ; norm_num [ hσpos.ne' ] at * ; constructor <;> nlinarith [ abs_pos.mpr hξ_ne_zero, mul_div_cancel₀ ( 2 * k * Real.pi + Real.pi / 6 ) ( ne_of_gt ( abs_pos.mpr hξ_ne_zero ) ), mul_div_cancel₀ ( 2 * k * Real.pi + 5 * Real.pi / 6 ) ( ne_of_gt ( abs_pos.mpr hξ_ne_zero ) ) ];
      -- Since $|\sin(x)| \geq \frac{1}{2}$ for $2k\pi + \frac{\pi}{6} \leq x \leq 2k\pi + \frac{5\pi}{6}$, we have $|\sin(n^\sigma |\xi|)| \geq \frac{1}{2}$.
      have h_sin_bound : ∀ x : ℝ, 2 * k * Real.pi + Real.pi / 6 ≤ x ∧ x ≤ 2 * k * Real.pi + 5 * Real.pi / 6 → |Real.sin x| ≥ 1 / 2 := by
        intros x hx
        have h_sin_bound : Real.sin (x - 2 * k * Real.pi) ≥ 1 / 2 := by
          by_cases h_case : x - 2 * k * Real.pi ≤ Real.pi / 2;
          · rw [ ← Real.cos_pi_div_two_sub ] ; rw [ ← Real.cos_pi_div_three ] ; exact Real.cos_le_cos_of_nonneg_of_le_pi ( by linarith ) ( by linarith ) ( by linarith ) ;
          · rw [ ← Real.cos_sub_pi_div_two ] ; exact Real.cos_pi_div_three ▸ Real.cos_le_cos_of_nonneg_of_le_pi ( by linarith ) ( by linarith ) ( by linarith );
        simpa [ mul_assoc, mul_left_comm ] using h_sin_bound.trans ( le_abs_self _ );
      cases abs_cases ξ <;> simp_all +decide [ mul_comm ];
      convert h_sin_bound ( - ( ξ * ( n : ℝ ) ^ σ ) ) ( by linarith ) ( by linarith ) using 1 ; norm_num [ Real.sin_neg ]

/-
Lower bound for the sum over the interval Ik.
-/
lemma sum_Ik_ge (σ ξ r : ℝ) (hσpos : 0 < σ) (hξ_ne_zero : ξ ≠ 0) (hr : r ≤ 1) (k : ℕ) :
    ∑ n ∈ Ik σ ξ k, |Real.sin ((n : ℝ) ^ σ * ξ) / (n : ℝ) ^ r| ≥ (Ik σ ξ k).card * (1 / (2 * (bk σ ξ k))) := by
  -- For each $n \in I_k$, we have $|\sin(n^\sigma \xi)| \geq 1/2$ and $n \leq b_k$.
  have h_term_bound : ∀ n ∈ Ik σ ξ k, |Real.sin ((n : ℝ) ^ σ * ξ) / (n : ℝ) ^ r| ≥ (1 / 2) / (bk σ ξ k) := by
    intro n hn
    have h_sin_bound : |Real.sin ((n : ℝ) ^ σ * ξ)| ≥ 1 / 2 := by
      exact?
    have h_n_bound : (n : ℝ) ≤ bk σ ξ k := by
      exact Nat.floor_le ( show 0 ≤ bk σ ξ k from Real.rpow_nonneg ( div_nonneg ( by positivity ) ( abs_nonneg ξ ) ) _ ) |> le_trans ( Nat.cast_le.mpr <| Finset.mem_Icc.mp hn |>.2 )
    have h_r_bound : (n : ℝ) ^ r ≤ bk σ ξ k := by
      by_cases hn_zero : n = 0;
      · norm_num [ hn_zero, hσpos.ne' ] at *;
      · exact le_trans ( Real.rpow_le_rpow_of_exponent_le ( mod_cast Nat.one_le_iff_ne_zero.mpr hn_zero ) hr ) ( by simpa using h_n_bound )
    have h_term_bound : |Real.sin ((n : ℝ) ^ σ * ξ) / (n : ℝ) ^ r| ≥ (1 / 2) / (bk σ ξ k) := by
      rw [ abs_div, abs_of_nonneg ( Real.rpow_nonneg ( Nat.cast_nonneg _ ) _ ) ];
      gcongr;
      by_cases hn_zero : n = 0;
      · norm_num [ hn_zero, hσpos.ne' ] at *;
      · positivity
    exact h_term_bound;
  simpa [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ] using Finset.sum_le_sum h_term_bound

/-
Upper bound for bk.
-/
lemma bk_le (σ ξ : ℝ) (hσpos : 0 < σ) (hξ_ne_zero : ξ ≠ 0) :
    ∃ C > 0, ∀ᶠ k in Filter.atTop, bk σ ξ k ≤ C * (k : ℝ) ^ (1 / σ) := by
  -- We can choose $C = \left(\frac{2\pi + \frac{5\pi}{6}}{|\xi|}\right)^{1/\sigma}$.
  use ((2 * Real.pi + 5 * Real.pi / 6) / |ξ|) ^ (1 / σ);
  refine' ⟨ Real.rpow_pos_of_pos ( div_pos ( by positivity ) ( abs_pos.mpr hξ_ne_zero ) ) _, _ ⟩;
  filter_upwards [ Filter.eventually_gt_atTop 0 ] with k hk;
  rw [ ← Real.mul_rpow ( by positivity ) ( by positivity ) ];
  exact Real.rpow_le_rpow ( by positivity ) ( by rw [ div_mul_eq_mul_div, div_le_div_iff_of_pos_right ( by positivity ) ] ; nlinarith [ Real.pi_pos, show ( k : ℝ ) ≥ 1 by norm_cast ] ) ( by positivity )

/-
The sum over Ik is at least C/k for large k.
-/
lemma sum_Ik_ge_inv_k (σ ξ r : ℝ) (hσpos : 0 < σ) (hσlt1 : σ < 1) (hξ_ne_zero : ξ ≠ 0) (hr : r ≤ 1) :
    ∃ C > 0, ∀ᶠ k in Filter.atTop, ∑ n ∈ Ik σ ξ k, |Real.sin ((n : ℝ) ^ σ * ξ) / (n : ℝ) ^ r| ≥ C / k := by
      -- Using the bounds from the lemmas, we can combine them to get the desired inequality.
      obtain ⟨C1, hC1_pos, hC1⟩ := card_Ik_ge σ ξ hσpos hσlt1 hξ_ne_zero
      obtain ⟨C2, hC2_pos, hC2⟩ := bk_le σ ξ hσpos hξ_ne_zero;
      -- Substitute the bounds from card_Ik_ge and bk_le into the inequality from sum_Ik_ge.
      have h_subst : ∀ᶠ k in Filter.atTop, ∑ n ∈ Ik σ ξ k, |Real.sin ((n : ℝ) ^ σ * ξ) / (n : ℝ) ^ r| ≥ (C1 * (k : ℝ) ^ (1 / σ - 1)) * (1 / (2 * (C2 * (k : ℝ) ^ (1 / σ)))) := by
        filter_upwards [ hC1, hC2 ] with k hk₁ hk₂;
        refine' le_trans _ ( sum_Ik_ge σ ξ r hσpos hξ_ne_zero hr k );
        gcongr;
        exact mul_pos zero_lt_two ( Real.rpow_pos_of_pos ( div_pos ( by positivity ) ( abs_pos.mpr hξ_ne_zero ) ) _ );
      -- Simplify the expression to get the desired inequality.
      have h_simplify : ∀ᶠ k in Filter.atTop, ∑ n ∈ Ik σ ξ k, |Real.sin ((n : ℝ) ^ σ * ξ) / (n : ℝ) ^ r| ≥ (C1 / (2 * C2)) / (k : ℝ) := by
        filter_upwards [ h_subst, Filter.eventually_gt_atTop 0 ] with k hk hk' ; convert hk using 1 ; ring;
        norm_num [ Real.rpow_add ( Nat.cast_pos.mpr hk' ), Real.rpow_neg_one ] ; ring;
        rw [ mul_inv_cancel_right₀ ( by positivity ) ];
      exact ⟨ C1 / ( 2 * C2 ), by positivity, h_simplify ⟩

/-
If f is non-negative and summable, then the series of sums over disjoint finite sets is summable.
-/
lemma summable_sum_of_summable_disjoint_nonneg {f : ℕ → ℝ} (hf : Summable f) (hnonneg : ∀ n, 0 ≤ f n)
    {I : ℕ → Finset ℕ} (hI : ∀ k m, k ≠ m → Disjoint (I k) (I m)) :
    Summable (fun k ↦ ∑ n ∈ I k, f n) := by
      refine' summable_of_sum_le _ _;
      exact ∑' n, f n;
      · exact fun k => Finset.sum_nonneg fun _ _ => hnonneg _;
      · intro u;
        rw [ ← Finset.sum_biUnion ];
        · exact Summable.sum_le_tsum ( u.biUnion I ) ( fun _ _ => hnonneg _ ) hf;
        · exact fun k hk m hm hkm => hI k m hkm

/-
If g(k) is eventually bounded below by C/k, then g is not summable.
-/
lemma not_summable_of_ge_inv_k {g : ℕ → ℝ} (hg : ∀ k, 0 ≤ g k) (h : ∃ C > 0, ∀ᶠ k in Filter.atTop, g k ≥ C / k) :
    ¬ Summable g := by
      -- Apply the comparison test with the harmonic series.
      obtain ⟨C, hC_pos, hC_bound⟩ := h
      have h_comparison : ¬ Summable (fun k : ℕ => C / (k : ℝ)) := by
        erw [ summable_mul_left_iff ] <;> norm_num [ hC_pos.ne' ];
        exact_mod_cast Real.not_summable_natCast_inv;
      contrapose! h_comparison;
      rw [ ← summable_nat_add_iff ( Nat.find <| Filter.eventually_atTop.mp hC_bound ) ] at *;
      exact Summable.of_nonneg_of_le ( fun n => div_nonneg hC_pos.le <| Nat.cast_nonneg _ ) ( fun n => Nat.find_spec ( Filter.eventually_atTop.mp hC_bound ) _ <| Nat.le_add_left _ _ ) h_comparison

/-
If r ≤ 1, the series diverges.
-/
theorem problem_177_diverges (σ r ξ : ℝ) (hσpos : 0 < σ) (hσlt1 : σ < 1) (hξ_ne_zero : ξ ≠ 0) (hr : r ≤ 1) :
    ¬ Summable fun (n : ℕ) ↦ |Real.sin (((n : ℝ) ^ σ) * ξ) / ((n : ℝ) ^ r)| := by
  contrapose! hr;
  -- By `summable_sum_of_summable_disjoint_nonneg` and `Ik_disjoint`, $g$ is summable.
  have h_summable : Summable (fun k : ℕ => ∑ n ∈ Ik σ ξ k, |Real.sin ((n : ℝ) ^ σ * ξ) / (n : ℝ) ^ r|) := by
    refine' summable_sum_of_summable_disjoint_nonneg hr ( fun n => abs_nonneg _ ) _;
    intro k m hkm; cases lt_or_gt_of_ne hkm <;> [ exact Ik_disjoint σ ξ hσpos hξ_ne_zero _ _ ‹_› ; exact Disjoint.symm ( Ik_disjoint σ ξ hσpos hξ_ne_zero _ _ ‹_› ) ] ;
  have := @not_summable_of_ge_inv_k;
  exact not_le.mp fun h => this ( fun k => Finset.sum_nonneg fun _ _ => abs_nonneg _ ) ( by simpa using sum_Ik_ge_inv_k σ ξ r hσpos hσlt1 hξ_ne_zero h ) h_summable

/-
The series converges absolutely if and only if r > 1.
-/
theorem problem_177 (σ r ξ : ℝ) (hσpos : 0 < σ) (hσlt1 : σ < 1) (hξ_ne_zero : ξ ≠ 0) :
    (Summable fun (n : ℕ) ↦ |Real.sin (((n : ℝ) ^ σ) * ξ) / ((n : ℝ) ^ r)|) ↔ r > 1 := by
  constructor
  · intro h
    by_contra h_le
    have hr : r ≤ 1 := not_lt.mp h_le
    exact problem_177_diverges σ r ξ hσpos hσlt1 hξ_ne_zero hr h
  · intro h
    exact problem_177_converges σ r ξ hσpos hσlt1 hξ_ne_zero h