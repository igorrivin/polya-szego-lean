/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 27e3c8fd-5df4-4de2-b21d-1e325aaec5da
-/

/-
We have formalized and proved Polya-Szego Problems 105 and 106.

Problem 105 states that for a properly integrable function $f$ on $[a, b]$, $\lim_{n \to \infty} \int_a^b f(x) \sin(nx) dx = 0$. This is the Riemann-Lebesgue lemma, which we proved using the Mathlib version `Real.tendsto_integral_exp_smul_cocompact`.

Problem 106 states that $\lim_{n \to \infty} \int_a^b f(x) |\sin(nx)| dx = \frac{2}{\pi} \int_a^b f(x) dx$. We proved this by:
1.  Proving it for polynomials using the fact that $|\sin(nx)| - \frac{2}{\pi}$ has mean zero and applying integration by parts (or rather, the Riemann-Lebesgue lemma for the oscillating part).
2.  Approximating the continuous function $f$ by polynomials using the Weierstrass approximation theorem.
3.  Bounding the error terms to show convergence.

The formalization uses Lebesgue integration (`IntervalIntegrable` with `volume` measure) and assumes $f$ is continuous for Problem 106 to facilitate the polynomial approximation argument. The limits are taken as $n \to \infty$ in $\mathbb{N}$.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Checking Filter.Tendsto
-/
#check Filter.Tendsto

/-
Checking MeasureTheory.volume
-/
#check MeasureTheory.volume

/-
Checking IntervalIntegrable
-/
#check IntervalIntegrable

/-
Checking availability of Riemann-Lebesgue lemma and Real constants
-/
#check Real.tendsto_integral_exp_smul_cocompact
#check Real.sin
#check Real.pi

/-
Checking nhds and atTop
-/
#check nhds
#check Filter.atTop

/-
Problem 105: Riemann-Lebesgue lemma for sine
-/
theorem problem_105 {a b : ℝ} (hab : a ≤ b) {f : ℝ → ℝ} (hf : IntervalIntegrable f MeasureTheory.volume a b) :
    Filter.Tendsto (λ n : ℕ ↦ ∫ x in a..b, f x * Real.sin (n * x)) Filter.atTop (nhds 0) := by
  -- By the Riemann-Lebesgue lemma, the integral of $f(x) \exp(inx)$ over $[a, b]$ tends to $0$ as $n \to \infty$.
  have h_riemann_lebesgue : Filter.Tendsto (fun n : ℕ => ∫ x in a..b, f x * Complex.exp (↑n * x * Complex.I)) Filter.atTop (nhds 0) := by
    have := @Real.tendsto_integral_exp_smul_cocompact;
    specialize this ( fun x => if x ∈ Set.Icc a b then ( f x : ℂ ) else 0 );
    simp_all +decide [ Real.fourierChar, intervalIntegral.integral_of_le hab ];
    convert this.1.comp ( show Filter.Tendsto ( fun n : ℕ => - ( n : ℝ ) / ( 2 * Real.pi ) ) Filter.atTop Filter.atBot from Filter.tendsto_atTop_atBot.mpr _ ) using 2;
    · rw [ ← MeasureTheory.integral_Icc_eq_integral_Ioc, ← MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
      norm_num [ mul_assoc, mul_comm, mul_left_comm, div_eq_mul_inv, Real.pi_ne_zero, Circle.smul_def ];
    · exact fun x => ⟨ Nat.ceil ( -x * ( 2 * Real.pi ) ), fun n hn => by rw [ div_le_iff₀ ( by positivity ) ] ; nlinarith [ Nat.ceil_le.mp hn, Real.pi_pos ] ⟩;
  -- The integral of $f(x) \sin(nx)$ is the imaginary part of the integral of $f(x) \exp(inx)$.
  have h_im : ∀ n : ℕ, ∫ x in a..b, f x * Real.sin (↑n * x) = Complex.im (∫ x in a..b, f x * Complex.exp (↑n * x * Complex.I)) := by
    intro n
    have h_im : ∫ x in a..b, f x * Real.sin (↑n * x) = Complex.im (∫ x in a..b, f x * Complex.exp (↑n * x * Complex.I)) := by
      have h_eq : ∀ x : ℝ, f x * Real.sin (↑n * x) = Complex.im (f x * Complex.exp (↑n * x * Complex.I)) := by
        norm_num [ Complex.exp_im ]
      simp +decide only [intervalIntegral.integral_of_le hab];
      rw [ MeasureTheory.integral_congr_ae ( Filter.Eventually.of_forall h_eq ) ];
      convert ( integral_im _ );
      any_goals tauto;
      refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => |f x|;
      · exact MeasureTheory.Integrable.abs ( hf.1 );
      · exact MeasureTheory.AEStronglyMeasurable.mul ( Complex.continuous_ofReal.comp_aestronglyMeasurable ( hf.1.aestronglyMeasurable ) ) ( Continuous.aestronglyMeasurable ( by continuity ) );
      · norm_num [ Complex.norm_exp ];
    exact h_im;
  simpa only [ h_im, Complex.zero_im ] using Filter.Tendsto.comp ( Complex.continuous_im.tendsto 0 ) h_riemann_lebesgue

/-
Checking Set.uIcc
-/
#check Set.uIcc

/-
Checking Function.Periodic and integral of |sin x|
-/
#check Function.Periodic
example : ∫ x in (0)..Real.pi, |Real.sin x| = 2 := by
  rw [ intervalIntegral.integral_of_le Real.pi_pos.le ];
  rw [ MeasureTheory.setIntegral_congr_fun measurableSet_Ioc fun x hx => abs_of_nonneg ( Real.sin_nonneg_of_nonneg_of_le_pi hx.1.le hx.2 ), ← intervalIntegral.integral_of_le Real.pi_pos.le ] ; norm_num

/-
Helper lemma: The limit of the integral of |sin(nx)| over [a, b] is (2/π)(b-a).
-/
theorem lemma_106_const {a b : ℝ} (hab : a ≤ b) :
    Filter.Tendsto (λ n : ℕ ↦ ∫ x in a..b, |Real.sin (n * x)|) Filter.atTop
      (nhds ((2/Real.pi) * (b - a))) := by
  -- The integral of |sin(nx)| over [a, b] can be rewritten as an integral over [0, π] scaled by n.
  suffices h_scale : Filter.Tendsto (fun n : ℕ => ∫ x in (n * a)..n * b, |Real.sin x| / n) Filter.atTop (nhds (2 / Real.pi * (b - a))) by
    refine h_scale.congr' ?_ ; filter_upwards [ Filter.eventually_ne_atTop 0 ] with n hn ; simp +decide [ div_eq_inv_mul, intervalIntegral.integral_comp_mul_left, hn ];
    rw [ intervalIntegral.integral_comp_mul_left ( fun x => |Real.sin x| ) ] <;> norm_num [ hn ];
  -- We'll use the fact that the integral of |sin(x)| over [n*a, n*b] can be split into the sum of integrals over intervals of length π.
  have h_split : ∀ n : ℕ, n > 0 → ∫ x in (n * a)..n * b, |Real.sin x| = ∑ k ∈ Finset.range (Nat.floor (n * (b - a) / Real.pi)), (∫ x in (n * a + k * Real.pi).. (n * a + (k + 1) * Real.pi), |Real.sin x|) + ∫ x in (n * a + Nat.floor (n * (b - a) / Real.pi) * Real.pi)..n * b, |Real.sin x| := by
    intro n hn_pos
    have h_split : ∀ k : ℕ, k ≤ Nat.floor (n * (b - a) / Real.pi) → ∫ x in (n * a).. (n * a + k * Real.pi), |Real.sin x| = ∑ j ∈ Finset.range k, (∫ x in (n * a + j * Real.pi).. (n * a + (j + 1) * Real.pi), |Real.sin x|) := by
      intro k hk_le; induction' k with k ih <;> simp_all +decide [ add_mul, Finset.sum_range_succ ] ;
      rw [ ← ih ( Nat.le_of_succ_le hk_le ), intervalIntegral.integral_add_adjacent_intervals ] <;> exact Continuous.intervalIntegrable ( by continuity ) _ _;
    rw [ ← h_split _ le_rfl, intervalIntegral.integral_add_adjacent_intervals ] <;> exact Continuous.intervalIntegrable ( by continuity ) _ _;
  -- The integral of |sin(x)| over [n*a + k*π, n*a + (k+1)*π] is equal to the integral over [0, π], which is 2.
  have h_integral : ∀ n : ℕ, n > 0 → ∀ k : ℕ, ∫ x in (n * a + k * Real.pi).. (n * a + (k + 1) * Real.pi), |Real.sin x| = 2 := by
    -- The integral of |sin(x)| over [n*a + k*π, n*a + (k+1)*π] is equal to the integral over [0, π], which is 2. This follows from the periodicity of the sine function.
    intros n hn k
    have h_periodic : ∫ x in (n * a + k * Real.pi).. (n * a + (k + 1) * Real.pi), |Real.sin x| = ∫ x in (0)..Real.pi, |Real.sin x| := by
      have h_periodic : ∀ k : ℕ, ∫ x in (n * a + k * Real.pi).. (n * a + (k + 1) * Real.pi), |Real.sin x| = ∫ x in (n * a).. (n * a + Real.pi), |Real.sin x| := by
        intro k; convert intervalIntegral.integral_comp_add_right _ ( -k * Real.pi ) using 2 <;> ring;
        norm_num [ Real.sin_sub ];
        norm_num [ abs_mul, Real.abs_cos_eq_sqrt_one_sub_sin_sq ];
      rw [ h_periodic k ];
      -- By periodicity, we can split the integral into two parts:
      have h_split : ∫ x in (n * a).. (n * a + Real.pi), |Real.sin x| = (∫ x in (n * a)..0, |Real.sin x|) + (∫ x in (0)..Real.pi, |Real.sin x|) + (∫ x in (Real.pi).. (n * a + Real.pi), |Real.sin x|) := by
        rw [ intervalIntegral.integral_add_adjacent_intervals, intervalIntegral.integral_add_adjacent_intervals ] <;> exact Continuous.intervalIntegrable ( by continuity ) _ _;
      -- By periodicity, we can shift the interval of integration.
      have h_shift : ∫ x in (Real.pi).. (n * a + Real.pi), |Real.sin x| = ∫ x in (0).. (n * a), |Real.sin x| := by
        convert intervalIntegral.integral_comp_sub_right _ π using 2 <;> norm_num;
      rw [ h_split, h_shift ];
      rw [ intervalIntegral.integral_symm ] ; ring;
    rw [ h_periodic, intervalIntegral.integral_congr fun x hx => abs_of_nonneg ( Real.sin_nonneg_of_nonneg_of_le_pi ( by linarith [ Set.mem_Icc.mp ( by simpa [ Real.pi_pos.le ] using hx ) ] ) ( by linarith [ Set.mem_Icc.mp ( by simpa [ Real.pi_pos.le ] using hx ) ] ) ) ] ; norm_num;
  -- The integral of |sin(x)| over [n*a + Nat.floor (n * (b - a) / Real.pi) * π, n * b] is bounded between 0 and 2.
  have h_remainder : ∀ n : ℕ, n > 0 → 0 ≤ ∫ x in (n * a + Nat.floor (n * (b - a) / Real.pi) * Real.pi)..n * b, |Real.sin x| ∧ ∫ x in (n * a + Nat.floor (n * (b - a) / Real.pi) * Real.pi)..n * b, |Real.sin x| ≤ 2 := by
    intros n hn_pos
    have h_remainder_bound : ∫ x in (n * a + Nat.floor (n * (b - a) / Real.pi) * Real.pi)..n * b, |Real.sin x| ≤ ∫ x in (n * a + Nat.floor (n * (b - a) / Real.pi) * Real.pi).. (n * a + (Nat.floor (n * (b - a) / Real.pi) + 1) * Real.pi), |Real.sin x| := by
      apply_rules [ intervalIntegral.integral_mono_interval ];
      · norm_num;
      · nlinarith [ Nat.floor_le ( show 0 ≤ ( n : ℝ ) * ( b - a ) / Real.pi by exact div_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg.mpr hab ) ) Real.pi_pos.le ), Real.pi_pos, mul_div_cancel₀ ( ( n : ℝ ) * ( b - a ) ) Real.pi_ne_zero ];
      · nlinarith [ Nat.lt_floor_add_one ( ( n : ℝ ) * ( b - a ) / Real.pi ), Real.pi_pos, mul_div_cancel₀ ( ( n : ℝ ) * ( b - a ) ) Real.pi_ne_zero ];
      · exact Filter.Eventually.of_forall fun x => abs_nonneg _;
      · exact Continuous.intervalIntegrable ( Real.continuous_sin.abs ) _ _;
    exact ⟨ intervalIntegral.integral_nonneg ( by nlinarith [ Nat.floor_le ( show 0 ≤ ( n : ℝ ) * ( b - a ) / Real.pi by exact div_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg.mpr hab ) ) Real.pi_pos.le ), Real.pi_pos, mul_div_cancel₀ ( ( n : ℝ ) * ( b - a ) ) Real.pi_ne_zero ] ) fun x hx => abs_nonneg _, h_remainder_bound.trans ( h_integral n hn_pos _ ▸ le_rfl ) ⟩;
  -- Using the results from h_split, h_integral, and h_remainder, we can bound the expression.
  have h_bound : ∀ n : ℕ, n > 0 → |(∫ x in (n * a)..n * b, |Real.sin x|) / n - (2 / Real.pi) * (b - a)| ≤ (2 / n) + (2 / n) := by
    intro n hn; rw [ h_split n hn ] ; norm_num [ h_integral n hn, h_remainder n hn ];
    rw [ abs_le ];
    field_simp;
    constructor <;> nlinarith [ Nat.floor_le ( show 0 ≤ ( n : ℝ ) * ( b - a ) / Real.pi by exact div_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg.mpr hab ) ) Real.pi_pos.le ), Nat.lt_floor_add_one ( ( n : ℝ ) * ( b - a ) / Real.pi ), Real.pi_pos, mul_div_cancel₀ ( ( n : ℝ ) * ( b - a ) ) Real.pi_ne_zero, h_remainder n hn, show ( ∫ x in ( n * a + Real.pi * ⌊ ( n : ℝ ) * ( b - a ) / Real.pi⌋₊ ).. ( n * b ), |Real.sin x| ) = ∫ x in ( n * a + ⌊ ( n : ℝ ) * ( b - a ) / Real.pi⌋₊ * Real.pi ).. ( n * b ), |Real.sin x| by ac_rfl ];
  exact tendsto_iff_norm_sub_tendsto_zero.mpr <| squeeze_zero_norm' ( Filter.eventually_atTop.mpr ⟨ 1, fun n hn => by simpa using h_bound n hn ⟩ ) <| by simpa using Filter.Tendsto.add ( tendsto_const_nhds.mul tendsto_inverse_atTop_nhds_zero_nat ) ( tendsto_const_nhds.mul tendsto_inverse_atTop_nhds_zero_nat ) ;

/-
Helper lemma: The integral of |sin u| - 2/π is bounded.
-/
theorem lemma_sine_integral_bounded :
    ∃ C, ∀ y : ℝ, |∫ u in 0..y, (|Real.sin u| - 2 / Real.pi)| ≤ C := by
      -- The integral of |sin u| - 2/π over any interval of length π is zero.
      have h_integral_zero : ∀ k : ℤ, ∫ u in (0)..k * Real.pi, |Real.sin u| - 2 / Real.pi = 0 := by
        -- We'll use the fact that |sin u| is periodic with period π and symmetric around π/2.
        have h_periodic : ∀ k : ℤ, ∫ u in (0)..k * Real.pi, |Real.sin u| = k * ∫ u in (0)..Real.pi, |Real.sin u| := by
          -- We can prove this by induction on $k$.
          intro k
          induction' k using Int.induction_on with k hk;
          · norm_num;
          · -- For the induction step, we can split the integral at $k\pi$ and use the periodicity of $|\sin u|$.
            have h_split : ∫ u in (0)..((k + 1) : ℝ) * Real.pi, |Real.sin u| = (∫ u in (0)..(k : ℝ) * Real.pi, |Real.sin u|) + (∫ u in (k : ℝ) * Real.pi..((k + 1) : ℝ) * Real.pi, |Real.sin u|) := by
              rw [ intervalIntegral.integral_add_adjacent_intervals ] <;> exact Continuous.intervalIntegrable ( by continuity ) _ _;
            -- By the periodicity of $|\sin u|$, we have $\int_{k\pi}^{(k+1)\pi} |\sin u| \, du = \int_{0}^{\pi} |\sin u| \, du$.
            have h_periodic : ∀ k : ℤ, ∫ u in (k : ℝ) * Real.pi..((k + 1) : ℝ) * Real.pi, |Real.sin u| = ∫ u in (0)..Real.pi, |Real.sin u| := by
              intro k; convert intervalIntegral.integral_comp_add_right _ ( -k * Real.pi ) using 2 <;> ring;
              norm_num [ Real.sin_sub ];
            have := h_periodic k; norm_num at *; linarith;
          · -- By the properties of integrals, we can split the integral at $-i\pi$.
            have h_split : ∫ u in (0)..(-(↑‹ℕ› : ℝ) - 1) * Real.pi, |Real.sin u| = (∫ u in (0)..(-(↑‹ℕ› : ℝ)) * Real.pi, |Real.sin u|) + (∫ u in (-(↑‹ℕ› : ℝ)) * Real.pi..(-(↑‹ℕ› : ℝ) - 1) * Real.pi, |Real.sin u|) := by
              rw [ intervalIntegral.integral_add_adjacent_intervals ] <;> exact Continuous.intervalIntegrable ( by continuity ) _ _;
            -- By the properties of integrals, we can split the integral at $-i\pi$ and use the periodicity of $|\sin u|$.
            have h_split : ∫ u in (-(↑‹ℕ› : ℝ)) * Real.pi..(-(↑‹ℕ› : ℝ) - 1) * Real.pi, |Real.sin u| = ∫ u in (0)..(-1) * Real.pi, |Real.sin u| := by
              convert intervalIntegral.integral_comp_add_right _ ( ↑‹ℕ› * Real.pi ) using 2 <;> ring;
              norm_num [ Real.sin_add ];
              norm_num [ abs_mul, Real.abs_cos_eq_sqrt_one_sub_sin_sq ];
            simp_all +decide [ sub_mul ];
            rw [ show ( ∫ u in ( 0 : ℝ )..-Real.pi, |Real.sin u| ) = - ( ∫ u in ( 0 : ℝ )..Real.pi, |Real.sin u| ) by rw [ ← intervalIntegral.integral_symm ] ; convert intervalIntegral.integral_comp_neg _ using 2 <;> norm_num ] ; ring;
        intro k; rw [ intervalIntegral.integral_sub ] <;> norm_num [ h_periodic ];
        · rw [ intervalIntegral.integral_congr fun x hx => abs_of_nonneg ( Real.sin_nonneg_of_nonneg_of_le_pi ( by linarith [ Set.mem_Icc.mp ( by simpa [ Real.pi_pos.le ] using hx ) ] ) ( by linarith [ Set.mem_Icc.mp ( by simpa [ Real.pi_pos.le ] using hx ) ] ) ) ] ; norm_num ; ring_nf ; norm_num [ Real.pi_ne_zero ];
        · exact Continuous.intervalIntegrable ( Real.continuous_sin.abs ) _ _;
      -- By periodicity, we can bound the integral over any interval [0, y] by the integral over [0, π].
      have h_bound : ∀ y : ℝ, |∫ u in (0)..y, |Real.sin u| - 2 / Real.pi| ≤ |∫ u in (0)..(y - ⌊y / Real.pi⌋ * Real.pi), |Real.sin u| - 2 / Real.pi| := by
        intro y
        have h_split : ∫ u in (0)..y, |Real.sin u| - 2 / Real.pi = (∫ u in (0)..(⌊y / Real.pi⌋ * Real.pi), |Real.sin u| - 2 / Real.pi) + (∫ u in (⌊y / Real.pi⌋ * Real.pi)..y, |Real.sin u| - 2 / Real.pi) := by
          rw [ intervalIntegral.integral_add_adjacent_intervals ] <;> exact Continuous.intervalIntegrable ( by continuity ) _ _;
        -- By periodicity, we can shift the interval of integration.
        have h_shift : ∫ u in (⌊y / Real.pi⌋ * Real.pi)..y, |Real.sin u| - 2 / Real.pi = ∫ u in (0)..(y - ⌊y / Real.pi⌋ * Real.pi), |Real.sin (u + ⌊y / Real.pi⌋ * Real.pi)| - 2 / Real.pi := by
          convert intervalIntegral.integral_comp_sub_right _ _ using 3 <;> ring;
        simp_all +decide [ Real.sin_add ];
      -- The integral of |sin u| - 2/π over [0, π] is bounded.
      have h_integral_bound : ∃ C : ℝ, ∀ y : ℝ, 0 ≤ y ∧ y ≤ Real.pi → |∫ u in (0)..y, |Real.sin u| - 2 / Real.pi| ≤ C := by
        have h_integral_bound : ContinuousOn (fun y => ∫ u in (0)..y, |Real.sin u| - 2 / Real.pi) (Set.Icc 0 Real.pi) := by
          fun_prop (disch := norm_num);
        exact ⟨ _, fun y hy => le_csSup ( IsCompact.bddAbove ( isCompact_Icc.image_of_continuousOn ( h_integral_bound.abs ) ) ) ( Set.mem_image_of_mem _ hy ) ⟩;
      exact ⟨ h_integral_bound.choose, fun y => le_trans ( h_bound y ) ( h_integral_bound.choose_spec _ ⟨ by nlinarith [ Int.floor_le ( y / Real.pi ), Real.pi_pos, mul_div_cancel₀ y Real.pi_ne_zero ], by nlinarith [ Int.lt_floor_add_one ( y / Real.pi ), Real.pi_pos, mul_div_cancel₀ y Real.pi_ne_zero ] ⟩ ) ⟩

/-
Helper lemma: The limit is 0 for polynomials.
-/
theorem lemma_poly_limit {a b : ℝ} (hab : a ≤ b) (P : Polynomial ℝ) :
    Filter.Tendsto (λ n : ℕ ↦ ∫ x in a..b, P.eval x * (|Real.sin (n * x)| - 2 / Real.pi)) Filter.atTop (nhds 0) := by
  -- We'll use the fact that |sin(nx)| - 2/π is bounded and apply the dominated convergence theorem.
  have h_bound : ∀ n : ℕ, ∫ x in a..b, P.eval x * (|Real.sin (n * x)| - 2 / Real.pi) = ∑ k ∈ P.support, P.coeff k * ∫ x in a..b, x^k * (|Real.sin (n * x)| - 2 / Real.pi) := by
    simp +decide [ Polynomial.eval_eq_sum, Polynomial.sum_def, mul_assoc, Finset.sum_mul _ _ _ ];
    intro n; rw [ intervalIntegral.integral_finset_sum ] ; aesop;
    exact fun i hi => Continuous.intervalIntegrable ( by continuity ) _ _;
  -- Using the fact that |sin(nx)| - 2/π is bounded, we can apply the dominated convergence theorem.
  have h_dominated : ∀ k ∈ P.support, Filter.Tendsto (fun n : ℕ ↦ ∫ x in a..b, x^k * (|Real.sin (n * x)| - 2 / Real.pi)) Filter.atTop (nhds 0) := by
    -- By integrating by parts, we can show that the integral of $x^k (|\sin(nx)| - 2/\pi)$ over $[a, b]$ tends to zero as $n$ tends to infinity.
    have h_int_parts : ∀ k ∈ P.support, Filter.Tendsto (fun n : ℕ ↦ ∫ x in a..b, x^k * (|Real.sin (n * x)| - 2 / Real.pi)) Filter.atTop (nhds 0) := by
      intro k hk
      have h_int_parts_step : ∀ n : ℕ, n ≠ 0 → ∫ x in a..b, x^k * (|Real.sin (n * x)| - 2 / Real.pi) = (1 / n) * (b^k * (∫ u in (0)..n * b, (|Real.sin u| - 2 / Real.pi)) - a^k * (∫ u in (0)..n * a, (|Real.sin u| - 2 / Real.pi))) - (k / n) * ∫ x in a..b, x^(k - 1) * (∫ u in (0)..n * x, (|Real.sin u| - 2 / Real.pi)) := by
        intro n hn_ne; rw [ intervalIntegral.integral_mul_deriv_eq_deriv_mul ] <;> norm_num [ hn_ne, mul_comm ];
        any_goals intro x hx; exact hasDerivAt_pow k x;
        rotate_right;
        use fun x => ( ∫ u in ( 0 : ℝ )..x * n, |Real.sin u| - 2 / Real.pi ) / n;
        · norm_num [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm, ← intervalIntegral.integral_const_mul ];
          norm_num [ mul_sub, mul_assoc, mul_comm, mul_left_comm, ← intervalIntegral.integral_const_mul ];
        · intro x hx; convert HasDerivAt.div_const ( HasDerivAt.comp x ( show HasDerivAt ( fun u => ∫ u in ( 0 : ℝ )..u, |Real.sin u| - 2 / Real.pi ) _ _ from ?_ ) ( hasDerivAt_mul_const _ ) ) _ using 1; aesop;
          apply_rules [ intervalIntegral.integral_hasDerivAt_right ];
          · exact Continuous.intervalIntegrable ( by continuity ) _ _;
          · exact Continuous.stronglyMeasurable ( by continuity ) |> fun h => h.stronglyMeasurableAtFilter;
          · exact ContinuousAt.sub ( Real.continuous_sin.continuousAt.abs ) ( continuousAt_const );
        · norm_num;
        · exact Continuous.intervalIntegrable ( by continuity ) _ _
      -- Since $\int_0^y (|\sin u| - 2/\pi) \, du$ is bounded, we can apply the dominated convergence theorem.
      have h_bounded : ∃ C : ℝ, ∀ y : ℝ, |∫ u in (0)..y, (|Real.sin u| - 2 / Real.pi)| ≤ C := by
        exact?;
      -- Using the boundedness of the integral, we can show that the limit of the integral is zero.
      obtain ⟨C, hC⟩ : ∃ C : ℝ, ∀ y : ℝ, |∫ u in (0)..y, (|Real.sin u| - 2 / Real.pi)| ≤ C := h_bounded;
      have h_limit_zero : Filter.Tendsto (fun n : ℕ => (1 / n) * (b^k * (∫ u in (0)..n * b, (|Real.sin u| - 2 / Real.pi)) - a^k * (∫ u in (0)..n * a, (|Real.sin u| - 2 / Real.pi)))) Filter.atTop (nhds 0) ∧ Filter.Tendsto (fun n : ℕ => (k / n) * ∫ x in a..b, x^(k - 1) * (∫ u in (0)..n * x, (|Real.sin u| - 2 / Real.pi))) Filter.atTop (nhds 0) := by
        constructor;
        · field_simp;
          norm_num [ mul_comm, sub_div ];
          exact le_trans ( Filter.Tendsto.sub ( squeeze_zero_norm ( fun n => by simpa [ abs_div, abs_mul ] using div_le_div_of_nonneg_right ( mul_le_mul_of_nonneg_left ( hC _ ) ( by positivity ) ) ( Nat.cast_nonneg _ ) ) ( by simpa using tendsto_const_nhds.mul ( tendsto_inverse_atTop_nhds_zero_nat ) ) ) ( squeeze_zero_norm ( fun n => by simpa [ abs_div, abs_mul ] using div_le_div_of_nonneg_right ( mul_le_mul_of_nonneg_left ( hC _ ) ( by positivity ) ) ( Nat.cast_nonneg _ ) ) ( by simpa using tendsto_const_nhds.mul ( tendsto_inverse_atTop_nhds_zero_nat ) ) ) ) ( by norm_num );
        · -- Using the boundedness of the integral, we can show that the limit of the integral is zero by the squeeze theorem.
          have h_squeeze : ∀ n : ℕ, |∫ x in a..b, x^(k - 1) * (∫ u in (0)..n * x, (|Real.sin u| - 2 / Real.pi))| ≤ C * ∫ x in a..b, |x^(k - 1)| := by
            intro n; rw [ intervalIntegral.integral_of_le hab ] ; rw [ intervalIntegral.integral_of_le hab ] ;
            rw [ ← MeasureTheory.integral_const_mul ];
            refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) ) ( MeasureTheory.integral_mono_of_nonneg _ _ _ );
            · exact Filter.Eventually.of_forall fun x => norm_nonneg _;
            · exact Continuous.integrableOn_Ioc ( by continuity );
            · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx using by simpa [ mul_comm, abs_mul ] using mul_le_mul_of_nonneg_left ( hC ( n * x ) ) ( by positivity ) ;
          exact squeeze_zero_norm ( fun n => by simpa [ abs_mul, abs_div ] using mul_le_mul_of_nonneg_left ( h_squeeze n ) ( by positivity ) ) ( by simpa using tendsto_const_nhds.mul ( tendsto_inverse_atTop_nhds_zero_nat ) |> Filter.Tendsto.mul_const ( C * ∫ x in a..b, |x ^ ( k - 1 )| ) );
      simpa using Filter.Tendsto.congr' ( by filter_upwards [ Filter.eventually_ne_atTop 0 ] with n hn; aesop ) ( h_limit_zero.1.sub h_limit_zero.2 );
    assumption;
  simpa [ h_bound ] using tendsto_finset_sum _ fun k hk => Filter.Tendsto.mul tendsto_const_nhds ( h_dominated k hk )

/-
Problem 106: Limit with absolute value of sine
-/
theorem problem_106 {a b : ℝ} (hab : a ≤ b) {f : ℝ → ℝ} (hf : IntervalIntegrable f MeasureTheory.volume a b)
    (hcont : ContinuousOn f (Set.uIcc a b)) :
    Filter.Tendsto (λ n : ℕ ↦ ∫ x in a..b, f x * |Real.sin (n * x)|) Filter.atTop
      (nhds ((2/Real.pi) * ∫ x in a..b, f x)) := by
        -- By the properties of the integral, we can bring the limit inside.
        have h_tendsto : Filter.Tendsto (fun n : ℕ => ∫ x in a..b, f x * (abs (Real.sin (n * x)) - 2 / Real.pi)) Filter.atTop (nhds 0) := by
          -- By the density of polynomials in the space of continuous functions, we can approximate $f$ uniformly by polynomials.
          have h_poly_approx : ∀ ε > 0, ∃ P : Polynomial ℝ, ∀ x ∈ Set.uIcc a b, abs (f x - P.eval x) < ε := by
            -- The Weierstrass approximation theorem states that any continuous function on a closed interval can be uniformly approximated by polynomials.
            have h_weierstrass : ∀ {g : ℝ → ℝ}, ContinuousOn g (Set.Icc a b) → ∀ ε > 0, ∃ P : Polynomial ℝ, ∀ x ∈ Set.Icc a b, |P.eval x - g x| < ε := by
              apply_rules [ exists_polynomial_near_of_continuousOn ];
            simpa only [ abs_sub_comm, Set.uIcc_of_le hab ] using h_weierstrass ( by simpa only [ Set.uIcc_of_le hab ] using hcont );
          -- Using the polynomial approximation, we can bound the difference between the integrals.
          have h_bound : ∀ ε > 0, ∃ P : Polynomial ℝ, ∀ n : ℕ, abs (∫ x in a..b, f x * (abs (Real.sin (n * x)) - 2 / Real.pi) - P.eval x * (abs (Real.sin (n * x)) - 2 / Real.pi)) ≤ ε * (b - a) * 2 := by
            intro ε hε_pos
            obtain ⟨P, hP⟩ := h_poly_approx ε hε_pos
            use P
            intro n
            have h_integral_bound : abs (∫ x in a..b, (f x - P.eval x) * (abs (Real.sin (n * x)) - 2 / Real.pi)) ≤ ε * (b - a) * 2 := by
              have h_integral_bound : ∀ x ∈ Set.uIcc a b, abs ((f x - P.eval x) * (abs (Real.sin (n * x)) - 2 / Real.pi)) ≤ ε * 2 := by
                intro x hx; rw [ abs_mul ] ; exact mul_le_mul ( le_of_lt ( hP x hx ) ) ( abs_le.mpr ⟨ by cases abs_cases ( Real.sin ( n * x ) ) <;> nlinarith [ Real.neg_one_le_sin ( n * x ), Real.sin_le_one ( n * x ), Real.pi_gt_three, mul_div_cancel₀ ( 2 : ℝ ) Real.pi_ne_zero ], by cases abs_cases ( Real.sin ( n * x ) ) <;> nlinarith [ Real.neg_one_le_sin ( n * x ), Real.sin_le_one ( n * x ), Real.pi_gt_three, mul_div_cancel₀ ( 2 : ℝ ) Real.pi_ne_zero ] ⟩ ) ( by positivity ) ( by positivity ) ;
              rw [ intervalIntegral.integral_of_le hab ];
              refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) ) ( le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ );
              refine' fun x => ε * 2;
              · exact Filter.Eventually.of_forall fun x => norm_nonneg _;
              · fun_prop;
              · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx using h_integral_bound x <| by rw [ Set.uIcc_of_le hab ] ; exact Set.Ioc_subset_Icc_self hx;
              · norm_num [ mul_assoc, mul_comm, mul_left_comm, hab ];
            simpa only [ sub_mul ] using h_integral_bound;
          -- Using the polynomial approximation, we can bound the difference between the integrals and apply the squeeze theorem.
          have h_squeeze : ∀ ε > 0, ∃ N : ℕ, ∀ n ≥ N, abs (∫ x in a..b, f x * (abs (Real.sin (n * x)) - 2 / Real.pi)) ≤ ε * (b - a) * 2 + ε := by
            intros ε hε_pos
            obtain ⟨P, hP⟩ := h_bound (ε / 3) (by linarith)
            obtain ⟨N, hN⟩ : ∃ N : ℕ, ∀ n ≥ N, abs (∫ x in a..b, P.eval x * (abs (Real.sin (n * x)) - 2 / Real.pi)) ≤ ε / 3 := by
              have := lemma_poly_limit hab P;
              simpa using this.eventually ( Metric.closedBall_mem_nhds _ <| by positivity );
            use N; intros n hn; specialize hP n; specialize hN n hn; rw [ intervalIntegral.integral_sub ] at hP <;> norm_num at *;
            · exact abs_le.mpr ⟨ by nlinarith [ abs_le.mp hP, abs_le.mp hN ], by nlinarith [ abs_le.mp hP, abs_le.mp hN ] ⟩;
            · apply_rules [ ContinuousOn.intervalIntegrable ];
              exact ContinuousOn.mul hcont ( ContinuousOn.sub ( ContinuousOn.abs ( Real.continuous_sin.comp_continuousOn ( continuousOn_const.mul continuousOn_id ) ) ) continuousOn_const );
            · exact Continuous.intervalIntegrable ( by exact Continuous.mul ( P.continuous ) ( by exact Continuous.sub ( Real.continuous_sin.abs.comp ( by continuity ) ) continuous_const ) ) _ _;
          rw [ Metric.tendsto_nhds ];
          norm_num +zetaDelta at *;
          exact fun ε hε => by obtain ⟨ N, hN ⟩ := h_squeeze ( ε / 3 / ( b - a + 1 ) ) ( by exact div_pos ( by positivity ) ( by linarith ) ) ; exact ⟨ N, fun n hn => lt_of_le_of_lt ( hN n hn ) ( by nlinarith [ mul_div_cancel₀ ( ε / 3 ) ( by linarith : ( b - a + 1 ) ≠ 0 ) ] ) ⟩ ;
        convert h_tendsto.add_const ( 2 / Real.pi * ∫ x in a..b, f x ) using 2 <;> norm_num [ mul_sub, ← mul_assoc, ← intervalIntegral.integral_const_mul ] ; ring;
        rw [ intervalIntegral.integral_sub ] <;> norm_num [ mul_assoc, mul_comm, mul_left_comm, hf ];
        exact hf.mul_continuousOn ( Continuous.continuousOn ( by continuity ) )

/-
Problem 106: Limit with absolute value of sine
-/
theorem problem_106' {a b : ℝ} (hab : a ≤ b) {f : ℝ → ℝ} (hf : IntervalIntegrable f MeasureTheory.volume a b)
    (hcont : ContinuousOn f (Set.uIcc a b)) :
    Filter.Tendsto (λ n : ℕ ↦ ∫ x in a..b, f x * |Real.sin (n * x)|) Filter.atTop
      (nhds ((2/Real.pi) * ∫ x in a..b, f x)) := by
        -- By the properties of the Riemann-Lebesgue lemma and the continuity of $f$, we can apply the lemma directly.
        apply problem_106 hab hf hcont

/-
Problem 106: Limit with absolute value of sine
-/
theorem problem_106_proved {a b : ℝ} (hab : a ≤ b) {f : ℝ → ℝ} (hf : IntervalIntegrable f MeasureTheory.volume a b)
    (hcont : ContinuousOn f (Set.uIcc a b)) :
    Filter.Tendsto (λ n : ℕ ↦ ∫ x in a..b, f x * |Real.sin ((n : ℝ) * x)|) Filter.atTop
      (nhds ((2/Real.pi) * ∫ x in a..b, f x)) := by
        convert @problem_106' a b hab f hf hcont using 1