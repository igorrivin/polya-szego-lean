/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e14d9d26-3062-46a2-8dc1-0956776d1c49

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Complex
open scoped ComplexConjugate

#check Lagrange.interpolate

#check SimplyConnectedSpace

def SimpleConnected (s : Set ℂ) : Prop := SimplyConnectedSpace s

#check ContinuousLinearMap.id ℂ ℂ

/-
Define the contour integral of a function f along a curve L as a placeholder.
-/
noncomputable def contourIntegral (L : Set ℂ) (f : ℂ → ℂ) : ℂ := Classical.choice (by
-- The complex numbers are nonempty since they contain the real numbers.
apply Nonempty.intro; exact 0)

/-
Define the polynomial ω(z) = Π (z - z_i).
-/
noncomputable def omega {n : ℕ} (z : Fin n → ℂ) : Polynomial ℂ := 
  Finset.prod Finset.univ (fun i => Polynomial.X - Polynomial.C (z i))

#check ContinuousLinearMap.smulRight

/-
Define the interpolating polynomial P for f at points z.
-/
noncomputable def interpolatingPoly {n : ℕ} (z : Fin n → ℂ) (f : ℂ → ℂ) : Polynomial ℂ :=
  Lagrange.interpolate Finset.univ z (f ∘ z)

/-
Define the kernel polynomial K(z) = (ω(ζ) - ω(z)) / (ζ - z) and prove its degree is < n.
-/
noncomputable def kernelPoly {n : ℕ} (z_pts : Fin n → ℂ) (ζ : ℂ) : Polynomial ℂ :=
  ((Polynomial.C ((omega z_pts).eval ζ)) - (omega z_pts)) /ₘ (Polynomial.C ζ - Polynomial.X)

lemma kernelPoly_degree {n : ℕ} (z_pts : Fin n → ℂ) (ζ : ℂ) :
  (kernelPoly z_pts ζ).degree < n := by
  unfold kernelPoly
  simp [omega];
  erw [ Polynomial.degree_lt_iff_coeff_zero ];
  rw [ show ( Polynomial.C ζ - Polynomial.X : Polynomial ℂ ) = - ( Polynomial.X - Polynomial.C ζ ) by ring, Polynomial.divByMonic ];
  unfold Polynomial.divModByMonicAux;
  norm_num +zetaDelta at *;
  split_ifs <;> norm_num;
  erw [ Polynomial.Monic.def, Polynomial.leadingCoeff_add_of_degree_lt ] at * <;> norm_num at *;
  · exact?;
  · exact lt_of_le_of_lt ( Polynomial.degree_C_le ) ( by erw [ Polynomial.degree_prod, Finset.sum_congr rfl fun i _ => Polynomial.degree_X_sub_C _ ] ; simpa using Nat.pos_of_ne_zero ( by aesop_cat ) )

#check circleIntegral

/-
Define the target polynomial P using the contour integral formula for its coefficients.
-/
noncomputable def targetPoly {n : ℕ} (z : Fin n → ℂ) (f : ℂ → ℂ) (c : ℂ) (R : ℝ) : Polynomial ℂ :=
  ∑ k ∈ Finset.range n, Polynomial.monomial k ((1 / (2 * ↑Real.pi * I)) * 
    ∮ ζ in C(c, R), (f ζ / (omega z).eval ζ) * (kernelPoly z ζ).coeff k)

/-
The degree of the interpolating polynomial is less than n.
-/
lemma interpolatingPoly_degree {n : ℕ} {z : Fin n → ℂ} (hz : Function.Injective z) (f : ℂ → ℂ) :
  (interpolatingPoly z f).degree < n := by
    unfold interpolatingPoly;
    erw [ Polynomial.degree_lt_iff_coeff_zero ];
    cases n <;> simp_all +decide [ Polynomial.coeff_eq_zero_of_natDegree_lt ];
    intro m hm; refine Finset.sum_eq_zero fun i _ => ?_; rw [ Polynomial.coeff_eq_zero_of_natDegree_lt ] ; aesop;
    rw [ @Lagrange.natDegree_basis ] ; aesop;
    · exact hz.injOn;
    · exact Finset.mem_univ i

/-
The degree of the target polynomial is less than n.
-/
lemma targetPoly_degree {n : ℕ} {z : Fin n → ℂ} (f : ℂ → ℂ) (c : ℂ) (R : ℝ) :
  (targetPoly z f c R).degree < n := by
    -- The sum of monomials up to degree n-1 has degree less than n.
    have h_deg : (targetPoly z f c R).degree < n := by
      have h_deg_mono : ∀ k ∈ Finset.range n, (Polynomial.monomial k ((1 / (2 * ↑Real.pi * I)) * ∮ ζ in C(c, R), (f ζ / (omega z).eval ζ) * (kernelPoly z ζ).coeff k)).degree < n := by
        intro k hk; by_cases h : ( 1 / ( 2 * Real.pi * Complex.I ) * ∮ ζ in C(c, R), f ζ / Polynomial.eval ζ ( omega z ) * ( kernelPoly z ζ |> Polynomial.coeff ) k ) = 0 <;> simp_all +decide [ Polynomial.degree_monomial ] ;
        exact WithBot.bot_lt_coe n
      refine' lt_of_le_of_lt ( Polynomial.degree_sum_le _ _ ) ( Finset.sup_lt_iff _ |>.2 _ );
      · exact WithBot.bot_lt_coe n;
      · aesop;
    exact?

/-
The circle integral of a sum is the sum of the circle integrals, given integrability.
-/
lemma circleIntegral_sum {ι : Type*} {s : Finset ι} {f : ι → ℂ → ℂ} {c : ℂ} {R : ℝ}
  (hf : ∀ i ∈ s, CircleIntegrable (f i) c R) :
  (∮ z in C(c, R), ∑ i ∈ s, f i z) = ∑ i ∈ s, ∮ z in C(c, R), f i z := by
    induction' s using Finset.induction with i s hi ih;
    · simp +decide [ circleIntegral ];
    · rw [ Finset.sum_insert hi, ← ih fun j hj => hf j ( Finset.mem_insert_of_mem hj ) ];
      rw [ ← circleIntegral.integral_add ];
      · simp +decide [ Finset.sum_insert hi ];
      · exact hf i ( Finset.mem_insert_self _ _ );
      · simp_all +decide [ circleIntegrable_iff ];
        induction' s using Finset.induction with i s hi ih;
        · norm_num;
        · simp_all +decide [ Finset.sum_insert, mul_add ]

/-
The circle integral of 0 is 0.
-/
lemma circleIntegral_zero {c : ℂ} {R : ℝ} : (∮ z in C(c, R), (0 : ℂ)) = 0 := by
  simp [circleIntegral]

#check circleIntegral_sum