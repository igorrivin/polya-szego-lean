/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 68a5aa8e-2d3d-444f-b46d-17537b0931a1
-/

/-
We formalize and prove Polya-Szego Problem 113, which states that if f is monotone on [1, ‚àû) and ‚à´‚ÇÅ^‚àû x^Œ± f(x) dx converges, then lim_{x ‚Üí ‚àû} x^{Œ±+1} f(x) = 0.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Opening necessary namespaces for the problem statement.
-/
open Filter Topology Set MeasureTheory

/-
If the integral of f from 1 to infinity converges, then the integral from x to 2x tends to 0 as x tends to infinity.
-/
lemma integral_tendsto_zero_of_convergent {f : ‚Ñù ‚Üí ‚Ñù}
    (hint : ‚àÄ (X : ‚Ñù), 1 ‚â§ X ‚Üí IntervalIntegrable f MeasureTheory.volume 1 X)
    (hconv : ‚àÉ (I : ‚Ñù), Tendsto (Œª (X : ‚Ñù) ‚Ü¶ ‚à´ x in 1..X, f x) atTop (ùìù I)) :
    Tendsto (Œª x ‚Ü¶ ‚à´ t in x..2*x, f t) atTop (ùìù 0) := by
  choose I hI using hconv;
  -- Let $F(X) = \int_1^X f(t) dt$. We are given that $F(X) \to I$ as $X \to \infty$.
  set F : ‚Ñù ‚Üí ‚Ñù := fun X => ‚à´ x in (1 : ‚Ñù)..X, f x;
  have h_diff : ‚àÄ x ‚â• 1, ‚à´ t in (x : ‚Ñù)..2 * x, f t = F (2 * x) - F x := by
    intro x hx; rw [ eq_sub_iff_add_eq' ] ; rw [ intervalIntegral.integral_add_adjacent_intervals ] ; ring;
    ¬∑ exact?;
    ¬∑ rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le ( by linarith ) ];
      have := ‚Äπ‚àÄ X : ‚Ñù, 1 ‚â§ X ‚Üí IntervalIntegrable f MeasureTheory.MeasureSpace.volume 1 X‚Ä∫ ( 2 * x ) ( by linarith ) ; rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le ( by linarith ) ] at this; exact this.mono_set ( Set.Ioc_subset_Ioc ( by linarith ) le_rfl ) ;
  rw [ Filter.tendsto_congr' ( Filter.eventuallyEq_of_mem ( Filter.Ici_mem_atTop 1 ) h_diff ) ] ; simpa using Filter.Tendsto.sub ( hI.comp ( Filter.tendsto_id.const_mul_atTop zero_lt_two ) ) hI;

/-
The integral of x^r from a to b is positive if 0 < a < b.
-/
lemma integral_rpow_pos_of_pos {a b : ‚Ñù} (hab : a < b) (ha : 0 < a) (r : ‚Ñù) :
    0 < ‚à´ x in a..b, x^r := by
      rw [ intervalIntegral.integral_of_le hab.le ];
      rw [ MeasureTheory.integral_pos_iff_support_of_nonneg_ae ];
      ¬∑ simp +decide [ Function.support, ha.not_le, hab.le ];
        rw [ show { x : ‚Ñù | ¬¨x ^ r = 0 } ‚à© Set.Ioc a b = Set.Ioc a b by ext x; exact ‚ü® fun hx => hx.2, fun hx => ‚ü® ne_of_gt ( Real.rpow_pos_of_pos ( by linarith [ hx.1 ] ) _ ), hx ‚ü© ‚ü© ] ; aesop;
      ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx using Real.rpow_nonneg ( by linarith [ hx.1 ] ) _;
      ¬∑ exact ( ContinuousOn.integrableOn_Icc ( by exact continuousOn_of_forall_continuousAt fun x hx => by exact ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by linarith [ hx.1 ] ) ) |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self

/-
If f is monotone increasing, then the integral of t^Œ± * f(t) from x to 2x is at least f(x) times the integral of t^Œ± from x to 2x.
-/
lemma integral_bound_ge {f : ‚Ñù ‚Üí ‚Ñù} {Œ± : ‚Ñù} (hmono : MonotoneOn f (Set.Ici 1)) (x : ‚Ñù) (hx : 1 ‚â§ x) :
    ‚à´ t in x..2*x, t^Œ± * f t ‚â• f x * ‚à´ t in x..2*x, t^Œ± := by
      rw [ ‚Üê intervalIntegral.integral_const_mul ] ; apply_rules [ intervalIntegral.integral_mono_on ];
      ¬∑ linarith;
      ¬∑ apply_rules [ ContinuousOn.intervalIntegrable ];
        exact continuousOn_of_forall_continuousAt fun u hu => ContinuousAt.mul continuousAt_const ( ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by cases Set.mem_uIcc.mp hu <;> linarith );
      ¬∑ apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ];
        have h_integrable : MeasureTheory.IntegrableOn (fun u => f u) (Set.uIcc x (2 * x)) := by
          exact ( hmono.mono ( show Set.uIcc x ( 2 * x ) ‚äÜ Set.Ici 1 from fun u hu => by cases Set.mem_uIcc.mp hu <;> norm_num <;> linarith ) ) |> fun h => h.integrableOn_isCompact ( CompactIccSpace.isCompact_Icc );
        have h_integrable : MeasureTheory.IntegrableOn (fun u => u ^ Œ± * f u) (Set.uIcc x (2 * x)) := by
          have h_bounded : ‚àÉ C, ‚àÄ u ‚àà Set.uIcc x (2 * x), |u ^ Œ± * f u| ‚â§ C * |f u| := by
            have h_bounded : ‚àÉ C, ‚àÄ u ‚àà Set.uIcc x (2 * x), |u ^ Œ±| ‚â§ C := by
              have h_bounded : ContinuousOn (fun u => u ^ Œ±) (Set.uIcc x (2 * x)) := by
                exact continuousOn_of_forall_continuousAt fun u hu => ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by cases Set.mem_uIcc.mp hu <;> linarith;
              exact IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) h_bounded |> fun ‚ü® C, hC ‚ü© => ‚ü® C, fun u hu => hC u hu ‚ü©;
            exact ‚ü® h_bounded.choose, fun u hu => by rw [ abs_mul ] ; exact mul_le_mul_of_nonneg_right ( h_bounded.choose_spec u hu ) ( abs_nonneg _ ) ‚ü©
          refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun u => h_bounded.choose * |f u|;
          ¬∑ exact MeasureTheory.Integrable.const_mul ( h_integrable.norm ) _;
          ¬∑ exact MeasureTheory.AEStronglyMeasurable.mul ( measurable_id.pow_const Œ± |> Measurable.aestronglyMeasurable ) h_integrable.aestronglyMeasurable;
          ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with u hu using h_bounded.choose_spec u hu;
        convert h_integrable using 1;
      ¬∑ exact fun y hy => by rw [ mul_comm ] ; exact mul_le_mul_of_nonneg_left ( hmono ( show 1 ‚â§ x by linarith ) ( show 1 ‚â§ y by linarith [ hy.1 ] ) hy.1 ) ( Real.rpow_nonneg ( by linarith [ hy.1 ] ) _ ) ;

/-
The integral of t^Œ± from x to 2x is given by the formula involving powers of x.
-/
lemma integral_rpow_interval {Œ± : ‚Ñù} {x : ‚Ñù} (hx : 0 < x) :
    ‚à´ t in x..2*x, t^Œ± = if Œ± = -1 then x^0 * Real.log 2 else x^(Œ±+1) * ((2^(Œ±+1) - 1)/(Œ±+1)) := by
      split_ifs with h;
      ¬∑ norm_num [ h, hx ];
        norm_num [ Real.rpow_neg_one, hx ];
        rw [ mul_div_cancel_right‚ÇÄ _ hx.ne' ];
      ¬∑ rw [ integral_rpow ];
        ¬∑ rw [ Real.mul_rpow ( by positivity ) ( by positivity ) ] ; ring;
        ¬∑ exact Or.inr ‚ü® h, Set.notMem_uIcc_of_lt ( by linarith ) ( by linarith ) ‚ü©

/-
If f is monotone increasing, then the integral of t^Œ± * f(t) from x/2 to x is at most f(x) times the integral of t^Œ± from x/2 to x.
-/
lemma integral_bound_le_lower {f : ‚Ñù ‚Üí ‚Ñù} {Œ± : ‚Ñù} (hmono : MonotoneOn f (Set.Ici 1)) (x : ‚Ñù) (hx : 2 ‚â§ x) :
    ‚à´ t in x/2..x, t^Œ± * f t ‚â§ f x * ‚à´ t in x/2..x, t^Œ± := by
      rw [ intervalIntegral.integral_of_le ( by linarith ), intervalIntegral.integral_of_le ( by linarith ) ];
      rw [ ‚ÜêMeasureTheory.integral_const_mul ];
      refine' MeasureTheory.setIntegral_mono_on _ _ measurableSet_Ioc fun t ht => _;
      ¬∑ -- Since $f$ is monotone increasing on $[1, \infty)$, it is integrable on any interval $[a, b]$ where $1 \leq a < b$.
        have h_integrable : MeasureTheory.IntegrableOn f (Set.Icc (x / 2) x) := by
          exact ( hmono.mono <| Set.Icc_subset_Ici_self.trans <| Set.Ici_subset_Ici.2 <| by linarith ) |> fun h => h.integrableOn_isCompact <| CompactIccSpace.isCompact_Icc;
        -- Since $x^\alpha$ is continuous on $[x/2, x]$, it is bounded on this interval.
        have h_bounded : ‚àÉ C, ‚àÄ t ‚àà Set.Icc (x / 2) x, abs (t ^ Œ±) ‚â§ C := by
          exact IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) ( show ContinuousOn ( fun t : ‚Ñù => t ^ Œ± ) ( Set.Icc ( x / 2 ) x ) from continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by linarith [ ht.1 ] );
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun t => h_bounded.choose * |f t|;
        ¬∑ exact MeasureTheory.Integrable.const_mul ( h_integrable.norm.mono_measure <| MeasureTheory.Measure.restrict_mono ( Set.Ioc_subset_Icc_self ) le_rfl ) _;
        ¬∑ exact MeasureTheory.AEStronglyMeasurable.mul ( measurable_id.pow_const Œ± |> Measurable.aestronglyMeasurable ) ( h_integrable.aestronglyMeasurable.mono_set <| Set.Ioc_subset_Icc_self );
        ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using by simpa only [ Real.norm_eq_abs, abs_mul ] using mul_le_mul_of_nonneg_right ( h_bounded.choose_spec t <| Set.Ioc_subset_Icc_self ht ) ( abs_nonneg _ ) ;
      ¬∑ exact ContinuousOn.integrableOn_Icc ( by exact continuousOn_of_forall_continuousAt fun y hy => ContinuousAt.mul continuousAt_const <| ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by linarith [ hy.1 ] ) |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self;
      ¬∑ nlinarith [ hmono ( show 1 ‚â§ t by linarith [ ht.1 ] ) ( show 1 ‚â§ x by linarith ) ht.2, Real.rpow_nonneg ( by linarith [ ht.1 ] : 0 ‚â§ t ) Œ± ]

/-
The integral of t^Œ± from x to 2x scales as x^(Œ±+1) times the integral from 1 to 2.
-/
lemma integral_rpow_scaling_unified {Œ± : ‚Ñù} {x : ‚Ñù} (hx : 0 < x) :
    ‚à´ t in x..2*x, t^Œ± = x^(Œ±+1) * ‚à´ t in 1..2, t^Œ± := by
      cases eq_or_ne Œ± ( -1 ) <;> simp_all +decide [ intervalIntegral.integral_comp_mul_left ];
      ¬∑ norm_num [ Real.rpow_neg_one, hx ];
        rw [ mul_div_cancel_right‚ÇÄ _ hx.ne' ];
      ¬∑ rw [ integral_rpow, integral_rpow ] <;> norm_num;
        ¬∑ rw [ Real.mul_rpow ( by positivity ) ( by positivity ) ] ; ring;
        ¬∑ tauto;
        ¬∑ exact Or.inr ‚ü® by assumption, Set.notMem_uIcc_of_lt ( by linarith ) ( by linarith ) ‚ü©

/-
If f is monotone and the integral converges, then x^{Œ±+1} f(x) tends to 0.
-/
theorem problem_113 {Œ± : ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù} (hmono : MonotoneOn f (Set.Ici 1))
    (hint : ‚àÄ (X : ‚Ñù), 1 ‚â§ X ‚Üí IntervalIntegrable f MeasureTheory.volume 1 X)
    (hconv : ‚àÉ (I : ‚Ñù), Tendsto (Œª (X : ‚Ñù) ‚Ü¶ ‚à´ x in 1..X, (x : ‚Ñù)^Œ± * f x) atTop (ùìù I)) :
    Tendsto (Œª (x : ‚Ñù) ‚Ü¶ (x : ‚Ñù)^(Œ± + 1) * f x) atTop (ùìù 0) := by
      -- We define C = ‚à´_1^2 t^Œ± dt > 0.
      set C : ‚Ñù := ‚à´ t in (1 : ‚Ñù)..2, t^Œ±
      have hC_pos : 0 < C := by
        apply integral_rpow_pos_of_pos; norm_num; norm_num
      have h_integral : ‚àÄ x ‚â• 1, ‚à´ t in x..2*x, t^Œ± * f t ‚â• f x * x^(Œ±+1) * C := by
        intro x hx
        have h_integral_bound : ‚à´ t in x..2*x, t^Œ± * f t ‚â• f x * ‚à´ t in x..2*x, t^Œ± := by
          simpa only [ mul_comm, ‚Üê intervalIntegral.integral_const_mul ] using integral_bound_ge hmono x hx;
        -- Using the scaling property of the integral, we have $\int_x^{2x} t^\alpha dt = x^{\alpha+1} \int_1^2 t^\alpha dt$.
        have h_integral_scale : ‚à´ t in x..2*x, t^Œ± = x^(Œ±+1) * ‚à´ t in (1 : ‚Ñù)..2, t^Œ± := by
          convert integral_rpow_scaling_unified ( show 0 < x by linarith ) using 1;
        simpa only [ mul_assoc, h_integral_scale ] using h_integral_bound
      have h_integral2 : ‚àÄ x ‚â• 2, ‚à´ t in (x/2)..x, t^Œ± * f t ‚â§ f x * (x/2)^(Œ±+1) * C := by
        -- Using the fact that $f$ is monotone increasing, we can bound the integral.
        intros x hx
        have h_integral_bound : ‚à´ t in (x/2)..x, t^Œ± * f t ‚â§ f x * ‚à´ t in (x/2)..x, t^Œ± := by
          exact?;
        have h_integral_bound : ‚à´ t in (x/2)..x, t^Œ± = (x/2)^(Œ±+1) * C := by
          convert integral_rpow_scaling_unified ( show 0 < x / 2 by linarith ) using 1 ; ring;
        simpa only [ h_integral_bound, mul_assoc ] using ‚Äπ‚à´ t in x / 2..x, t ^ Œ± * f t ‚â§ f x * ‚à´ t in x / 2..x, t ^ Œ±‚Ä∫;
      -- We know $\int_x^{2x} t^\alpha f(t) dt \to 0$.
      have h_lim_zero : Filter.Tendsto (fun x => ‚à´ t in x..2*x, t^Œ± * f t) Filter.atTop (nhds 0) := by
        -- By the properties of integrals, we can split the integral from x to 2x into the difference of integrals from 1 to 2x and from 1 to x.
        have h_split : ‚àÄ x ‚â• 1, ‚à´ t in x..2 * x, t^Œ± * f t = (‚à´ t in (1 : ‚Ñù)..2 * x, t^Œ± * f t) - (‚à´ t in (1 : ‚Ñù)..x, t^Œ± * f t) := by
          intro x hx; rw [ eq_sub_iff_add_eq', intervalIntegral.integral_add_adjacent_intervals ];
          ¬∑ apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ];
            have := ‚Äπ‚àÄ X : ‚Ñù, 1 ‚â§ X ‚Üí IntervalIntegrable f MeasureTheory.MeasureSpace.volume 1 X‚Ä∫ x hx;
            rw [ intervalIntegrable_iff_integrableOn_Icc_of_le hx ] at this;
            rw [ Set.uIcc_of_le hx ];
            refine' MeasureTheory.Integrable.mono' _ _ _;
            refine' fun t => ( x ^ |Œ±| ) * |f t|;
            ¬∑ exact MeasureTheory.Integrable.const_mul ( this.norm ) _;
            ¬∑ exact MeasureTheory.AEStronglyMeasurable.mul ( measurable_id.pow_const Œ± |> Measurable.aestronglyMeasurable ) this.aestronglyMeasurable;
            ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with t ht;
              rw [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( Real.rpow_nonneg ( by linarith [ ht.1 ] ) _ ) ];
              exact mul_le_mul_of_nonneg_right ( by cases abs_cases Œ± <;> [ exact le_trans ( Real.rpow_le_rpow ( by linarith [ ht.1 ] ) ht.2 ( by linarith ) ) ( Real.rpow_le_rpow_of_exponent_le ( by linarith [ ht.1 ] ) ( by linarith ) ) ; exact le_trans ( Real.rpow_le_rpow_of_exponent_le ( by linarith [ ht.1 ] ) ( by linarith ) ) ( Real.rpow_le_rpow ( by linarith [ ht.1 ] ) ht.2 ( by linarith ) ) ] ) ( abs_nonneg _ );
          ¬∑ rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le ( by linarith ) ];
            have h_integrable : MeasureTheory.IntegrableOn (fun t => t ^ Œ± * f t) (Set.Icc 1 (2 * x)) := by
              have h_integrable : MeasureTheory.IntegrableOn f (Set.Icc 1 (2 * x)) := by
                have := ‚Äπ‚àÄ X : ‚Ñù, 1 ‚â§ X ‚Üí IntervalIntegrable f MeasureTheory.MeasureSpace.volume 1 X‚Ä∫ ( 2 * x ) ( by linarith );
                rw [ intervalIntegrable_iff_integrableOn_Icc_of_le ( by linarith ) ] at this ; aesop;
              have h_integrable : MeasureTheory.IntegrableOn (fun t => t ^ Œ± * f t) (Set.Icc 1 (2 * x)) := by
                have h_bounded : ‚àÉ M, ‚àÄ t ‚àà Set.Icc 1 (2 * x), |t ^ Œ± * f t| ‚â§ M * |f t| := by
                  use ( SupSet.sSup ( Set.image ( fun t : ‚Ñù => |t ^ Œ±| ) ( Set.Icc 1 ( 2 * x ) ) ) );
                  exact fun t ht => by rw [ abs_mul ] ; exact mul_le_mul_of_nonneg_right ( le_csSup ( by exact ( isCompact_Icc.image_of_continuousOn ( by exact ContinuousOn.abs ( ContinuousOn.rpow continuousOn_id continuousOn_const <| by intro u hu; exact Or.inl <| by linarith [ hu.1 ] ) ) ) |> IsCompact.bddAbove ) <| Set.mem_image_of_mem _ ht ) <| abs_nonneg _;
                refine' MeasureTheory.Integrable.mono' _ _ _;
                use fun t => h_bounded.choose * |f t|;
                ¬∑ exact MeasureTheory.Integrable.const_mul ( h_integrable.norm ) _;
                ¬∑ exact MeasureTheory.AEStronglyMeasurable.mul ( measurable_id.pow_const Œ± |> Measurable.aestronglyMeasurable ) h_integrable.aestronglyMeasurable;
                ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with t ht using h_bounded.choose_spec t ht;
              convert h_integrable using 1;
            exact h_integrable.mono_set ( Set.Ioc_subset_Icc_self.trans ( Set.Icc_subset_Icc ( by linarith ) le_rfl ) );
        rw [ Filter.tendsto_congr' ( by filter_upwards [ Filter.eventually_ge_atTop 1 ] with x hx using h_split x hx ) ] ; simpa using Filter.Tendsto.sub ( hconv.choose_spec.comp ( Filter.tendsto_id.const_mul_atTop zero_lt_two ) ) hconv.choose_spec;
      -- We know $\int_{x/2}^x t^\alpha f(t) dt \to 0$.
      have h_lim_zero2 : Filter.Tendsto (fun x => ‚à´ t in (x/2)..x, t^Œ± * f t) Filter.atTop (nhds 0) := by
        have := h_lim_zero.comp ( show Filter.Tendsto ( fun x : ‚Ñù => x / 2 ) Filter.atTop Filter.atTop from Filter.tendsto_id.atTop_mul_const ( by norm_num ) );
        exact this.congr fun x => by rw [ Function.comp_apply ] ; ring;
      -- By the squeeze theorem, we can conclude that $f(x) x^{Œ±+1} \to 0$.
      have h_squeeze : Filter.Tendsto (fun x => f x * x^(Œ±+1)) Filter.atTop (nhds 0) := by
        have h_upper : ‚àÄ·∂† x in Filter.atTop, f x * x^(Œ±+1) ‚â§ (‚à´ t in x..2*x, t^Œ± * f t) / C := by
          filter_upwards [ Filter.eventually_ge_atTop 1 ] with x hx using by rw [ le_div_iff‚ÇÄ hC_pos ] ; linarith [ h_integral x hx ] ;
        have h_lower : ‚àÄ·∂† x in Filter.atTop, f x * x^(Œ±+1) ‚â• (2^(Œ±+1)) * (‚à´ t in (x/2)..x, t^Œ± * f t) / C := by
          filter_upwards [ Filter.eventually_ge_atTop 2 ] with x hx;
          rw [ ge_iff_le, div_le_iff‚ÇÄ hC_pos ];
          convert mul_le_mul_of_nonneg_left ( h_integral2 x hx ) ( Real.rpow_nonneg zero_le_two ( Œ± + 1 ) ) using 1 ; ring;
          rw [ Real.mul_rpow ( by positivity ) ( by positivity ) ] ; ring;
          norm_num [ mul_assoc, ‚Üê Real.mul_rpow ]
        simp +zetaDelta at *;
        exact tendsto_of_tendsto_of_tendsto_of_le_of_le' ( by simpa using Filter.Tendsto.div_const ( h_lim_zero2.const_mul ( 2 ^ ( Œ± + 1 ) ) ) C ) ( by simpa using h_lim_zero.div_const C ) ( Filter.eventually_atTop.mpr ‚ü® h_lower.choose, fun x hx => h_lower.choose_spec x hx ‚ü© ) ( Filter.eventually_atTop.mpr ‚ü® h_upper.choose, fun x hx => h_upper.choose_spec x hx ‚ü© );
      simpa only [ mul_comm ] using h_squeeze

/-
The function x^Œ± * f(x) is integrable on [1, X].
-/
lemma integrable_mul_rpow {Œ± : ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù}
    (hint : ‚àÄ (X : ‚Ñù), 1 ‚â§ X ‚Üí IntervalIntegrable f MeasureTheory.volume 1 X)
    (X : ‚Ñù) (hX : 1 ‚â§ X) :
    IntervalIntegrable (fun x => x^Œ± * f x) MeasureTheory.volume 1 X := by
      apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ];
      rw [ Set.uIcc_of_le hX ];
      -- The function x^Œ± is continuous on [1, X], hence bounded.
      have h_cont : ContinuousOn (fun x => x^Œ±) (Set.Icc 1 X) := by
        exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by linarith [ hx.1 ] ;
      have := ‚Äπ‚àÄ X : ‚Ñù, 1 ‚â§ X ‚Üí IntervalIntegrable f MeasureTheory.MeasureSpace.volume 1 X‚Ä∫ X hX;
      rw [ intervalIntegrable_iff_integrableOn_Icc_of_le hX ] at this;
      refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => ( SupSet.sSup ( Set.image ( fun x => |x ^ Œ±| ) ( Set.Icc 1 X ) ) ) * |f x|;
      ¬∑ exact MeasureTheory.Integrable.const_mul ( this.norm ) _;
      ¬∑ exact MeasureTheory.AEStronglyMeasurable.mul ( h_cont.aestronglyMeasurable measurableSet_Icc ) this.aestronglyMeasurable;
      ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using by rw [ norm_mul ] ; exact mul_le_mul_of_nonneg_right ( le_csSup ( IsCompact.bddAbove ( isCompact_Icc.image_of_continuousOn ( continuous_abs.comp_continuousOn h_cont ) ) ) ( Set.mem_image_of_mem _ hx ) ) ( abs_nonneg _ ) ;