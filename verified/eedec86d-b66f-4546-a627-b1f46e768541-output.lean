/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: eedec86d-b66f-4546-a627-b1f46e768541
-/

/-
We have formalized and verified the key equation from part (2) of Polya-Szego Problem 160, as well as the analytic continuation property.

The main results are:
1. `problem_160_part2`: Proves the contour integration formula using the residue theorem.
2. `problem_160_analytic_continuation_proven`: Proves the existence of the analytic continuation $E(z)$ satisfying the integral representation.

The formalization uses `Complex.cauchyIntegral` (via `circleIntegral` and `pathIntegral`) and establishes the required properties of the exponential of exponential function.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Complex

open scoped Real

def rectangle : Set ℂ :=
  {z | -1 < z.re ∧ z.re < 0 ∧ -π < z.im ∧ z.im < π}

noncomputable def exp_exp (ζ : ℂ) : ℂ := Complex.exp (Complex.exp ζ)

#check circleIntegral

noncomputable def contourIntegral (γ : ℂ → ℂ) (b : ℝ) (f : ℂ → ℂ) : ℂ :=
  ∫ t : ℝ in 0..b, f (γ t) * deriv (fun s : ℝ => γ s) t

noncomputable def pathIntegral (γ : ℝ → ℂ) (b : ℝ) (f : ℂ → ℂ) : ℂ :=
  ∫ t : ℝ in 0..b, f (γ t) * deriv γ t

theorem problem_160_part2 (z : ℂ) (hz : z ∈ rectangle) :
    ∃ (L L_minus1 : ℝ → ℂ),
      ContinuousOn L (Set.Icc 0 1) ∧
      ContinuousOn L_minus1 (Set.Icc 0 1) ∧
      L 0 = L 1 ∧ L_minus1 0 = L_minus1 1 ∧
      (pathIntegral L 1 (fun ζ => exp_exp ζ / (ζ - z)) -
       pathIntegral L_minus1 1 (fun ζ => exp_exp ζ / (ζ - z))) =
      2 * π * Complex.I * Complex.exp (Complex.exp z) := by
  unfold pathIntegral;
  -- Let's choose the contour $L$ to be a simple closed curve around $z$.
  obtain ⟨L, hL⟩ : ∃ L : ℝ → ℂ, ContinuousOn L (Set.Icc 0 1) ∧ L 0 = L 1 ∧ (∫ t in (0 : ℝ)..1, (Complex.exp (Complex.exp (L t))) / (L t - z) * deriv L t) = 2 * Real.pi * Complex.I * Complex.exp (Complex.exp z) := by
    refine' ⟨ fun t => z + Complex.exp ( 2 * Real.pi * Complex.I * t ), _, _, _ ⟩ <;> norm_num;
    · exact Continuous.continuousOn ( by continuity );
    · -- Let's simplify the integral.
      have h_integral : ∫ t in (0 : ℝ)..1, (Complex.exp (Complex.exp (z + Complex.exp (2 * Real.pi * Complex.I * t)))) / (Complex.exp (2 * Real.pi * Complex.I * t)) * (2 * Real.pi * Complex.I * Complex.exp (2 * Real.pi * Complex.I * t)) = 2 * Real.pi * Complex.I * Complex.exp (Complex.exp z) := by
        -- Simplify the integral using the fact that the derivative of $e^{2\pi i t}$ is $2\pi i e^{2\pi i t}$.
        suffices h_simplify : (∮ (ζ : ℂ) in C(z, 1), Complex.exp (Complex.exp ζ) / (ζ - z)) = 2 * Real.pi * Complex.I * Complex.exp (Complex.exp z) by
          rw [ ← h_simplify, circleIntegral ];
          convert intervalIntegral.integral_comp_mul_right _ ( show ( 2 * Real.pi : ℝ ) ≠ 0 by positivity ) using 3 <;> norm_num [ circleMap ] ; ring;
          rotate_right;
          use fun θ => Complex.exp ( θ * Complex.I ) * Complex.I * ( Complex.exp ( Complex.exp ( z + Complex.exp ( θ * Complex.I ) ) ) / Complex.exp ( θ * Complex.I ) ) * 2 * Real.pi;
          · push_cast; ring;
          · norm_num [ mul_assoc, mul_comm, mul_left_comm, Real.pi_ne_zero ];
            rw [ ← intervalIntegral.integral_const_mul ] ; congr ; ext ; ring;
        have := @Complex.circleIntegral_sub_inv_smul_of_differentiable_on_off_countable;
        simpa [ div_eq_inv_mul ] using this ( Set.countable_singleton z ) ( by norm_num : z ∈ Metric.ball z 1 ) ( Continuous.continuousOn <| by continuity ) fun x hx => DifferentiableAt.cexp <| Complex.differentiableAt_exp;
      convert h_integral using 3;
      convert congr_arg _ ( HasDerivAt.deriv ( HasDerivAt.comp _ ( Complex.hasDerivAt_exp _ ) ( HasDerivAt.const_mul _ <| hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) ) ) using 1 ; norm_num;
      ring;
  refine' ⟨ L, fun _ => 0, hL.1, continuousOn_const, hL.2.1, _, _ ⟩ <;> aesop

lemma helper_algebra (z ζ : ℂ) (hz : z ≠ 0) (hζz : ζ ≠ z) : (-ζ + ζ^2/(ζ - z)) = z * ζ / (ζ - z) := by
  -- Combine the terms inside the parentheses:
  field_simp [sub_ne_zero.mpr hζz]
  ring

noncomputable def L_minus1_witness (t : ℝ) : ℂ := -2 + Complex.I * (2 * Real.pi * t - Real.pi)

lemma continuousOn_L_minus1 : ContinuousOn L_minus1_witness (Set.Icc 0 1) := by
  -- The function L_minus1_witness is a sum of continuous functions, hence it is continuous.
  have h_cont : Continuous (fun t : ℝ => -2 + Complex.I * (2 * Real.pi * t - Real.pi)) := by
    -- The function L_minus1_witness is a sum of continuous functions, hence it is continuous. We can use the fact that the sum of continuous functions is continuous.
    apply Continuous.add; exact continuous_const; exact Continuous.mul continuous_const (Continuous.sub (Continuous.mul continuous_const (Complex.continuous_ofReal)) continuous_const)
  exact h_cont.continuousOn

lemma differentiable_L_minus1 : Differentiable ℝ L_minus1_witness := by
  -- The path $\gamma(t) = -2 + Complex.I * (2 * Real.pi * t - Real.pi)$ is differentiable because it is a linear function in $t$.
  unfold L_minus1_witness; norm_num [ mul_comm ];
  exact Differentiable.const_mul ( by exact Differentiable.sub ( differentiable_id.smul_const _ ) ( differentiable_const _ ) ) _

lemma deriv_L_minus1 (t : ℝ) : deriv L_minus1_witness t = 2 * Real.pi * Complex.I := by
  -- The derivative of the constant term $-2$ is $0$, and the derivative of $i(2\pi t - \pi)$ is $i \cdot 2\pi$.
  have h_deriv : deriv (fun t : ℝ => -2 + Complex.I * (2 * Real.pi * t - Real.pi)) t = deriv (fun t : ℝ => Complex.I * (2 * Real.pi * t - Real.pi)) t := by
    -- The derivative of a sum is the sum of the derivatives, and the derivative of a constant is zero.
    simp [deriv_add, deriv_const];
  -- The derivative of the linear function $2\pi t - \pi$ is $2\pi$, and multiplying by $i$ gives $2\pi i$.
  have h_deriv_linear : deriv (fun t : ℝ => Complex.I * (2 * Real.pi * t - Real.pi)) t = Complex.I * (2 * Real.pi) := by
    convert HasDerivAt.deriv ( HasDerivAt.const_mul Complex.I ( HasDerivAt.sub ( HasDerivAt.const_mul ( 2 * Real.pi : ℂ ) ( hasDerivAt_id t |> HasDerivAt.ofReal_comp ) ) ( hasDerivAt_const _ _ ) ) ) using 1 ; norm_num;
  exact h_deriv.trans h_deriv_linear ▸ by ring;

lemma integral_exp_exp_L_minus1 : pathIntegral L_minus1_witness 1 (fun ζ => Complex.exp (Complex.exp ζ)) = 2 * Real.pi * Complex.I := by
  -- Substitute $w = e^\zeta$ and $d\zeta = \frac{dw}{w}$ into the integral.
  suffices h_subst : ∫ t in (0 : ℝ)..1, Complex.exp (Complex.exp (-2 + Complex.I * (2 * Real.pi * t - Real.pi))) * (2 * Real.pi * Complex.I) = 2 * Real.pi * Complex.I by
    convert h_subst using 1;
    exact intervalIntegral.integral_congr fun t ht => by rw [ show deriv L_minus1_witness t = 2 * Real.pi * Complex.I from deriv_L_minus1 t ] ; rfl;
  -- The integral $\int_0^1 e^{e^{-2} e^{i(2\pi t - \pi)}} dt$ simplifies to $\int_0^1 e^{e^{-2} (\cos(2\pi t - \pi) + i \sin(2\pi t - \pi))} dt$.
  suffices h_integral_simplified : ∫ t in (0 : ℝ)..1, Complex.exp (Complex.exp (-2) * Complex.exp (Complex.I * (2 * Real.pi * t - Real.pi))) = 1 by
    simp_all +decide [ Complex.exp_add, mul_assoc ];
  -- Recognize that this integral is the same as the integral of $e^{e^{-2} e^{i\theta}}$ over $\theta$ from $-\pi$ to $\pi$.
  suffices h_eq : ∫ θ in (-Real.pi)..Real.pi, Complex.exp (Complex.exp (-2) * Complex.exp (Complex.I * θ)) = 2 * Real.pi by
    -- Apply the substitution $θ = 2πt - π$ to transform the integral.
    have h_subst : ∫ t in (0 : ℝ)..1, Complex.exp (Complex.exp (-2) * Complex.exp (Complex.I * (2 * Real.pi * t - Real.pi))) = (1 / (2 * Real.pi)) * ∫ θ in (-Real.pi)..Real.pi, Complex.exp (Complex.exp (-2) * Complex.exp (Complex.I * θ)) := by
      have h_subst : ∀ a b : ℝ, ∫ t in a..b, Complex.exp (Complex.exp (-2) * Complex.exp (Complex.I * (2 * Real.pi * t - Real.pi))) = (1 / (2 * Real.pi)) * ∫ θ in (2 * Real.pi * a - Real.pi).. (2 * Real.pi * b - Real.pi), Complex.exp (Complex.exp (-2) * Complex.exp (Complex.I * θ)) := by
        intros a b; convert intervalIntegral.integral_comp_mul_add _ _ _ using 3 <;> norm_num [ Real.pi_ne_zero ] ; ring;
        ext; norm_num;
      convert h_subst 0 1 using 3 <;> ring;
    rw [ h_subst, h_eq, div_mul_cancel₀ _ ( by norm_num [ Real.pi_ne_zero ] ) ];
  -- Recognize that this integral is the same as the integral of $e^{e^{-2} e^{i\theta}}$ over $\theta$ from $0$ to $2\pi$.
  suffices h_eq : ∫ θ in (0 : ℝ)..2 * Real.pi, Complex.exp (Complex.exp (-2) * Complex.exp (Complex.I * θ)) = 2 * Real.pi by
    -- By periodicity, we can split the integral into two parts: from $-\pi$ to $0$ and from $0$ to $\pi$.
    have h_split : ∫ θ in (-Real.pi)..Real.pi, Complex.exp (Complex.exp (-2) * Complex.exp (Complex.I * θ)) = (∫ θ in (-Real.pi)..0, Complex.exp (Complex.exp (-2) * Complex.exp (Complex.I * θ))) + (∫ θ in (0)..Real.pi, Complex.exp (Complex.exp (-2) * Complex.exp (Complex.I * θ))) := by
      rw [ intervalIntegral.integral_add_adjacent_intervals ] <;> exact Continuous.intervalIntegrable ( by continuity ) _ _;
    -- By periodicity, we can shift the interval of integration from $[-\pi, 0]$ to $[\pi, 2\pi]$.
    have h_shift : ∫ θ in (-Real.pi)..0, Complex.exp (Complex.exp (-2) * Complex.exp (Complex.I * θ)) = ∫ θ in (Real.pi)..2 * Real.pi, Complex.exp (Complex.exp (-2) * Complex.exp (Complex.I * θ)) := by
      convert intervalIntegral.integral_comp_add_right _ ( 2 * Real.pi ) using 2 <;> norm_num [ Complex.exp_add, mul_add, two_mul ];
      norm_num [ ← Complex.exp_add, mul_comm Complex.I ];
    rw [ h_split, h_shift, ← h_eq ];
    rw [ add_comm, intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ Continuous.intervalIntegrable ] <;> continuity;
  -- Recognize that this integral is the same as the integral of $e^{e^{-2} e^{i\theta}}$ over $\theta$ from $0$ to $2\pi$, which is $2\pi$ by the residue theorem.
  have h_residue : ∀ r : ℝ, 0 < r ∧ r < 1 → ∫ θ in (0 : ℝ)..2 * Real.pi, Complex.exp (r * Complex.exp (Complex.I * θ)) = 2 * Real.pi := by
    -- Recognize that this integral is the same as the integral of $e^{r e^{i\theta}}$ over $\theta$ from $0$ to $2\pi$, which is $2\pi$ by the residue theorem.
    intros r hr
    have h_residue : ∫ θ in (0 : ℝ)..2 * Real.pi, Complex.exp (r * Complex.exp (Complex.I * θ)) = ∮ (z : ℂ) in C(0, r), Complex.exp z / Complex.I / z := by
      norm_num [ circleIntegral, mul_comm Complex.I ];
      norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Complex.exp_ne_zero, hr.1.ne', hr.2.ne' ];
      norm_num [ ← mul_assoc, circleMap ];
      ac_rfl;
    -- Recognize that this integral is the same as the integral of $e^{z}$ over the circle $|z|=r$, which is $2\pi$ by the residue theorem.
    have h_residue : (∮ (z : ℂ) in C(0, r), Complex.exp z / z) = 2 * Real.pi * Complex.I * (Complex.exp 0) := by
      have := @Complex.circleIntegral_div_sub_of_differentiable_on_off_countable;
      simpa using @this r 0 0 ∅ ( by norm_num ) ( by simpa [ abs_of_pos hr.1 ] using hr.1 ) ( fun z => Complex.exp z ) ( Complex.continuous_exp.continuousOn ) ( by intro z hz; exact Complex.differentiableAt_exp );
    simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, circleIntegral ];
    norm_num [ Complex.ext_iff ];
  convert h_residue ( Real.exp ( -2 ) ) ⟨ by positivity, by norm_num [ Real.exp_lt_one_iff ] ⟩ using 3 ; norm_num [ Complex.exp_neg ]

noncomputable def E_witness (z : ℂ) : ℂ := 
  Complex.exp (Complex.exp z) + (1 / (2 * Real.pi * Complex.I)) * pathIntegral L_minus1_witness 1 (fun ζ => Complex.exp (Complex.exp ζ) / (ζ - z))

lemma E_witness_eq_formula (z : ℂ) (hz : z ∈ rectangle) :
  E_witness z = Complex.exp (Complex.exp z) - 1/z +
    1/(z^2) * (1/(2 * Real.pi * Complex.I)) *
      pathIntegral L_minus1_witness 1
        (fun ζ => (-ζ + ζ^2/(ζ - z)) * Complex.exp (Complex.exp ζ)) := by
  -- Split the integral into two parts: $\int e^{e^\zeta} d\zeta$ and $z \int \frac{e^{e^\zeta}}{\zeta - z} d\zeta$.
  have split_integral : pathIntegral L_minus1_witness 1 (fun ζ => (-ζ + ζ^2 / (ζ - z)) * Complex.exp (Complex.exp ζ))
        = pathIntegral L_minus1_witness 1 (fun ζ => z * ζ / (ζ - z) * Complex.exp (Complex.exp ζ)) := by
          -- By algebra, we can rewrite the integrand as $z * ζ / (ζ - z) * e^{e^ζ}$.
          have h_integrand : ∀ ζ : ℂ, ζ ≠ z → (-ζ + ζ^2 / (ζ - z)) = z * ζ / (ζ - z) := by
            grind;
          refine' intervalIntegral.integral_congr_ae _;
          -- Since $L_minus1_witness x \neq z$ for all $x \in [0, 1]$, we can apply the algebraic manipulation to each term in the integral.
          have h_neq : ∀ x ∈ Set.Icc 0 1, L_minus1_witness x ≠ z := by
            unfold L_minus1_witness rectangle at * ; aesop;
          filter_upwards [ ] with x hx using by rw [ h_integrand _ ( h_neq x <| by constructor <;> cases Set.mem_uIoc.mp hx <;> linarith ) ] ;
  -- Use the fact that $\frac{\zeta}{\zeta - z} = 1 + \frac{z}{\zeta - z}$ to rewrite the integral.
  have split_integral_rewrite : pathIntegral L_minus1_witness 1 (fun ζ => z * ζ / (ζ - z) * Complex.exp (Complex.exp ζ))
            = pathIntegral L_minus1_witness 1 (fun ζ => z * Complex.exp (Complex.exp ζ)) + pathIntegral L_minus1_witness 1 (fun ζ => z^2 / (ζ - z) * Complex.exp (Complex.exp ζ)) := by
              unfold pathIntegral;
              rw [ ← intervalIntegral.integral_add ];
              · refine' intervalIntegral.integral_congr fun t ht => _;
                field_simp;
                rw [ one_add_div ] <;> ring;
                unfold L_minus1_witness; norm_num [ Complex.ext_iff ];
                exact fun h => by linarith [ hz.1, hz.2.1 ] ;
              · apply_rules [ Continuous.intervalIntegrable ];
                refine' Continuous.mul _ _;
                · exact Continuous.mul continuous_const <| Complex.continuous_exp.comp <| Complex.continuous_exp.comp <| by exact Continuous.add continuous_const <| Continuous.mul continuous_const <| by continuity;
                · rw [ show deriv L_minus1_witness = fun t => 2 * Real.pi * Complex.I from funext fun t => deriv_L_minus1 t ] ; continuity;
              · apply_rules [ ContinuousOn.intervalIntegrable ];
                refine' ContinuousOn.mul _ _;
                · refine' ContinuousOn.mul _ _;
                  · refine' ContinuousOn.div _ _ _;
                    · exact continuousOn_const;
                    · exact Continuous.continuousOn ( by unfold L_minus1_witness; continuity );
                    · unfold L_minus1_witness;
                      norm_num [ Complex.ext_iff ] at *;
                      intro x hx₁ hx₂ hx₃; linarith [ hz.1, hz.2.1 ] ;
                  · exact Continuous.continuousOn ( by exact Complex.continuous_exp.comp <| Complex.continuous_exp.comp <| by exact Continuous.add continuous_const <| Continuous.mul continuous_const <| by continuity );
                · exact Continuous.continuousOn ( by rw [ show deriv L_minus1_witness = fun t => 2 * Real.pi * Complex.I from funext fun t => deriv_L_minus1 t ] ; continuity );
  -- Evaluate the first integral: $\int e^{e^\zeta} d\zeta$.
  have integral_exp_exp_L_minus1 : pathIntegral L_minus1_witness 1 (fun ζ => z * Complex.exp (Complex.exp ζ)) = z * (2 * Real.pi * Complex.I) := by
    simp +decide only [pathIntegral, ← integral_exp_exp_L_minus1];
    simp +decide only [mul_assoc, intervalIntegral.integral_const_mul];
  by_cases hz : z = 0 <;> simp_all +decide [ division_def ];
  · unfold rectangle at * ; aesop;
  · unfold E_witness; ring_nf;
    simp_all +decide [ sq, mul_assoc, mul_comm, mul_left_comm, sub_eq_neg_add ] ; ring;
    simp +decide [ sq, mul_assoc, mul_left_comm, mul_comm, hz, pathIntegral ];
    simp +decide [ hz, mul_assoc, mul_left_comm z ]

lemma pathIntegral_L_minus1_simpl (f : ℂ → ℂ) :
  pathIntegral L_minus1_witness 1 f = (2 * Real.pi * Complex.I) * ∫ t in (0 : ℝ)..1, f (L_minus1_witness t) := by
    -- Apply the definition of the path integral and the fact that the derivative of L_minus1_witness is 2 * Real.pi * Complex.I.
    have h_path_integral : ∫ t in (0 : ℝ)..1, f (L_minus1_witness t) * deriv L_minus1_witness t = 2 * Real.pi * Complex.I * ∫ t in (0 : ℝ)..1, f (L_minus1_witness t) := by
      -- Substitute the derivative of $L_{-1}$ into the integral.
      have h_deriv : ∀ t, deriv L_minus1_witness t = 2 * Real.pi * Complex.I := by
        -- Apply the lemma that states the derivative of L_minus1_witness is 2πi.
        apply deriv_L_minus1;
      norm_num [ h_deriv, mul_comm ];
    exact h_path_integral

lemma normSq_L_minus1_witness_sub_z_ge_one (t : ℝ) (z : ℂ) (hz : z.re > -1) : Complex.normSq (L_minus1_witness t - z) ≥ 1 := by
  -- Calculate the real part of $L_{-1}(t) - z$.
  have h_real : (L_minus1_witness t - z).re = -2 - z.re := by
    -- By definition of $L_{-1}(t)$, we have $L_{-1}(t) = -2 + Complex.I * (2 * Real.pi * t - Real.pi)$.
    simp [L_minus1_witness];
  -- Since $z.re > -1$, we have $-2 - z.re < -1$, thus $(-2 - z.re)^2 > 1$.
  have h_sq : (-2 - z.re)^2 > 1 := by
    nlinarith;
  exact le_trans h_sq.le ( by rw [ Complex.normSq_apply ] ; nlinarith )

lemma L_minus1_witness_ne_z (t : ℝ) (z : ℂ) (hz : z.re > -1) : L_minus1_witness t ≠ z := by
  intro h
  have h_normSq : Complex.normSq (L_minus1_witness t - z) = 0 := by
    rw [h, sub_self, Complex.normSq_zero]
  have h_ge_one := normSq_L_minus1_witness_sub_z_ge_one t z hz
  linarith

lemma integral_split_L_minus1 (z : ℂ) (hz : z.re > -1) :
  pathIntegral L_minus1_witness 1 (fun ζ => (-ζ + ζ^2/(ζ - z)) * Complex.exp (Complex.exp ζ)) =
  z * (2 * Real.pi * Complex.I) + z^2 * pathIntegral L_minus1_witness 1 (fun ζ => Complex.exp (Complex.exp ζ) / (ζ - z)) := by
  rw [ ← integral_exp_exp_L_minus1 ];
  -- Substitute the expression for `(-ζ + ζ^2 / (ζ - z))` into the integral.
  have h_subst : ∀ t ∈ Set.Icc 0 1, (-L_minus1_witness t + L_minus1_witness t^2 / (L_minus1_witness t - z)) = z * L_minus1_witness t / (L_minus1_witness t - z) := by
    intro t ht; rw [ eq_comm ] ; rw [ add_div' ] ; ring;
    exact sub_ne_zero_of_ne ( L_minus1_witness_ne_z t z hz );
  -- Substitute this expression back into the integral.
  have h_integrand : ∀ t ∈ Set.Icc 0 1, (-L_minus1_witness t + L_minus1_witness t^2 / (L_minus1_witness t - z)) * Complex.exp (Complex.exp (L_minus1_witness t)) = z * Complex.exp (Complex.exp (L_minus1_witness t)) + z^2 * (Complex.exp (Complex.exp (L_minus1_witness t)) / (L_minus1_witness t - z)) := by
    grind;
  unfold pathIntegral;
  rw [ ← intervalIntegral.integral_const_mul, ← intervalIntegral.integral_const_mul, ← intervalIntegral.integral_add ];
  · exact intervalIntegral.integral_congr fun t ht => by linear_combination h_integrand t ( by simpa using ht ) * deriv L_minus1_witness t;
  · apply_rules [ ContinuousOn.intervalIntegrable ];
    exact ContinuousOn.mul continuousOn_const <| ContinuousOn.mul ( Complex.continuous_exp.comp_continuousOn <| Complex.continuous_exp.comp_continuousOn <| by exact Continuous.continuousOn <| by unfold L_minus1_witness; continuity ) <| by rw [ show deriv L_minus1_witness = _ from funext fun _ => deriv_L_minus1 _ ] ; exact continuousOn_const;
  · apply_rules [ ContinuousOn.intervalIntegrable ];
    refine' ContinuousOn.mul continuousOn_const _;
    refine' ContinuousOn.mul _ _;
    · refine' ContinuousOn.div _ _ _;
      · refine' Continuous.continuousOn _;
        exact Complex.continuous_exp.comp <| Complex.continuous_exp.comp <| by unfold L_minus1_witness; continuity;
      · exact Continuous.continuousOn ( by unfold L_minus1_witness; continuity );
      · exact fun t ht => sub_ne_zero_of_ne <| L_minus1_witness_ne_z t z hz;
    · exact Continuous.continuousOn ( by rw [ show deriv L_minus1_witness = fun t => 2 * Real.pi * Complex.I from funext fun t => deriv_L_minus1 t ] ; continuity )

lemma E_witness_eq_formula_v2 (z : ℂ) (hz : z ∈ rectangle) :
  E_witness z = Complex.exp (Complex.exp z) - 1/z +
    1/(z^2) * (1/(2 * Real.pi * Complex.I)) *
      pathIntegral L_minus1_witness 1
        (fun ζ => (-ζ + ζ^2/(ζ - z)) * Complex.exp (Complex.exp ζ)) := by
          -- Apply the lemma E_witness_eq_formula with the given hypothesis hz.
          apply E_witness_eq_formula z hz

noncomputable def integrand (t : ℝ) (z : ℂ) : ℂ := 
  Complex.exp (Complex.exp (L_minus1_witness t)) / (L_minus1_witness t - z) * deriv L_minus1_witness t

noncomputable def integrand_deriv (t : ℝ) (z : ℂ) : ℂ :=
  Complex.exp (Complex.exp (L_minus1_witness t)) / (L_minus1_witness t - z)^2 * deriv L_minus1_witness t

#check intervalIntegral.hasDerivAt_integral_of_dominated_loc_of_deriv_le

noncomputable def bound_function (t : ℝ) : ℝ := 
  norm (Complex.exp (Complex.exp (L_minus1_witness t)) * (2 * Real.pi * Complex.I))

lemma bound_function_integrable : IntervalIntegrable bound_function MeasureTheory.volume 0 1 := by
  apply Continuous.intervalIntegrable
  unfold bound_function L_minus1_witness
  continuity

lemma differentiable_E_witness : DifferentiableOn ℂ E_witness {z | z.re > -1} := by
  -- The integral of a differentiable function is differentiable, so the integral part of E_witness is differentiable.
  have h_integral_diff : DifferentiableOn ℂ (fun z => ∫ t in (0 : ℝ)..1, (Complex.exp (Complex.exp (L_minus1_witness t))) / (L_minus1_witness t - z)) {z | z.re > -1} := by
    -- The integral of a differentiable function over a compact interval is differentiable, and the derivative can be computed using the Leibniz rule.
    have h_diff : ∀ z ∈ {z : ℂ | z.re > -1}, HasDerivAt (fun z => ∫ t in (0 : ℝ)..1, Complex.exp (Complex.exp (L_minus1_witness t)) / (L_minus1_witness t - z)) (∫ t in (0 : ℝ)..1, Complex.exp (Complex.exp (L_minus1_witness t)) / (L_minus1_witness t - z)^2) z := by
      intro z hz;
      rw [ hasDerivAt_iff_tendsto_slope_zero ];
      -- Apply the dominated convergence theorem to interchange the limit and the integral.
      have h_dominate : Filter.Tendsto (fun t => ∫ u in (0 : ℝ)..1, (Complex.exp (Complex.exp (L_minus1_witness u)) / ((L_minus1_witness u - (z + t)) * (L_minus1_witness u - z)))) (nhdsWithin 0 {0}ᶜ) (nhds (∫ u in (0 : ℝ)..1, (Complex.exp (Complex.exp (L_minus1_witness u)) / ((L_minus1_witness u - z)^2)))) := by
        refine' intervalIntegral.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _;
        use fun x => ‖Complex.exp (Complex.exp (L_minus1_witness x))‖ / (1 / 2) ^ 2;
        · refine' Filter.eventually_of_mem self_mem_nhdsWithin fun n hn => Measurable.aestronglyMeasurable _;
          -- The function $L_minus1_witness$ is continuous, hence measurable.
          have hL_minus1_witness_measurable : Measurable L_minus1_witness := by
            exact Continuous.measurable ( by unfold L_minus1_witness; continuity );
          fun_prop;
        · -- Since $|L_minus1_witness x - z| \geq 1$ and $|L_minus1_witness x - (z + n)| \geq 1/2$ for $n$ close to $0$, we have:
          have h_bound : ∀ᶠ n in nhdsWithin 0 {0}ᶜ, ∀ x ∈ Set.Icc (0 : ℝ) 1, ‖L_minus1_witness x - (z + n)‖ ≥ 1 / 2 ∧ ‖L_minus1_witness x - z‖ ≥ 1 := by
            rw [ eventually_nhdsWithin_iff ];
            rw [ Metric.eventually_nhds_iff ];
            use 1 / 2; norm_num;
            intro y hy hy' x hx₁ hx₂; refine' ⟨ _, _ ⟩;
            · have := norm_sub_le ( L_minus1_witness x - z ) ( y ) ; norm_num [ Complex.normSq, Complex.norm_def ] at *;
              rw [ Real.sqrt_lt' ] at hy <;> norm_num [ L_minus1_witness ] at *;
              exact Real.le_sqrt_of_sq_le ( by nlinarith [ sq_nonneg ( z.re + 1 ), sq_nonneg ( z.im + 1 ), Real.pi_gt_three, mul_le_mul_of_nonneg_left hx₂ Real.pi_pos.le ] );
            · have := normSq_L_minus1_witness_sub_z_ge_one x z hz;
              exact Real.le_sqrt_of_sq_le ( by simpa [ Complex.normSq_eq_norm_sq ] using this );
          filter_upwards [ h_bound ] with n hn;
          norm_num +zetaDelta at *;
          filter_upwards [ ] with x hx₁ hx₂ using by rw [ div_le_iff₀ ] <;> nlinarith [ hn x hx₁.le hx₂, show 0 < ‖cexp ( cexp ( L_minus1_witness x ) )‖ from norm_pos_iff.mpr <| Complex.exp_ne_zero _, mul_le_mul_of_nonneg_left ( hn x hx₁.le hx₂ |>.1 ) <| show 0 ≤ ‖cexp ( cexp ( L_minus1_witness x ) )‖ from norm_nonneg _ ] ;
        · -- The function ‖cexp (cexp (L_minus1_witness x))‖ is continuous on the compact interval [0, 1], hence it is integrable.
          have h_cont : ContinuousOn (fun x => ‖cexp (cexp (L_minus1_witness x))‖) (Set.Icc 0 1) := by
            exact Continuous.continuousOn ( by unfold L_minus1_witness; continuity );
          exact ( h_cont.intervalIntegrable_of_Icc ( by norm_num ) ) |> fun h => h.div_const _;
        · refine' Filter.Eventually.of_forall fun x hx => _;
          convert tendsto_const_nhds.div ( Continuous.continuousWithinAt ( show Continuous fun n : ℂ => ( L_minus1_witness x - ( z + n ) ) * ( L_minus1_witness x - z ) from by continuity ) ) _ using 2 <;> norm_num [ sq ];
          exact sub_ne_zero_of_ne <| L_minus1_witness_ne_z x z hz;
      refine' h_dominate.congr' _;
      rw [ Filter.EventuallyEq, eventually_nhdsWithin_iff ];
      rw [ Metric.eventually_nhds_iff ];
      refine' ⟨ 1 / 2, by norm_num, fun y hy hy' => _ ⟩;
      rw [ ← intervalIntegral.integral_sub ];
      · rw [ ← intervalIntegral.integral_smul ] ; refine' intervalIntegral.integral_congr fun u hu => _ ; rw [ div_sub_div ] ; ring;
        · simp +decide [ mul_assoc, mul_comm, mul_left_comm, hy' ];
          grind;
        · norm_num [ Complex.ext_iff, L_minus1_witness ] at *;
          intro h; linarith [ abs_le.mp ( Complex.abs_re_le_norm y ) ] ;
        · exact sub_ne_zero_of_ne <| L_minus1_witness_ne_z u z hz;
      · apply_rules [ ContinuousOn.intervalIntegrable ];
        refine' continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.div _ _ _;
        · -- The exponential function is continuous, and the composition of continuous functions is continuous.
          have h_cont : Continuous (fun t : ℝ => Complex.exp (Complex.exp (L_minus1_witness t))) := by
            exact Complex.continuous_exp.comp <| Complex.continuous_exp.comp <| by unfold L_minus1_witness; continuity;
          exact h_cont.continuousAt;
        · exact Continuous.continuousAt ( by unfold L_minus1_witness; continuity );
        · norm_num [ Complex.ext_iff, L_minus1_witness ] at *;
          intro h; linarith [ abs_le.mp ( Complex.abs_re_le_norm y ) ] ;
      · apply_rules [ ContinuousOn.intervalIntegrable ];
        -- The denominator $L_minus1_witness t - z$ is never zero on $[0, 1]$ because $z.re > -1$ and $L_minus1_witness t$ has a real part of $-2$.
        have h_denom_ne_zero : ∀ t ∈ Set.Icc (0 : ℝ) 1, L_minus1_witness t - z ≠ 0 := by
          exact fun t ht => sub_ne_zero_of_ne <| ne_of_apply_ne Complex.re <| by norm_num [ L_minus1_witness ] ; linarith [ hz.out ] ;
        exact ContinuousOn.div ( Complex.continuous_exp.comp_continuousOn <| Complex.continuous_exp.comp_continuousOn <| by exact Continuous.continuousOn <| by unfold L_minus1_witness; continuity ) ( ContinuousOn.sub ( by exact Continuous.continuousOn <| by unfold L_minus1_witness; continuity ) continuousOn_const ) fun t ht => h_denom_ne_zero t <| by simpa using ht;
    exact fun z hz => ( h_diff z hz |> HasDerivAt.differentiableAt |> DifferentiableAt.differentiableWithinAt );
  apply_rules [ DifferentiableOn.add, DifferentiableOn.mul, DifferentiableOn.cexp, differentiableOn_id, differentiableOn_const ];
  unfold pathIntegral;
  convert h_integral_diff.const_mul ( deriv L_minus1_witness 0 ) using 2 ; norm_num [ deriv_L_minus1 ];
  ring

lemma differentiable_E_witness_proven : DifferentiableOn ℂ E_witness {z | z.re > -1} := by
  -- By definition of $E_witness$, we know that it is differentiable on the set where $z.re > -1$.
  apply differentiable_E_witness

lemma differentiableAt_pathIntegral_term (z0 : ℂ) (hz0 : z0.re > -1) :
  DifferentiableAt ℂ (fun z => pathIntegral L_minus1_witness 1 (fun ζ => Complex.exp (Complex.exp ζ) / (ζ - z))) z0 := by
    have h_diff : DifferentiableOn ℂ E_witness {z : ℂ | z.re > -1} := by
      -- Apply the fact that the sum of differentiable functions is differentiable.
      apply differentiable_E_witness_proven;
    have h_diff_int : DifferentiableAt ℂ (fun z => E_witness z - Complex.exp (Complex.exp z)) z0 := by
      exact DifferentiableAt.sub ( h_diff.differentiableAt ( IsOpen.mem_nhds ( isOpen_lt continuous_const Complex.continuous_re ) hz0 ) ) ( Complex.differentiableAt_exp.comp z0 ( Complex.differentiableAt_exp ) );
    convert h_diff_int.mul_const ( 2 * Real.pi * Complex.I ) using 1 ; unfold E_witness ; norm_num ; ring;
    norm_num [ Real.pi_ne_zero ]

theorem problem_160_analytic_continuation :
    ∃ (E : ℂ → ℂ) (L_minus1 : ℝ → ℂ),
      DifferentiableOn ℂ E {z | z.re > -1} ∧
      ContinuousOn L_minus1 (Set.Icc 0 1) ∧
      ∀ z ∈ rectangle,
        E z = Complex.exp (Complex.exp z) - 1/z + 
          1/(z^2) * (1/(2 * Real.pi * Complex.I)) *
            pathIntegral L_minus1 1 
              (fun ζ => (-ζ + ζ^2/(ζ - z)) * Complex.exp (Complex.exp ζ)) := by
  use E_witness, L_minus1_witness
  refine ⟨?_, ?_, ?_⟩
  · exact differentiable_E_witness_proven
  · exact continuousOn_L_minus1
  · intro z hz
    apply E_witness_eq_formula_v2 z hz

theorem problem_160_analytic_continuation_proven :
    ∃ (E : ℂ → ℂ) (L_minus1 : ℝ → ℂ),
      DifferentiableOn ℂ E {z | z.re > -1} ∧
      ContinuousOn L_minus1 (Set.Icc 0 1) ∧
      ∀ z ∈ rectangle,
        E z = Complex.exp (Complex.exp z) - 1/z + 
          1/(z^2) * (1/(2 * Real.pi * Complex.I)) *
            pathIntegral L_minus1 1 
              (fun ζ => (-ζ + ζ^2/(ζ - z)) * Complex.exp (Complex.exp ζ)) := by
  use E_witness, L_minus1_witness
  refine ⟨?_, ?_, ?_⟩
  · exact differentiable_E_witness_proven
  · exact continuousOn_L_minus1
  · intro z hz
    apply E_witness_eq_formula_v2 z hz