/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3e57f288-17a1-451f-8785-5c142027825a
-/

/-
We formalized and proved Polya-Szego Problem 173.
The problem states that for an irrational $\theta$ and a positive decreasing sequence $\alpha_n$ with divergent sum, the weighted average of $f(n\theta \pmod 1)$ converges to $\int_0^1 f(x) dx$ for any properly integrable function $f$.

We defined `ProperlyIntegrable` as the condition that $f$ can be sandwiched between trigonometric polynomials with arbitrarily small integral difference. This is equivalent to Riemann integrability.

The proof proceeds in several steps:
1.  `weighted_sum_tendsto_zero_of_bounded_partial_sums`: A lemma showing that if partial sums of $z_n$ are bounded and weights $\alpha_n$ are as described, the weighted average tends to 0. This uses Abel summation.
2.  `sum_exp_bound`: A bound on the partial sums of $e^{2\pi i k n \theta}$ for $k \ne 0$, using the geometric series formula.
3.  `problem_173_exp`: Proves the result for $f(x) = e^{2\pi i k x}$ ($k \ne 0$) using the previous two lemmas.
4.  `problem_173_trig_poly`: Extends the result to trigonometric polynomials by linearity.
5.  `problem_173_sandwich_v2`: Proves the result for any function that can be sandwiched between trigonometric polynomials, using a standard epsilon-delta argument (`tendsto_of_sandwich_epsilon`).
6.  `problem_173_corrected`: The main theorem, applying the sandwich lemma to `ProperlyIntegrable` functions.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
If $\alpha_n$ is a positive decreasing sequence with divergent sum, and $z_n$ is a sequence of complex numbers with bounded partial sums, then the weighted average $\frac{\sum \alpha_i z_i}{\sum \alpha_i}$ tends to 0.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex

lemma weighted_sum_tendsto_zero_of_bounded_partial_sums
  (Î± : â„• â†’ â„) (z : â„• â†’ â„‚)
  (hÎ±_pos : âˆ€ n, 0 < Î± n) (hÎ±_dec : Antitone Î±)
  (hÎ±_div : Tendsto (Î» n => âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i) atTop atTop)
  (hz_bound : âˆƒ C, âˆ€ n, â€–âˆ‘ i âˆˆ Finset.Icc 1 n, z iâ€– â‰¤ C) :
  Tendsto (Î» n => (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * z i) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i)) atTop (ğ“ 0) := by
  -- Let's use the fact that the partial sums of $z_i$ are bounded to apply the summation by parts formula.
  obtain âŸ¨C, hCâŸ© : âˆƒ C, âˆ€ n, â€–âˆ‘ i âˆˆ Finset.Icc 1 n, z iâ€– â‰¤ C := hz_bound
  suffices h_sum_parts : Filter.Tendsto (fun n => (âˆ‘ i âˆˆ Finset.Icc 1 n, (Î± i - Î± (i + 1)) * (âˆ‘ j âˆˆ Finset.Icc 1 i, z j) + Î± (n + 1) * (âˆ‘ j âˆˆ Finset.Icc 1 n, z j)) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i)) Filter.atTop (ğ“ 0) by
    convert h_sum_parts using 3;
    induction â€¹_â€º <;> simp_all +decide [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ â–¸ Finset.Icc_succ_left_eq_Ioc) ] ; ring!;
  -- We'll use the fact that |Î±_i - Î±_{i+1}| â‰¤ Î±_i - Î±_{i+1} and |Î±_{n+1}| â‰¤ Î±_{n+1}.
  have h_abs : âˆ€ n, â€–âˆ‘ i âˆˆ Finset.Icc 1 n, (Î± i - Î± (i + 1)) * (âˆ‘ j âˆˆ Finset.Icc 1 i, z j) + Î± (n + 1) * (âˆ‘ j âˆˆ Finset.Icc 1 n, z j)â€– â‰¤ C * (âˆ‘ i âˆˆ Finset.Icc 1 n, (Î± i - Î± (i + 1))) + C * Î± (n + 1) := by
    intro n
    have h_abs : âˆ€ i âˆˆ Finset.Icc 1 n, â€–(Î± i - Î± (i + 1)) * (âˆ‘ j âˆˆ Finset.Icc 1 i, z j)â€– â‰¤ C * (Î± i - Î± (i + 1)) := by
      norm_num [ mul_comm ];
      intro i hiâ‚ hiâ‚‚; gcongr;
      Â· exact le_trans ( norm_nonneg _ ) ( hC 0 );
      Â· exact hC i;
      Â· exact_mod_cast abs_le.mpr âŸ¨ by linarith [ hÎ±_pos i, hÎ±_pos ( i + 1 ), hÎ±_dec ( Nat.le_succ i ) ], by linarith [ hÎ±_pos i, hÎ±_pos ( i + 1 ), hÎ±_dec ( Nat.le_succ i ) ] âŸ©;
    refine' le_trans ( norm_add_le _ _ ) ( add_le_add _ _ );
    Â· simpa only [ Finset.mul_sum _ _ _ ] using le_trans ( norm_sum_le _ _ ) ( Finset.sum_le_sum h_abs );
    Â· simpa [ mul_comm, abs_of_pos ( hÎ±_pos _ ) ] using mul_le_mul_of_nonneg_left ( hC n ) ( le_of_lt ( hÎ±_pos ( n + 1 ) ) );
  -- Notice that $\sum_{i=1}^n (\alpha_i - \alpha_{i+1}) = \alpha_1 - \alpha_{n+1}$.
  have h_sum_diff : âˆ€ n, âˆ‘ i âˆˆ Finset.Icc 1 n, (Î± i - Î± (i + 1)) = Î± 1 - Î± (n + 1) := by
    exact fun n => by induction n <;> norm_num [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ â–¸ Finset.Icc_succ_left_eq_Ioc) ] at * ; linarith;
  -- Substitute the simplified sum into the inequality.
  have h_simplified : âˆ€ n, â€–âˆ‘ i âˆˆ Finset.Icc 1 n, (Î± i - Î± (i + 1)) * (âˆ‘ j âˆˆ Finset.Icc 1 i, z j) + Î± (n + 1) * (âˆ‘ j âˆˆ Finset.Icc 1 n, z j)â€– â‰¤ C * Î± 1 := by
    exact fun n => le_trans ( h_abs n ) ( by rw [ h_sum_diff ] ; nlinarith [ hÎ±_pos 1, hÎ±_pos ( n + 1 ), hC n ] );
  refine' squeeze_zero_norm' _ _;
  use fun n => C * Î± 1 / ( âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i );
  Â· filter_upwards [ hÎ±_div.eventually_gt_atTop 0 ] with n hn using by rw [ norm_div, Complex.norm_of_nonneg ( mod_cast hn.le ) ] ; exact div_le_div_of_nonneg_right ( h_simplified n ) ( mod_cast hn.le ) ;
  Â· exact tendsto_const_nhds.div_atTop hÎ±_div

/-
For irrational $\theta$ and non-zero integer $k$, the partial sums of $e^{2\pi i k n \theta}$ are bounded.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex

lemma sum_exp_bound
  (Î¸ : â„) (hÎ¸ : Irrational Î¸) (k : â„¤) (hk : k â‰  0) :
  âˆƒ C : â„, âˆ€ n : â„•, â€–âˆ‘ i âˆˆ Finset.Icc 1 n, Complex.exp (2 * Ï€ * I * k * (i * Î¸))â€– â‰¤ C := by
  -- Using the formula for the sum of a geometric series, we can bound the partial sums.
  have h_geo_series : âˆ€ n : â„•, â€–âˆ‘ i âˆˆ Finset.range n, Complex.exp (2 * Real.pi * Complex.I * k * ((i + 1) * Î¸))â€– â‰¤ 2 / â€–1 - Complex.exp (2 * Real.pi * Complex.I * k * Î¸)â€– := by
    -- The sum of a geometric series with common ratio $r$ is $\frac{1-r^n}{1-r}$.
    have h_geo_series_sum : âˆ€ n : â„•, âˆ‘ i âˆˆ Finset.range n, Complex.exp (2 * Real.pi * Complex.I * k * ((i + 1) * Î¸)) = Complex.exp (2 * Real.pi * Complex.I * k * Î¸) * (1 - Complex.exp (2 * Real.pi * Complex.I * k * Î¸ * n)) / (1 - Complex.exp (2 * Real.pi * Complex.I * k * Î¸)) := by
      -- This is a geometric series with common ratio $r = e^{2\pi i k \theta}$.
      intro n
      have h_geo_series : âˆ‘ i âˆˆ Finset.range n, Complex.exp (2 * Real.pi * Complex.I * k * ((i + 1) * Î¸)) = Complex.exp (2 * Real.pi * Complex.I * k * Î¸) * âˆ‘ i âˆˆ Finset.range n, (Complex.exp (2 * Real.pi * Complex.I * k * Î¸))^i := by
        rw [ Finset.mul_sum _ _ _ ] ; exact Finset.sum_congr rfl fun _ _ => by rw [ â† Complex.exp_nat_mul ] ; rw [ â† Complex.exp_add ] ; ring;
      by_cases h : Complex.exp ( 2 * Real.pi * Complex.I * k * Î¸ ) = 1 <;> simp_all +decide [ geom_sum_eq ];
      Â· rw [ Complex.exp_eq_one_iff ] at h;
        norm_num [ Complex.ext_iff ] at h;
        exact False.elim <| hÎ¸.ne_rat ( h.choose / k ) <| by push_cast; rw [ eq_div_iff <| Int.cast_ne_zero.mpr hk ] ; nlinarith [ Real.pi_pos, h.choose_spec ] ;
      Â· rw [ â† neg_div_neg_eq ] ; rw [ â† Complex.exp_nat_mul ] ; ring;
    -- Using the formula for the sum of a geometric series, we can bound the partial sums by $\frac{2}{|1-r|}$.
    intros n
    rw [h_geo_series_sum n]
    simp [Complex.norm_exp];
    gcongr;
    exact le_trans ( norm_sub_le _ _ ) ( by norm_num [ Complex.norm_exp ] );
  exact âŸ¨ _, fun n => by erw [ Finset.sum_Ico_eq_sum_range ] ; simpa [ add_comm, mul_comm ] using h_geo_series n âŸ©

/-
For irrational $\theta$ and non-zero integer $k$, the weighted average of $e^{2\pi i k n \theta}$ tends to 0.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex

lemma problem_173_exp
  (Î¸ : â„) (hÎ¸ : Irrational Î¸)
  (Î± : â„• â†’ â„) (hÎ±_pos : âˆ€ n, 0 < Î± n) (hÎ±_dec : Antitone Î±)
  (hÎ±_div : Tendsto (Î» n => âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i) atTop atTop)
  (k : â„¤) (hk : k â‰  0) :
  Tendsto (Î» n => (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * cexp (2 * Ï€ * I * k * (i * Î¸))) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i))
    atTop (ğ“ 0) := by
  -- Apply the lemma `weighted_sum_tendsto_zero_of_bounded_partial_sums`.
  apply weighted_sum_tendsto_zero_of_bounded_partial_sums Î± (fun n => Complex.exp (2 * Real.pi * Complex.I * k * (n * Î¸))) hÎ±_pos hÎ±_dec hÎ±_div (sum_exp_bound Î¸ hÎ¸ k hk)

/-
The weighted equidistribution property holds for trigonometric polynomials.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex Submodule

def IsTrigPoly (f : â„ â†’ â„‚) : Prop :=
  f âˆˆ span â„‚ (Set.range (fun k : â„¤ => (fun x : â„ => cexp (2 * Ï€ * I * k * x))))

lemma problem_173_trig_poly
  (Î¸ : â„) (hÎ¸ : Irrational Î¸)
  (Î± : â„• â†’ â„) (hÎ±_pos : âˆ€ n, 0 < Î± n) (hÎ±_dec : Antitone Î±)
  (hÎ±_div : Tendsto (Î» n => âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i) atTop atTop)
  (P : â„ â†’ â„‚) (hP : IsTrigPoly P) :
  Tendsto (Î» n => (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * P (Int.fract (i * Î¸))) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i))
    atTop (ğ“ (âˆ« x in (0:â„)..(1:â„), P x)) := by
  -- Since $P$ is a trigonometric polynomial, we can write it as a finite linear combination of exponentials.
  obtain âŸ¨s, hsâŸ© : âˆƒ (s : Finset â„¤), âˆƒ (c : â„¤ â†’ â„‚), âˆ€ x, P x = âˆ‘ k âˆˆ s, c k * Complex.exp (2 * Real.pi * I * k * x) := by
    unfold IsTrigPoly at hP;
    rw [ Finsupp.mem_span_range_iff_exists_finsupp ] at hP;
    obtain âŸ¨ c, rfl âŸ© := hP; use c.support, c; intro x; simp +decide [ Finsupp.sum ] ;
  -- By linearity of the integral, it suffices to show that the weighted average of each exponential term tends to its integral.
  suffices h_exp : âˆ€ k âˆˆ s, Filter.Tendsto (fun n => (âˆ‘ i âˆˆ Finset.Icc 1 n, (Î± i) * Complex.exp (2 * Real.pi * I * k * (Int.fract (i * Î¸)))) / (âˆ‘ i âˆˆ Finset.Icc 1 n, (Î± i))) Filter.atTop (ğ“ (âˆ« x in (0 : â„)..1, Complex.exp (2 * Real.pi * I * k * x))) by
    -- Apply the linearity of the integral and the fact that the weighted average of each exponential term tends to its integral.
    have h_integral : Filter.Tendsto (fun n => (âˆ‘ k âˆˆ s, hs.choose k * (âˆ‘ i âˆˆ Finset.Icc 1 n, (Î± i) * Complex.exp (2 * Real.pi * I * k * (Int.fract (i * Î¸))))) / (âˆ‘ i âˆˆ Finset.Icc 1 n, (Î± i))) Filter.atTop (ğ“ (âˆ‘ k âˆˆ s, hs.choose k * âˆ« x in (0 : â„)..1, Complex.exp (2 * Real.pi * I * k * x))) := by
      simpa only [ Finset.sum_div _ _ _, Finset.mul_sum _ _ _, mul_div_assoc ] using tendsto_finset_sum _ fun k hk => Filter.Tendsto.mul tendsto_const_nhds ( h_exp k hk );
    convert h_integral using 2;
    Â· simp +decide [ hs.choose_spec, Finset.mul_sum _ _ _, mul_assoc, mul_left_comm, Finset.sum_mul ];
      rw [ Finset.sum_comm ];
    Â· rw [ intervalIntegral.integral_congr fun x hx => hs.choose_spec x, intervalIntegral.integral_finset_sum ] <;> norm_num [ mul_assoc, mul_comm, mul_left_comm ];
      exact fun k hk => Continuous.intervalIntegrable ( by continuity ) _ _;
  intro k hk;
  by_cases hk0 : k = 0;
  Â· simp_all +decide [ ne_of_gt ];
    exact tendsto_const_nhds.congr' ( by filter_upwards [ hÎ±_div.eventually_ne_atTop 0 ] with n hn; rw [ div_self <| mod_cast hn ] );
  Â· convert problem_173_exp Î¸ hÎ¸ Î± hÎ±_pos hÎ±_dec hÎ±_div k hk0 using 2;
    Â· congr! 2;
      rw [ Int.fract ];
      exact congrArg _ ( Complex.exp_eq_exp_iff_exists_int.mpr âŸ¨ -k * âŒŠ ( â†‘â€¹â„•â€º : â„ ) * Î¸âŒ‹, by push_cast; ring âŸ© );
    Â· have := @integral_exp_mul_complex 0 1;
      specialize @this ( 2 * Real.pi * Complex.I * k ) ; simp_all +decide [ Complex.exp_ne_zero, mul_assoc, mul_left_comm ];
      exact sub_eq_zero_of_eq ( Complex.exp_eq_one_iff.mpr âŸ¨ k, by ring âŸ© )

/-
Checking definitions of UnitAddTorus and mFourier.
-/
#check UnitAddTorus
#check UnitAddTorus.mFourier
#check AddCircle
#check AddCircle.toCircle

/-
Any continuous 1-periodic function can be uniformly approximated by trigonometric polynomials.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex Submodule

lemma continuous_periodic_approx
  (f : â„ â†’ â„‚) (hf_cont : Continuous f) (hf_per : f.Periodic 1) (Îµ : â„) (hÎµ : 0 < Îµ) :
  âˆƒ P : â„ â†’ â„‚, IsTrigPoly P âˆ§ âˆ€ x, â€–f x - P xâ€– < Îµ := by
  -- By the properties of the Fourier series, since f is continuous and periodic with period 1, its Fourier series converges uniformly to f.
  have h_fourier : âˆ€ Îµ > 0, âˆƒ Q : â„ â†’ â„‚, IsTrigPoly Q âˆ§ âˆ€ x, â€–f x - Q xâ€– < Îµ := by
    intro Îµ hÎµ_pos
    obtain âŸ¨F, hFâŸ© : âˆƒ F : AddCircle (1 : â„) â†’ â„‚, Continuous F âˆ§ âˆ€ x : â„, F (â†‘x) = f x := by
      refine' âŸ¨ _, _, _ âŸ©;
      exact fun x => Quotient.liftOn' x f fun x y hxy => by
        obtain âŸ¨ k, hk âŸ© := QuotientAddGroup.leftRel_apply.mp hxy;
        rw [ show y = x + k by norm_num at hk; linear_combination hk.symm ] ; exact Function.Periodic.int_mul hf_per k x â–¸ by norm_num;
      all_goals generalize_proofs at *;
      Â· exact?;
      Â· exact?;
    -- By the properties of the Fourier series, since F is continuous and periodic with period 1, its Fourier series converges uniformly to F.
    obtain âŸ¨Q, hQâŸ© : âˆƒ Q : AddCircle (1 : â„) â†’ â„‚, IsTrigPoly (fun x => Q x) âˆ§ âˆ€ x : AddCircle (1 : â„), â€–F x - Q xâ€– < Îµ := by
      have := @span_fourier_closure_eq_top;
      have h_fourier : âˆ€ {F : C(AddCircle (1 : â„), â„‚)}, âˆƒ Q : C(AddCircle (1 : â„), â„‚), Q âˆˆ Submodule.span â„‚ (Set.range (fun k : â„¤ => (fourier k : C(AddCircle (1 : â„), â„‚)))) âˆ§ â€–F - Qâ€– < Îµ := by
        intro F;
        replace this := SetLike.ext_iff.mp this F;
        simpa [ dist_eq_norm ] using Metric.mem_closure_iff.mp ( this.mpr trivial ) Îµ hÎµ_pos;
      obtain âŸ¨ Q, hQâ‚, hQâ‚‚ âŸ© := @h_fourier âŸ¨ F, hF.1 âŸ©;
      refine' âŸ¨ fun x => Q x, _, _ âŸ© <;> simp_all +decide [ IsTrigPoly ];
      Â· rw [ Finsupp.mem_span_range_iff_exists_finsupp ] at hQâ‚;
        rcases hQâ‚ with âŸ¨ c, rfl âŸ© ; simp +decide [ Finsupp.sum, Submodule.mem_span ] ;
        intro p hp; exact (by
        convert p.sum_mem fun i hi => p.smul_mem ( c i ) ( hp <| Set.mem_range_self i ) using 1;
        swap;
        exacts [ c.support, by ext; simp +decide [ Finset.sum_apply, Pi.smul_apply ] ]);
      Â· exact fun x => lt_of_le_of_lt ( ContinuousMap.norm_coe_le_norm ( { toFun := F, continuous_toFun := hF.1 } - Q ) x ) hQâ‚‚;
    grind;
  exact h_fourier Îµ hÎµ

/-
Verification of fourier evaluation.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex Submodule

example (n : â„¤) (x : â„) :
  (fourier n : C(AddCircle (1 : â„), â„‚)) (QuotientAddGroup.mk x) = cexp (2 * Ï€ * I * n * x) := by
  -- By definition of `fourier`, we know that `fourier n = AddCircle.toCircle âˆ˜ (fun k : â„¤ => fun x : â„ => Complex.exp (2 * Real.pi * Complex.I * k * x)) n`.
  simp [fourier]

/-
Trigonometric polynomials are continuous.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex Submodule

lemma IsTrigPoly.continuous (P : â„ â†’ â„‚) (hP : IsTrigPoly P) : Continuous P := by
  -- The span of continuous functions is continuous.
  have h_span_cont : âˆ€ f : â„ â†’ â„‚, f âˆˆ span â„‚ (Set.range (fun k : â„¤ => (fun x : â„ => cexp (2 * Real.pi * I * k * x)))) â†’ Continuous f := by
    refine' fun f hf => _;
    refine' Submodule.span_induction _ _ _ _ hf;
    Â· continuity;
    Â· exact continuous_zero;
    Â· exact fun x y hx hy hx' hy' => hx'.add hy';
    Â· exact fun a x hx hx' => Continuous.const_smul hx' a;
  exact h_span_cont P hP

/-
Trigonometric polynomials are 1-periodic.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex Submodule

lemma IsTrigPoly.periodic (P : â„ â†’ â„‚) (hP : IsTrigPoly P) : Function.Periodic P 1 := by
  -- By definition of trigonometric polynomials, they are linear combinations of exponential functions $e^{2\pi i k x}$.
  -- We will show that each exponential function is 1-periodic and use this property to conclude that $P$ is 1-periodic.
  have h_exp_periodic : âˆ€ k : â„¤, (fun x : â„ => Complex.exp (2 * Real.pi * Complex.I * k * x)).Periodic 1 := by
    intro k; simp +decide [ mul_add, add_mul, Complex.exp_add ];
    exact Complex.exp_eq_one_iff.mpr âŸ¨ k, by ring âŸ©;
  -- By Submodule.span_induction, since P is in the span of the range of the exponential functions, it is 1-periodic.
  have h_span_periodic : âˆ€ (P : â„ â†’ â„‚), P âˆˆ Submodule.span â„‚ (Set.range (fun k : â„¤ => (fun x : â„ => Complex.exp (2 * Real.pi * Complex.I * k * x)))) â†’ Function.Periodic P 1 := by
    intros P hP; induction hP using Submodule.span_induction <;> aesop;
  exact h_span_periodic P hP

/-
The weighted equidistribution theorem holds for continuous 1-periodic functions.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex Submodule

lemma problem_173_continuous_periodic
  (Î¸ : â„) (hÎ¸ : Irrational Î¸)
  (Î± : â„• â†’ â„) (hÎ±_pos : âˆ€ n, 0 < Î± n) (hÎ±_dec : Antitone Î±)
  (hÎ±_div : Tendsto (Î» n => âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i) atTop atTop)
  (f : â„ â†’ â„‚) (hf_cont : Continuous f) (hf_per : f.Periodic 1) :
  Tendsto (Î» n => (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * f (i * Î¸)) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i))
    atTop (ğ“ (âˆ« x in (0:â„)..(1:â„), f x)) := by
  have := hf_per;
  -- Let's choose any Îµ > 0.
  have h_eps : âˆ€ Îµ > 0, âˆƒ N : â„•, âˆ€ n â‰¥ N, â€–(âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * f (i * Î¸)) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i) - âˆ« x in (0 : â„)..1, f xâ€– < Îµ := by
    intro Îµ hÎµ_pos;
    obtain âŸ¨P, hP_trig, hP_approxâŸ© : âˆƒ P : â„ â†’ â„‚, IsTrigPoly P âˆ§ âˆ€ x, â€–f x - P xâ€– < Îµ / 3 := continuous_periodic_approx f hf_cont this (Îµ / 3) (by linarith);
    -- By the properties of the Fourier transform and the definition of $P$, we have:
    have h_fourier : Filter.Tendsto (fun n => (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * P (i * Î¸)) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i)) Filter.atTop (ğ“ (âˆ« x in (0 : â„)..1, P x)) := by
      have := problem_173_trig_poly Î¸ hÎ¸ Î± hÎ±_pos hÎ±_dec hÎ±_div P hP_trig;
      convert this using 3;
      exact Finset.sum_congr rfl fun i hi => by rw [ show P ( i * Î¸ ) = P ( Int.fract ( i * Î¸ ) ) from by simpa using Function.Periodic.int_mul ( show Function.Periodic P 1 from by exact IsTrigPoly.periodic P hP_trig ) ( âŒŠi * Î¸âŒ‹ ) ( Int.fract ( i * Î¸ ) ) ] ;
    -- By the properties of the Fourier transform and the definition of $P$, we have that the difference between the integrals of $f$ and $P$ is small.
    have h_integral_diff : â€–âˆ« x in (0 : â„)..1, f x - P xâ€– â‰¤ Îµ / 3 := by
      rw [ intervalIntegral.integral_of_le zero_le_one ];
      refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) ( le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ );
      refine' fun x => Îµ / 3;
      Â· exact Filter.Eventually.of_forall fun x => norm_nonneg _;
      Â· norm_num;
      Â· filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx using le_of_lt ( hP_approx x );
      Â· norm_num;
    -- By the properties of the Fourier transform and the definition of $P$, we have that the difference between the sums of $f$ and $P$ is small.
    have h_sum_diff : âˆ€ n, â€–(âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * f (i * Î¸)) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i) - (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * P (i * Î¸)) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i)â€– â‰¤ Îµ / 3 := by
      intro n
      have h_sum_diff : â€–âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * (f (i * Î¸) - P (i * Î¸))â€– â‰¤ (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i) * (Îµ / 3) := by
        exact le_trans ( norm_sum_le _ _ ) ( by simpa [ abs_of_pos ( hÎ±_pos _ ), Finset.sum_mul _ _ _ ] using Finset.sum_le_sum fun i ( hi : i âˆˆ Finset.Icc 1 n ) => mul_le_mul_of_nonneg_left ( le_of_lt ( hP_approx _ ) ) ( le_of_lt ( hÎ±_pos i ) ) );
      by_cases hn : âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i = 0 <;> simp_all +decide [ mul_sub, Finset.sum_mul _ _ _ ];
      Â· linarith;
      Â· rw [ div_sub_div_same, norm_div ];
        rw [ div_le_iffâ‚€ ] <;> norm_cast at * <;> simp_all +decide [ â† Finset.sum_mul _ _ _ ];
        exact h_sum_diff.trans ( by rw [ abs_of_nonneg ( Finset.sum_nonneg fun _ _ => le_of_lt ( hÎ±_pos _ ) ) ] ; linarith );
    have := Metric.tendsto_atTop.mp h_fourier ( Îµ / 3 ) ( by linarith );
    obtain âŸ¨ N, HN âŸ© := this; use N; intro n hn; have := h_sum_diff n; have := HN n hn; rw [ dist_eq_norm ] at *; simp_all +decide [ intervalIntegral.integral_sub ( hf_cont.intervalIntegrable _ _ ) ( IsTrigPoly.continuous _ hP_trig |> Continuous.intervalIntegrable |> fun h => h _ _ ) ] ;
    have := norm_add_le ( ( âˆ‘ i âˆˆ Finset.Icc 1 n, ( Î± i : â„‚ ) * f ( i * Î¸ ) ) / âˆ‘ i âˆˆ Finset.Icc 1 n, ( Î± i : â„‚ ) - ( âˆ‘ i âˆˆ Finset.Icc 1 n, ( Î± i : â„‚ ) * P ( i * Î¸ ) ) / âˆ‘ i âˆˆ Finset.Icc 1 n, ( Î± i : â„‚ ) ) ( ( âˆ‘ i âˆˆ Finset.Icc 1 n, ( Î± i : â„‚ ) * P ( i * Î¸ ) ) / âˆ‘ i âˆˆ Finset.Icc 1 n, ( Î± i : â„‚ ) - âˆ« x in ( 0 : â„ )..1, P x ) ; ( have := norm_add_le ( ( âˆ‘ i âˆˆ Finset.Icc 1 n, ( Î± i : â„‚ ) * f ( i * Î¸ ) ) / âˆ‘ i âˆˆ Finset.Icc 1 n, ( Î± i : â„‚ ) - ( âˆ‘ i âˆˆ Finset.Icc 1 n, ( Î± i : â„‚ ) * P ( i * Î¸ ) ) / âˆ‘ i âˆˆ Finset.Icc 1 n, ( Î± i : â„‚ ) + ( ( âˆ‘ i âˆˆ Finset.Icc 1 n, ( Î± i : â„‚ ) * P ( i * Î¸ ) ) / âˆ‘ i âˆˆ Finset.Icc 1 n, ( Î± i : â„‚ ) - âˆ« x in ( 0 : â„ )..1, P x ) ) ( âˆ« x in ( 0 : â„ )..1, P x - f x ) ; ( simp_all +decide [ intervalIntegral.integral_sub ( IsTrigPoly.continuous _ hP_trig |> Continuous.intervalIntegrable |> fun h => h _ _ ) ( hf_cont.intervalIntegrable _ _ ) ] ; ) );
    linarith [ h_sum_diff n, norm_sub_rev ( âˆ« x in ( 0 : â„ )..1, P x ) ( âˆ« x in ( 0 : â„ )..1, f x ) ];
  exact Metric.tendsto_atTop.mpr fun Îµ hÎµ => by simpa using h_eps Îµ hÎµ;

/-
If a sequence can be sandwiched between sequences converging to limits arbitrarily close to L, then it converges to L.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex Submodule

lemma tendsto_of_sandwich_epsilon
  (u : â„• â†’ â„) (L : â„)
  (h : âˆ€ Îµ > 0, âˆƒ (v w : â„• â†’ â„) (L_v L_w : â„),
    (âˆƒ N, âˆ€ n â‰¥ N, v n â‰¤ u n âˆ§ u n â‰¤ w n) âˆ§
    Tendsto v atTop (ğ“ L_v) âˆ§
    Tendsto w atTop (ğ“ L_w) âˆ§
    L_v â‰¤ L âˆ§ L â‰¤ L_w âˆ§
    L_w - L_v < Îµ) :
  Tendsto u atTop (ğ“ L) := by
  rw [ Metric.tendsto_nhds ];
  field_simp;
  intro Îµ hÎµ;
  obtain âŸ¨ v, w, L_v, L_w, âŸ¨ N, hN âŸ©, hv, hw, hL_v, hL_w, hÎµ' âŸ© := h ( Îµ / 3 ) ( by positivity );
  filter_upwards [ Filter.eventually_ge_atTop N, hv.eventually ( Metric.ball_mem_nhds _ <| show 0 < Îµ / 3 by linarith ), hw.eventually ( Metric.ball_mem_nhds _ <| show 0 < Îµ / 3 by linarith ) ] with n hn hn' hn'' using abs_lt.mpr âŸ¨ by linarith [ abs_lt.mp hn', abs_lt.mp hn'', hN n hn ], by linarith [ abs_lt.mp hn', abs_lt.mp hn'', hN n hn ] âŸ©

/-
If a function can be sandwiched between trigonometric polynomials with arbitrarily small integral difference, then the weighted equidistribution holds.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex Submodule

lemma problem_173_sandwich
  (Î¸ : â„) (hÎ¸ : Irrational Î¸)
  (Î± : â„• â†’ â„) (hÎ±_pos : âˆ€ n, 0 < Î± n) (hÎ±_dec : Antitone Î±)
  (hÎ±_div : Tendsto (Î» n => âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i) atTop atTop)
  (f : â„ â†’ â„) (hf : IntervalIntegrable f volume 0 1)
  (h_sandwich : âˆ€ Îµ > 0, âˆƒ g h : â„ â†’ â„‚, IsTrigPoly g âˆ§ IsTrigPoly h âˆ§ (âˆ€ x, (g x).re â‰¤ f x âˆ§ f x â‰¤ (h x).re) âˆ§ (âˆ« x in (0:â„)..(1:â„), ((h x).re - (g x).re)) < Îµ) :
  Tendsto (Î» n => (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * f (Int.fract (i * Î¸))) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i))
    atTop (ğ“ (âˆ« x in (0:â„)..(1:â„), f x)) := by
      refine' tendsto_of_sandwich_epsilon _ _ _;
      intro Îµ hÎµ_pos
      obtain âŸ¨g, h, hg_poly, hh_poly, hgh, h_intâŸ© := h_sandwich Îµ hÎµ_pos
      use (fun n => (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * (g (Int.fract (i * Î¸))).re) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i)), (fun n => (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * (h (Int.fract (i * Î¸))).re) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i)), âˆ« x in (0:â„)..(1:â„), (g x).re, âˆ« x in (0:â„)..(1:â„), (h x).re;
      constructor;
      Â· exact âŸ¨ 1, fun n hn => âŸ¨ div_le_div_of_nonneg_right ( Finset.sum_le_sum fun _ _ => mul_le_mul_of_nonneg_left ( hgh _ |>.1 ) ( le_of_lt ( hÎ±_pos _ ) ) ) ( Finset.sum_nonneg fun _ _ => le_of_lt ( hÎ±_pos _ ) ), div_le_div_of_nonneg_right ( Finset.sum_le_sum fun _ _ => mul_le_mul_of_nonneg_left ( hgh _ |>.2 ) ( le_of_lt ( hÎ±_pos _ ) ) ) ( Finset.sum_nonneg fun _ _ => le_of_lt ( hÎ±_pos _ ) ) âŸ© âŸ©;
      Â· refine' âŸ¨ _, _, _, _, _ âŸ©;
        Â· have := problem_173_trig_poly Î¸ hÎ¸ Î± hÎ±_pos hÎ±_dec hÎ±_div g hg_poly;
          convert Complex.continuous_re.continuousAt.tendsto.comp this using 2 ; norm_num [ Complex.normSq, Complex.div_re ];
          Â· by_cases h : âˆ‘ i âˆˆ Finset.Icc 1 â€¹_â€º, Î± i = 0 <;> simp +decide [ h, mul_div_mul_right ];
          Â· rw [ intervalIntegral.integral_of_le zero_le_one, intervalIntegral.integral_of_le zero_le_one ];
            convert integral_re ( show MeasureTheory.IntegrableOn g ( Set.Ioc 0 1 ) _ from ?_ );
            exact Continuous.integrableOn_Ioc ( by exact? );
        Â· have := problem_173_trig_poly Î¸ hÎ¸ Î± hÎ±_pos hÎ±_dec hÎ±_div h hh_poly;
          convert Complex.continuous_re.continuousAt.tendsto.comp this using 2 ; norm_num [ Complex.ext_iff ];
          Â· norm_num [ div_eq_mul_inv, Complex.normSq, Complex.div_re ];
            by_cases h : âˆ‘ i âˆˆ Finset.Icc 1 â€¹_â€º, Î± i = 0 <;> simp +decide [ h ];
          Â· rw [ intervalIntegral.integral_of_le zero_le_one, intervalIntegral.integral_of_le zero_le_one ];
            convert ( integral_re ( show MeasureTheory.IntegrableOn h ( Set.Ioc 0 1 ) MeasureTheory.MeasureSpace.volume from ?_ ) ) using 1;
            exact Continuous.integrableOn_Ioc ( by exact hh_poly.continuous );
        Â· refine' intervalIntegral.integral_mono_on _ _ _ _ <;> norm_num;
          Â· exact Continuous.intervalIntegrable ( by exact Complex.continuous_re.comp ( hg_poly.continuous ) ) _ _;
          Â· exact hf;
          Â· exact fun x _ _ => hgh x |>.1;
        Â· refine' intervalIntegral.integral_mono_on _ _ _ _ <;> norm_num;
          Â· exact hf;
          Â· exact Continuous.intervalIntegrable ( by exact Complex.continuous_re.comp ( hh_poly.continuous ) ) _ _;
          Â· exact fun x _ _ => hgh x |>.2;
        Â· rwa [ intervalIntegral.integral_sub ] at h_int;
          Â· exact Continuous.intervalIntegrable ( by exact Complex.continuous_re.comp ( IsTrigPoly.continuous h hh_poly ) ) _ _;
          Â· exact Continuous.intervalIntegrable ( by exact Complex.continuous_re.comp ( hg_poly.continuous ) ) _ _

/-
The real part of the interval integral is the interval integral of the real part.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex Submodule

lemma intervalIntegral_re {a b : â„} {f : â„ â†’ â„‚} (hf : IntervalIntegrable f volume a b) :
  âˆ« x in a..b, (f x).re = (âˆ« x in a..b, f x).re := by
  -- Apply the theorem that states the integral of the real part of a function is the real part of the integral.
  have h_real_part : âˆ« x in a..b, (f x).re = (âˆ« x in a..b, f x).re := by
    have h_integrable : IntervalIntegrable (fun x => f x) MeasureTheory.MeasureSpace.volume a b := hf
    unfold intervalIntegral at *;
    cases le_total a b <;> simp +decide [ *, intervalIntegrable_iff ] at *;
    Â· convert integral_re h_integrable;
    Â· convert integral_re h_integrable;
  exact h_real_part

/-
Checking existence of sandwich lemma and integral real part lemma.
-/
#check problem_173_sandwich
#check intervalIntegral_re

/-
Checking for Complex.div_re and Continuous.intervalIntegrable.
-/
#check Complex.div_re
#check Continuous.intervalIntegrable

/-
If a function can be sandwiched between trigonometric polynomials with arbitrarily small integral difference, then the weighted equidistribution holds.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex Submodule

lemma problem_173_sandwich_v2
  (Î¸ : â„) (hÎ¸ : Irrational Î¸)
  (Î± : â„• â†’ â„) (hÎ±_pos : âˆ€ n, 0 < Î± n) (hÎ±_dec : Antitone Î±)
  (hÎ±_div : Tendsto (Î» n => âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i) atTop atTop)
  (f : â„ â†’ â„) (hf : IntervalIntegrable f volume 0 1)
  (h_sandwich : âˆ€ Îµ > 0, âˆƒ g h : â„ â†’ â„‚, IsTrigPoly g âˆ§ IsTrigPoly h âˆ§ (âˆ€ x âˆˆ Set.Ico 0 1, (g x).re â‰¤ f x âˆ§ f x â‰¤ (h x).re) âˆ§ (âˆ« x in (0:â„)..(1:â„), ((h x).re - (g x).re)) < Îµ) :
  Tendsto (Î» n => (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * f (Int.fract (i * Î¸))) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i))
    atTop (ğ“ (âˆ« x in (0:â„)..(1:â„), f x)) := by
      refine' tendsto_of_sandwich_epsilon _ _ _;
      intro Îµ hÎµ_pos
      obtain âŸ¨g, h, hg_trig, hh_trig, hgh, hgh_intâŸ© := h_sandwich Îµ hÎµ_pos
      use fun n => (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * (g (Int.fract (i * Î¸))).re) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i), fun n => (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * (h (Int.fract (i * Î¸))).re) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i), (âˆ« x in (0 : â„)..(1 : â„), (g x).re), (âˆ« x in (0 : â„)..(1 : â„), (h x).re);
      refine' âŸ¨ _, _, _, _, _ âŸ©;
      Â· refine' âŸ¨ 1, fun n hn => âŸ¨ _, _ âŸ© âŸ©;
        Â· gcongr;
          Â· exact Finset.sum_nonneg fun _ _ => le_of_lt ( hÎ±_pos _ );
          Â· exact le_of_lt ( hÎ±_pos _ );
          Â· exact hgh _ âŸ¨ Int.fract_nonneg _, Int.fract_lt_one _ âŸ© |>.1;
        Â· exact div_le_div_of_nonneg_right ( Finset.sum_le_sum fun i hi => mul_le_mul_of_nonneg_left ( hgh _ âŸ¨ Int.fract_nonneg _, Int.fract_lt_one _ âŸ© |>.2 ) ( le_of_lt ( hÎ±_pos i ) ) ) ( Finset.sum_nonneg fun _ _ => le_of_lt ( hÎ±_pos _ ) );
      Â· have := problem_173_trig_poly Î¸ hÎ¸ Î± hÎ±_pos hÎ±_dec hÎ±_div g hg_trig;
        convert Complex.continuous_re.continuousAt.tendsto.comp this using 2 ; norm_num [ Complex.normSq, Complex.div_re ];
        Â· by_cases h : âˆ‘ i âˆˆ Finset.Icc 1 â€¹_â€º, Î± i = 0 <;> simp +decide [ h, mul_div_mul_right ];
        Â· rw [ intervalIntegral_re ];
          exact Continuous.intervalIntegrable ( by exact? ) _ _;
      Â· have := problem_173_trig_poly Î¸ hÎ¸ Î± hÎ±_pos hÎ±_dec hÎ±_div h hh_trig;
        convert Complex.continuous_re.continuousAt.tendsto.comp this using 2 ; norm_num [ Complex.normSq, Complex.div_re ];
        Â· by_cases h : âˆ‘ i âˆˆ Finset.Icc 1 â€¹_â€º, Î± i = 0 <;> simp +decide [ h, mul_div_mul_right ];
        Â· rw [ intervalIntegral_re ];
          exact Continuous.intervalIntegrable ( by exact hh_trig.continuous ) _ _;
      Â· rw [ intervalIntegral.integral_of_le zero_le_one, intervalIntegral.integral_of_le zero_le_one ] at *;
        rw [ MeasureTheory.integral_Ioc_eq_integral_Ioo, MeasureTheory.integral_Ioc_eq_integral_Ioo ] at *;
        refine' MeasureTheory.setIntegral_mono_on _ _ measurableSet_Ioo fun x hx => hgh x âŸ¨ hx.1.le, hx.2 âŸ© |>.1;
        Â· exact Continuous.integrableOn_Icc ( by exact Complex.continuous_re.comp ( hg_trig.continuous ) ) |> fun h => h.mono_set ( Set.Ioo_subset_Icc_self );
        Â· exact hf.1.mono_set <| Set.Ioo_subset_Ioc_self;
      Â· constructor;
        Â· rw [ intervalIntegral.integral_of_le zero_le_one, intervalIntegral.integral_of_le zero_le_one ];
          rw [ MeasureTheory.integral_Ioc_eq_integral_Ioo, MeasureTheory.integral_Ioc_eq_integral_Ioo ];
          refine' MeasureTheory.setIntegral_mono_on _ _ measurableSet_Ioo fun x hx => hgh x âŸ¨ hx.1.le, hx.2 âŸ© |>.2;
          Â· exact hf.1.mono_set <| Set.Ioo_subset_Ioc_self;
          Â· exact Continuous.integrableOn_Icc ( by exact Complex.continuous_re.comp ( hh_trig.continuous ) ) |> fun h => h.mono_set ( Set.Ioo_subset_Icc_self );
        Â· rwa [ â† intervalIntegral.integral_sub ];
          Â· exact Continuous.intervalIntegrable ( by exact Complex.continuous_re.comp ( by exact hh_trig.continuous ) ) _ _;
          Â· exact Continuous.intervalIntegrable ( by exact Complex.continuous_re.comp ( hg_trig.continuous ) ) _ _

/-
If a function can be sandwiched between trigonometric polynomials with arbitrarily small integral difference, then the weighted equidistribution holds.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex Submodule

lemma problem_173_sandwich_final
  (Î¸ : â„) (hÎ¸ : Irrational Î¸)
  (Î± : â„• â†’ â„) (hÎ±_pos : âˆ€ n, 0 < Î± n) (hÎ±_dec : Antitone Î±)
  (hÎ±_div : Tendsto (Î» n => âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i) atTop atTop)
  (f : â„ â†’ â„) (hf : IntervalIntegrable f volume 0 1)
  (h_sandwich : âˆ€ Îµ > 0, âˆƒ g h : â„ â†’ â„‚, IsTrigPoly g âˆ§ IsTrigPoly h âˆ§ (âˆ€ x âˆˆ Set.Ico 0 1, (g x).re â‰¤ f x âˆ§ f x â‰¤ (h x).re) âˆ§ (âˆ« x in (0:â„)..(1:â„), ((h x).re - (g x).re)) < Îµ) :
  Tendsto (Î» n => (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * f (Int.fract (i * Î¸))) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i))
    atTop (ğ“ (âˆ« x in (0:â„)..(1:â„), f x)) := by
      exact?

/-
The weighted average of the real part of a trigonometric polynomial converges to the integral of the real part.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex Submodule

lemma problem_173_trig_poly_re
  (Î¸ : â„) (hÎ¸ : Irrational Î¸)
  (Î± : â„• â†’ â„) (hÎ±_pos : âˆ€ n, 0 < Î± n) (hÎ±_dec : Antitone Î±)
  (hÎ±_div : Tendsto (Î» n => âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i) atTop atTop)
  (P : â„ â†’ â„‚) (hP : IsTrigPoly P) :
  Tendsto (Î» n => (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * (P (Int.fract (i * Î¸))).re) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i))
    atTop (ğ“ (âˆ« x in (0:â„)..(1:â„), (P x).re)) := by
      -- Apply the problem_173_sandwich lemma to get convergence for the complex polynomial.
      have h_complex : Filter.Tendsto (fun n => (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * P (Int.fract (i * Î¸))) / âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i) .atTop (ğ“ (âˆ« x in (0:â„)..(1:â„), P x)) := by
        convert problem_173_trig_poly Î¸ hÎ¸ Î± hÎ±_pos hÎ±_dec hÎ±_div P hP using 1;
      convert Complex.continuous_re.continuousAt.tendsto.comp h_complex using 2 ; norm_num [ Complex.div_re ];
      Â· norm_num [ Complex.normSq, sq ];
        by_cases h : âˆ‘ i âˆˆ Finset.Icc 1 â€¹_â€º, Î± i = 0 <;> simp +decide [ h, mul_div_mul_right ];
      Â· convert intervalIntegral_re _;
        exact Continuous.intervalIntegrable ( by exact? ) _ _

/-
For any properly integrable function f (defined as sandwichable by trigonometric polynomials), the weighted average converges to the integral.
-/
open MeasureTheory Filter Topology BigOperators Set Real Complex Submodule

def ProperlyIntegrable (f : â„ â†’ â„) : Prop :=
  IntervalIntegrable f volume 0 1 âˆ§
  âˆ€ Îµ > 0, âˆƒ g h : â„ â†’ â„‚, IsTrigPoly g âˆ§ IsTrigPoly h âˆ§
    (âˆ€ x âˆˆ Set.Ico 0 1, (g x).re â‰¤ f x âˆ§ f x â‰¤ (h x).re) âˆ§
    (âˆ« x in (0:â„)..(1:â„), ((h x).re - (g x).re)) < Îµ

theorem problem_173_corrected
  (Î¸ : â„) (hÎ¸ : Irrational Î¸)
  (Î± : â„• â†’ â„) (hÎ±_pos : âˆ€ n, 0 < Î± n) (hÎ±_dec : Antitone Î±)
  (hÎ±_div : Tendsto (Î» n => âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i) atTop atTop)
  (f : â„ â†’ â„) (hf : ProperlyIntegrable f) :
  Tendsto (Î» n => (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i * f (Int.fract (i * Î¸))) / (âˆ‘ i âˆˆ Finset.Icc 1 n, Î± i))
    atTop (ğ“ (âˆ« x in (0:â„)..(1:â„), f x)) := by
  apply problem_173_sandwich_v2 Î¸ hÎ¸ Î± hÎ±_pos hÎ±_dec hÎ±_div f hf.1 hf.2