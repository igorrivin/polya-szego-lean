/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 97ce9ade-ac19-4e6d-bd61-dd41b5671e6c
-/

/-
Formalized Polya-Szego Problem 148 and 149.
Problem 148: Defined the series, proved convergence to 2/3, proved it envelops 2/3 (oscillates), and proved it is not strictly enveloping (consecutive terms on same side).
Problem 149: Defined the series for e^i, and proved that the 7th partial sum approximates e^i within 0.001 (using squared norm).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-- The terms of the series in Problem 148 -/
def problem148_term (n : ℕ) : ℝ :=
  let k := n / 2
  let sign : ℝ := if (n / 2) % 2 = 0 then 1 else -1
  if n % 2 = 0 then sign * (3 : ℝ) / ((2 : ℝ) ^ (k + 1))
  else sign * (1 : ℝ) / ((2 : ℝ) ^ (k + 1))

/-- The partial sums of the series -/
def problem148_partial_sum (N : ℕ) : ℝ :=
  ∑ n ∈ Finset.range N, problem148_term n

/-
Corrected definition of the terms of the series in Problem 148. The original definition had an off-by-one error in the exponent of 2.
-/
/-- The terms of the series in Problem 148 (Corrected) -/
def problem148_term_corrected (n : ℕ) : ℝ :=
  let k := n / 2
  let sign : ℝ := if (n / 2) % 2 = 0 then 1 else -1
  if n % 2 = 0 then sign * (3 : ℝ) / ((2 : ℝ) ^ (k + 2))
  else sign * (1 : ℝ) / ((2 : ℝ) ^ (k + 2))

/-- The partial sums of the series (Corrected) -/
def problem148_partial_sum_corrected (N : ℕ) : ℝ :=
  ∑ n ∈ Finset.range N, problem148_term_corrected n

/-- The series converges to 2/3 -/
theorem problem148_converges_corrected : Filter.Tendsto problem148_partial_sum_corrected Filter.atTop (nhds (2/3 : ℝ)) := by
  unfold problem148_partial_sum_corrected problem148_term_corrected;
  -- We'll use the fact that the series is absolutely convergent to split it into two separate series.
  have h_split : Filter.Tendsto (fun N => ∑ n ∈ Finset.range N, (if n % 2 = 0 then (3 : ℝ) / (2 ^ (n / 2 + 2)) else (1 : ℝ) / (2 ^ (n / 2 + 2))) * (-1) ^ (n / 2)) Filter.atTop (nhds (2 / 3)) := by
    -- Let's simplify the expression inside the sum.
    suffices h_simp : Filter.Tendsto (fun N => ∑ n ∈ Finset.range (2 * N), ((if n % 2 = 0 then (3 : ℝ) / (2 ^ (n / 2 + 2)) else (1 : ℝ) / (2 ^ (n / 2 + 2))) * (-1) ^ (n / 2))) Filter.atTop (nhds (2 / 3)) by
      have h_simp : Filter.Tendsto (fun N => ∑ n ∈ Finset.range (2 * N + 1), ((if n % 2 = 0 then (3 : ℝ) / (2 ^ (n / 2 + 2)) else (1 : ℝ) / (2 ^ (n / 2 + 2))) * (-1) ^ (n / 2))) Filter.atTop (nhds (2 / 3)) := by
        norm_num [ Finset.sum_range_succ ];
        convert h_simp.add ( show Filter.Tendsto ( fun N : ℕ => 3 / 2 ^ ( N + 2 ) * ( -1 ) ^ N ) Filter.atTop ( nhds 0 ) from ?_ ) using 2 <;> norm_num [ div_eq_mul_inv ];
        exact tendsto_zero_iff_norm_tendsto_zero.mpr ( by simpa using tendsto_const_nhds.div_atTop ( tendsto_pow_atTop_atTop_of_one_lt one_lt_two |> Filter.Tendsto.comp <| Filter.tendsto_add_atTop_nat 2 ) );
      rw [ Filter.tendsto_atTop' ] at *;
      intro s hs; rcases ‹∀ s ∈ nhds ( 2 / 3 ), ∃ a, ∀ b ≥ a, ∑ n ∈ Finset.range ( 2 * b ), ( if n % 2 = 0 then 3 / ( 2 : ℝ ) ^ ( n / 2 + 2 ) else 1 / ( 2 : ℝ ) ^ ( n / 2 + 2 ) ) * ( -1 ) ^ ( n / 2 ) ∈ s› s hs with ⟨ a, ha ⟩ ; rcases h_simp s hs with ⟨ b, hb ⟩ ; exact ⟨ 2 * a + 2 * b, fun n hn => by rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩ <;> [ exact ha _ ( by linarith ) ; exact hb _ ( by linarith ) ] ⟩ ;
    -- Let's simplify the expression inside the sum further.
    suffices h_simp' : Filter.Tendsto (fun N => ∑ n ∈ Finset.range N, ((3 : ℝ) / (2 ^ (n + 2)) * (-1) ^ n + (1 : ℝ) / (2 ^ (n + 2)) * (-1) ^ n)) Filter.atTop (nhds (2 / 3)) by
      convert h_simp' using 2;
      induction ‹_› <;> simp_all +decide [ Nat.mul_succ, Finset.sum_range_succ ];
      norm_num [ Nat.add_div ] ; ring;
    ring_nf;
    norm_num only [ ← mul_pow ];
    convert hasSum_geometric_of_norm_lt_one _ |> HasSum.tendsto_sum_nat using 1 <;> norm_num;
  convert h_split using 2 ; norm_num [ Nat.even_iff ] ; ring;
  exact Finset.sum_congr rfl fun x hx => by rcases Nat.mod_two_eq_zero_or_one ( x / 2 ) with h | h <;> rw [ ← Nat.mod_add_div ( x / 2 ) 2 ] <;> norm_num [ pow_add, pow_mul, h ] <;> ring;

/-- The enveloping is not strict in the sense that it is not strictly alternating.
    We prove that there are consecutive terms on the same side of 2/3. -/
theorem problem148_not_strictly_alternating :
    ∃ n : ℕ, (problem148_partial_sum_corrected n - 2/3) * (problem148_partial_sum_corrected (n+1) - 2/3) > 0 := by
  -- Let's choose any $n$ such that $n \geq 1$.
  use 1;
  -- Let's simplify the expression for the partial sum at $n = 1$.
  simp [problem148_partial_sum_corrected];
  -- Let's simplify the expression for the partial sum at $n = 2$.
  norm_num [Finset.sum_range_succ, problem148_term_corrected]

/-
Definition of the terms of the series for e^i in Problem 149.
-/
/-- The terms of the series in Problem 149: (i)^n / n! -/
def problem149_term (n : ℕ) : ℂ := (Complex.I ^ n) / (n.factorial : ℂ)

/-
Definition of the partial sums of the series for e^i in Problem 149.
-/
/-- The partial sums of the series in Problem 149 -/
def problem149_partial_sum (N : ℕ) : ℂ := ∑ n ∈ Finset.range N, problem149_term n

#check Complex.exp
#check dist

#check Complex.normSq
#check Real.sqrt
#synth NormedField ℂ

#check Complex.exp

/-
Theorem stating that the sum of the first 7 terms of the series for e^i approximates the true value within 0.001, using squared norm.
-/
/-- The approximation of e^i using the first 7 terms is accurate to 3 decimals.
    We interpret "3 decimals" as the error being less than 0.001.
    We use normSq to avoid issues with Complex.abs. -/
theorem problem149_approximation : Complex.normSq (Complex.exp Complex.I - problem149_partial_sum 7) < ((1 : ℝ) / 1000) ^ 2 := by
  -- Calculate the sum of the first 7 terms of the series for e^i.
  let S7 : ℂ := ∑ n ∈ Finset.range 7, (Complex.I ^ n) / (n.factorial : ℂ);
  -- We'll use the exponential representation of the series to simplify the expression.
  have h_exp : Complex.exp Complex.I - S7 = ∑' n : ℕ, (Complex.I ^ (n + 7)) / (Nat.factorial (n + 7)) := by
    norm_num [ Complex.exp_eq_exp_ℂ, NormedSpace.exp_eq_tsum_div ];
    rw [ ← Summable.sum_add_tsum_nat_add ];
    exacts [ by ring!, Summable.of_norm <| by simpa using Real.summable_pow_div_factorial 1 ];
  -- We'll use the exponential representation of the series to simplify the expression further.
  have h_exp_simplified : Complex.exp Complex.I - S7 = Complex.I ^ 7 * ∑' n : ℕ, (Complex.I ^ n) / (Nat.factorial (n + 7)) := by
    rw [ h_exp, ← tsum_mul_left ] ; congr ; ext n ; ring;
  -- We'll use the exponential representation of the series to simplify the expression further and bound it.
  have h_exp_simplified_bound : Complex.normSq (∑' n : ℕ, (Complex.I ^ n) / (Nat.factorial (n + 7))) ≤ (∑' n : ℕ, (1 : ℝ) / (Nat.factorial (n + 7))) ^ 2 := by
    rw [ sq, Complex.normSq_eq_norm_sq ];
    rw [ sq ];
    gcongr;
    · convert norm_tsum_le_tsum_norm _ <;> norm_num;
      simpa using summable_nat_add_iff 7 |>.2 <| Real.summable_pow_div_factorial 1;
    · convert norm_tsum_le_tsum_norm _ <;> norm_num;
      simpa using summable_nat_add_iff 7 |>.2 <| Real.summable_pow_div_factorial 1;
  -- We'll use the exponential representation of the series to simplify the expression further and bound it. Notice that $\sum_{n=0}^{\infty} \frac{1}{(n+7)!}$ is a convergent p-series with $p=7>1$.
  have h_pseries : ∑' n : ℕ, (1 : ℝ) / (Nat.factorial (n + 7)) < 1 / 1000 := by
    have h_pseries : ∑' n : ℕ, (1 : ℝ) / (Nat.factorial (n + 7)) ≤ ∑' n : ℕ, (1 : ℝ) / (Nat.factorial 7) * (1 / 2) ^ n := by
      refine' Summable.tsum_le_tsum _ _ _;
      · intro n; rw [ div_mul_eq_mul_div ] ; rw [ div_le_div_iff₀ ] <;> norm_cast <;> first | positivity | induction' n with n ih <;> norm_num [ Nat.factorial_succ, pow_succ' ] at *;
        nlinarith [ pow_pos ( by norm_num : ( 0 : ℝ ) < 1 / 2 ) n, pow_nonneg ( by positivity : ( 0 : ℝ ) ≤ n ) 2, pow_nonneg ( by positivity : ( 0 : ℝ ) ≤ n ) 3, pow_nonneg ( by positivity : ( 0 : ℝ ) ≤ n ) 4, pow_nonneg ( by positivity : ( 0 : ℝ ) ≤ n ) 5, pow_nonneg ( by positivity : ( 0 : ℝ ) ≤ n ) 6, pow_nonneg ( by positivity : ( 0 : ℝ ) ≤ n ) 7 ];
      · simpa using summable_nat_add_iff 7 |>.2 <| Real.summable_pow_div_factorial 1;
      · exact Summable.mul_left _ ( summable_geometric_two );
    exact h_pseries.trans_lt ( by rw [ tsum_mul_left, tsum_geometric_two ] ; norm_num [ Nat.factorial ] );
  -- By combining the results from h_exp_simplified_bound and h_pseries, we can conclude the proof.
  have h_final : Complex.normSq (∑' n : ℕ, (Complex.I ^ n) / (Nat.factorial (n + 7))) < (1 / 1000) ^ 2 := by
    exact h_exp_simplified_bound.trans_lt ( pow_lt_pow_left₀ h_pseries ( tsum_nonneg fun _ => by positivity ) ( by norm_num ) );
  convert h_final using 1;
  exact h_exp_simplified.symm ▸ by norm_num [ pow_succ, mul_assoc, mul_comm, mul_left_comm, Complex.normSq_mul ] ;

/-
Definition of the witness function f(n) which is true if n mod 4 is 1 or 2, and false otherwise.
-/
/-- The witness function for the enveloping property.
    Returns true if the partial sum is >= 2/3, false otherwise. -/
def problem148_witness (n : ℕ) : Prop := n % 4 = 1 ∨ n % 4 = 2

/-
Lemma stating the closed form for the partial sum at indices which are multiples of 4.
-/
/-- Helper lemma: The partial sum S_{4k} is 2/3 * (1 - 1/4^k) -/
lemma problem148_partial_sum_4k (k : ℕ) :
  problem148_partial_sum_corrected (4 * k) = 2/3 * (1 - (1/4 : ℝ) ^ k) := by
  -- We can prove this general formula by induction on $k$.
  induction' k with k ih;
  · norm_num [ problem148_partial_sum_corrected ];
  · simp_all +decide [ Nat.mul_succ, pow_succ' ];
    unfold problem148_partial_sum_corrected at *;
    norm_num [ Finset.sum_range_succ, ih ] ; ring;
    unfold problem148_term_corrected; norm_num [ Nat.add_mod, Nat.mul_mod, pow_add ] ; ring;
    norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.mul_mod, Nat.add_mod ] ; ring;
    simpa only [ pow_mul' ] using by ring;

/-
Lemma stating that the partial sum at indices 4k+1 is strictly greater than 2/3.
-/
/-- Helper lemma: The partial sum S_{4k+1} is > 2/3 -/
lemma problem148_partial_sum_4k_plus_1 (k : ℕ) :
  problem148_partial_sum_corrected (4 * k + 1) > 2/3 := by
  -- Using the lemma for S_{4k}, we express the difference for S_{4k+1}.
  have h_diff : problem148_partial_sum_corrected (4 * k + 1) = (2 / 3 : ℝ) * (1 - (1 / 4 : ℝ) ^ k) + (3 : ℝ) / ((2 : ℝ) ^ (2 * k + 2)) := by
    rw [ ← problem148_partial_sum_4k k ];
    norm_num [ Finset.sum_range_succ, problem148_partial_sum_corrected ];
    unfold problem148_term_corrected; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] ; ring;
    norm_num [ Nat.mul_div_assoc, Nat.mul_mod ] ; ring;
  rcases k with ( _ | k ) <;> norm_num [ pow_succ', pow_mul ] at * ; ring_nf at * ; norm_num at *;
  · linarith;
  · rw [ h_diff ] ; ring_nf ; norm_num

/-
Lemma stating that the partial sum at indices 4k+2 is strictly greater than 2/3.
-/
/-- Helper lemma: The partial sum S_{4k+2} is > 2/3 -/
lemma problem148_partial_sum_4k_plus_2 (k : ℕ) :
  problem148_partial_sum_corrected (4 * k + 2) > 2/3 := by
  -- By definition of $problem148_partial_sum_corrected$, we can write
  have h_partial_sum : problem148_partial_sum_corrected (4 * k + 2) = problem148_partial_sum_corrected (4 * k + 1) + problem148_term_corrected (4 * k + 1) := by
    exact Finset.sum_range_succ _ _;
  -- By definition of $problem148_term_corrected$, we know that
  have h_term : problem148_term_corrected (4 * k + 1) = 1 / (2 ^ (2 * k + 2 : ℕ)) := by
    unfold problem148_term_corrected; norm_num [ Nat.add_mod, Nat.mul_mod ] ;
    grind;
  linarith [ problem148_partial_sum_4k_plus_1 k, show ( 0 : ℝ ) < 1 / 2 ^ ( 2 * k + 2 ) by positivity ]

/-
Lemma stating that the partial sum at indices 4k+3 is strictly less than 2/3.
-/
/-- Helper lemma: The partial sum S_{4k+3} is < 2/3 -/
lemma problem148_partial_sum_4k_plus_3 (k : ℕ) :
  problem148_partial_sum_corrected (4 * k + 3) < 2/3 := by
  -- By definition of partial sum, we can write:
  have h_partial_sum : problem148_partial_sum_corrected (4 * k + 3) = problem148_partial_sum_corrected (4 * k) + problem148_term_corrected (4 * k) + problem148_term_corrected (4 * k + 1) + problem148_term_corrected (4 * k + 2) := by
    simp +decide [ problem148_partial_sum_corrected, Finset.sum_range_succ ];
  -- Substitute the values of the terms into the partial sum expression.
  have h_terms : problem148_term_corrected (4 * k) = 3 / (2 : ℝ) ^ (2 * k + 2) ∧ problem148_term_corrected (4 * k + 1) = 1 / (2 : ℝ) ^ (2 * k + 2) ∧ problem148_term_corrected (4 * k + 2) = -3 / (2 : ℝ) ^ (2 * k + 3) := by
    unfold problem148_term_corrected;
    norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.mul_mod, Nat.add_mod ] ; ring;
    norm_num [ Nat.add_mod, Nat.mul_mod, Nat.mul_div_assoc ] ; ring ; norm_num;
  -- Substitute the expressions for the terms and the partial sum at 4k into the equation.
  rw [h_partial_sum, h_terms.left, h_terms.right.left, h_terms.right.right];
  rw [problem148_partial_sum_4k]
  field_simp
  ring;
  norm_num [ pow_mul', ← mul_pow ]

/-
Proof that the partial sums oscillate around 2/3, using the witness function f(n) = (n mod 4 is 1 or 2).
-/
/-- The partial sums oscillate around 2/3 -/
theorem problem148_envelops_corrected :
    ∃ (f : ℕ → Prop),
      (∀ n, f n → problem148_partial_sum_corrected n ≥ (2/3 : ℝ)) ∧
      (∀ n, ¬f n → problem148_partial_sum_corrected n ≤ (2/3 : ℝ)) ∧
      (∀ n, ∃ m ≥ n, f m) ∧
      (∀ n, ∃ m ≥ n, ¬f m) := by
  use problem148_witness
  constructor;
  · rintro n ( hn | hn ) <;> rw [ ← Nat.div_add_mod n 4, hn ];
    · exact le_of_lt ( problem148_partial_sum_4k_plus_1 _ );
    · exact le_of_lt ( problem148_partial_sum_4k_plus_2 _ );
  · constructor;
    · unfold problem148_witness;
      intro n hn; rw [ ← Nat.mod_add_div n 4 ] ; have := Nat.mod_lt n zero_lt_four; interval_cases _ : n % 4 <;> norm_num at *;
      · rw [ problem148_partial_sum_4k ] ; norm_num;
      · rw [ show 3 + 4 * ( n / 4 ) = 4 * ( n / 4 ) + 3 by ring ] ; exact le_of_lt ( problem148_partial_sum_4k_plus_3 _ );
    · exact ⟨ fun n => ⟨ 4 * n + 1, by linarith, by unfold problem148_witness; norm_num [ Nat.add_mod, Nat.mul_mod ] ⟩, fun n => ⟨ 4 * n, by linarith, by unfold problem148_witness; norm_num [ Nat.add_mod, Nat.mul_mod ] ⟩ ⟩