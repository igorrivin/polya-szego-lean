/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f095c78a-8df5-4c6f-aa05-b4ee885eda2b

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Checking intervalIntegral
-/
#check intervalIntegral

/-
Checking integration by parts theorem
-/
#check intervalIntegral.integral_mul_deriv_eq_deriv_mul

/-
Integration by parts formula for $\int_1^b t^l f(t) dt$ assuming $f$ is continuous.
-/
open MeasureTheory Filter Topology Set

lemma problem_131_ibp {f : ‚Ñù ‚Üí ‚Ñù} {Œ≤ l b : ‚Ñù} (hb : 1 ‚â§ b)
    (hf : ContinuousOn f (Ici 0)) :
    ‚à´ t in 1..b, t^l * f t =
    b^(l-Œ≤) * (‚à´ t in 1..b, t^Œ≤ * f t) - ‚à´ t in 1..b, (l-Œ≤) * t^(l-Œ≤-1) * (‚à´ x in 1..t, x^Œ≤ * f x) := by
  -- Let $F(t) = \int_1^t x^\beta f(x) dx$.
  set F : ‚Ñù ‚Üí ‚Ñù := fun t => ‚à´ u in (1 : ‚Ñù)..t, u ^ Œ≤ * f u;
  -- Apply the integration by parts formula with $u(t) = t^{l-\beta}$ and $v(t) = F(t)$.
  have h_parts : ‚àÄ a b : ‚Ñù, 1 ‚â§ a ‚Üí a ‚â§ b ‚Üí b ‚â§ b ‚Üí ‚à´ t in a..b, t ^ (l - Œ≤) * (t ^ Œ≤ * f t) = (b ^ (l - Œ≤) * F b) - (a ^ (l - Œ≤) * F a) - ‚à´ t in a..b, (l - Œ≤) * t ^ (l - Œ≤ - 1) * F t := by
    intro a b _ _ _; rw [ intervalIntegral.integral_mul_deriv_eq_deriv_mul ];
    ¬∑ exact fun x hx => by simpa using Real.hasDerivAt_rpow_const ( Or.inl <| by cases Set.mem_uIcc.mp hx <;> linarith ) ;
    ¬∑ intro x hx;
      apply_rules [ intervalIntegral.integral_hasDerivAt_right ];
      ¬∑ apply_rules [ ContinuousOn.intervalIntegrable ];
        exact ContinuousOn.mul ( continuousOn_of_forall_continuousAt fun y hy => by exact ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by cases Set.mem_uIcc.mp hy <;> linarith [ Set.mem_Icc.mp <| by simpa [ * ] using hx ] ) <| hf.mono <| by intro y hy ; cases Set.mem_uIcc.mp hy <;> exact Set.mem_Ici.mpr <| by linarith [ Set.mem_Icc.mp <| by simpa [ * ] using hx ];
      ¬∑ exact ‚ü® Set.Ioi 0, Ioi_mem_nhds ( by cases Set.mem_uIcc.mp hx <;> linarith ), ContinuousOn.aestronglyMeasurable ( by exact ContinuousOn.mul ( continuousOn_of_forall_continuousAt fun y hy => by exact ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by linarith [ hy.out ] ) <| hf.mono <| Set.Ioi_subset_Ici_self ) measurableSet_Ioi ‚ü©;
      ¬∑ exact ContinuousAt.mul ( ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by cases Set.mem_uIcc.mp hx <;> linarith ) ( hf.continuousAt <| Ici_mem_nhds <| by cases Set.mem_uIcc.mp hx <;> linarith );
    ¬∑ apply_rules [ ContinuousOn.intervalIntegrable ];
      exact ContinuousOn.mul continuousOn_const ( continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by cases Set.mem_uIcc.mp hx <;> linarith );
    ¬∑ apply_rules [ ContinuousOn.intervalIntegrable ];
      exact ContinuousOn.mul ( continuousOn_of_forall_continuousAt fun x hx => by exact ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by cases Set.mem_uIcc.mp hx <;> linarith ) ( hf.mono <| by intro x hx ; cases Set.mem_uIcc.mp hx <;> exact Set.mem_Ici.mpr <| by linarith );
  convert h_parts 1 b le_rfl hb le_rfl using 1 <;> norm_num [ ‚Üê mul_assoc, ‚Üê Real.rpow_add ] ; ring;
  ¬∑ refine' intervalIntegral.integral_congr fun x hx => by rw [ ‚Üê Real.rpow_add ( by linarith [ Set.mem_Icc.mp ( by simpa [ hb ] using hx ) ] ) ] ; ring;
  ¬∑ norm_num +zetaDelta at *

/-
If $G(t) \to L$ as $t \to \infty$, then $\lim_{k \to 0^+} k \int_1^\infty t^{-k-1} G(t) dt = L$.
-/
open MeasureTheory Filter Topology Set

lemma limit_of_weighted_average {G : ‚Ñù ‚Üí ‚Ñù} {L : ‚Ñù}
    (hG_cont : ContinuousOn G (Ici 1))
    (hG_lim : Tendsto G atTop (ùìù L)) :
    Tendsto (fun k => k * ‚à´ t in Ioi 1, t^(-k-1) * G t) (ùìù[>] 0) (ùìù L) := by
  have h_tendsto_zero : Filter.Tendsto (fun k => k * ‚à´ t in Set.Ioi (1 : ‚Ñù), t ^ (-k - 1 : ‚Ñù) * (G t - L)) (ùìù[>] 0) (ùìù 0) := by
    -- Let's choose any $\epsilon > 0$.
    have h_eps : ‚àÄ œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ k : ‚Ñù, 0 < k ‚àß k < Œ¥ ‚Üí abs (k * ‚à´ t in Set.Ioi (1 : ‚Ñù), t ^ (-k - 1 : ‚Ñù) * (G t - L)) < œµ := by
      -- Let $\epsilon > 0$. Since $G(t) \to L$, there exists $T \ge 1$ such that for $t \ge T$, $|G(t) - L| < \epsilon/2$. Use this $T$.
      intro œµ hœµ_pos
      obtain ‚ü®T, hT_ge_1, hT‚ü© : ‚àÉ T ‚â• 1, ‚àÄ t ‚â• T, |G t - L| < œµ / 2 := by
        exact Exists.elim ( Metric.tendsto_atTop.mp hG_lim ( œµ / 2 ) ( half_pos hœµ_pos ) ) fun T hT => ‚ü® Max.max 1 T, le_max_left _ _, fun t ht => hT t ( le_trans ( le_max_right _ _ ) ht ) ‚ü©;
      -- Split the integral into $\int_1^T + \int_T^\infty$.
      have h_split : ‚àÄ k : ‚Ñù, 0 < k ‚Üí k * ‚à´ t in (Set.Ioi 1), t ^ (-k - 1) * (G t - L) = k * (‚à´ t in (Set.Ioc 1 T), t ^ (-k - 1) * (G t - L)) + k * (‚à´ t in (Set.Ioi T), t ^ (-k - 1) * (G t - L)) := by
        intro k hk_pos
        have h_integrable : MeasureTheory.IntegrableOn (fun t => t ^ (-k - 1) * (G t - L)) (Set.Ioi 1) := by
          -- Since $G(t) \to L$, there exists $M > 0$ such that $|G(t) - L| \leq M$ for all $t \geq 1$.
          obtain ‚ü®M, hM‚ü© : ‚àÉ M > 0, ‚àÄ t ‚â• 1, |G t - L| ‚â§ M := by
            have h_bounded : ‚àÉ M > 0, ‚àÄ t ‚àà Set.Icc 1 T, |G t - L| ‚â§ M := by
              obtain ‚ü® M, hM ‚ü© := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) ( hG_cont.sub continuousOn_const |> ContinuousOn.mono <| Set.Icc_subset_Ici_self ) ; use Max.max M 1; aesop;
            exact ‚ü® Max.max h_bounded.choose ( œµ / 2 ), lt_max_of_lt_left h_bounded.choose_spec.1, fun t ht => if h : t ‚â§ T then le_trans ( h_bounded.choose_spec.2 t ‚ü® ht, h ‚ü© ) ( le_max_left _ _ ) else le_trans ( le_of_lt ( hT t ( le_of_not_ge h ) ) ) ( le_max_right _ _ ) ‚ü©;
          have h_integrable : MeasureTheory.IntegrableOn (fun t : ‚Ñù => t ^ (-k - 1) * M) (Set.Ioi 1) := by
            exact ( integrableOn_Ioi_rpow_of_lt ( by linarith ) ( by linarith ) ) |> fun h => h.mul_const _;
          refine' h_integrable.mono' _ _;
          ¬∑ exact MeasureTheory.AEStronglyMeasurable.mul ( measurable_id.pow_const _ |> Measurable.aestronglyMeasurable ) ( ContinuousOn.aestronglyMeasurable ( by exact ContinuousOn.sub ( hG_cont.mono ( Set.Ioi_subset_Ici_self ) ) continuousOn_const ) measurableSet_Ioi );
          ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with t ht using by rw [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( Real.rpow_nonneg ( by linarith [ ht.out ] ) _ ) ] ; exact mul_le_mul_of_nonneg_left ( hM.2 t ( by linarith [ ht.out ] ) ) ( Real.rpow_nonneg ( by linarith [ ht.out ] ) _ ) ;
        rw [ ‚Üê mul_add, ‚Üê MeasureTheory.setIntegral_union ] <;> norm_num [ hT_ge_1 ];
        ¬∑ exact h_integrable.mono_set <| Set.Ioc_subset_Ioi_self;
        ¬∑ exact h_integrable.mono_set <| Set.Ioi_subset_Ioi hT_ge_1;
      -- For the second part: $|\int_T^\infty k t^{-k-1} (G(t) - L) dt| \le \int_T^\infty k t^{-k-1} (\epsilon/2) dt = (\epsilon/2) T^{-k} \le \epsilon/2$.
      have h_second_part : ‚àÄ k : ‚Ñù, 0 < k ‚Üí |k * ‚à´ t in (Set.Ioi T), t ^ (-k - 1) * (G t - L)| ‚â§ (œµ / 2) * T ^ (-k) := by
        -- Using the bound $|G(t) - L| < \epsilon / 2$ for $t \ge T$, we can show that the integral is bounded.
        intros k hk_pos
        have h_integral_bound : |‚à´ t in (Set.Ioi T), t ^ (-k - 1) * (G t - L)| ‚â§ ‚à´ t in (Set.Ioi T), t ^ (-k - 1) * (œµ / 2) := by
          refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ‚Ñù ‚Üí ‚Ñù ) ) ( MeasureTheory.integral_mono_of_nonneg _ _ _ );
          ¬∑ exact Filter.Eventually.of_forall fun x => norm_nonneg _;
          ¬∑ have h_integrable : MeasureTheory.IntegrableOn (fun t : ‚Ñù => t ^ (-k - 1)) (Set.Ioi T) := by
              rw [ integrableOn_Ioi_rpow_iff ] <;> linarith;
            exact h_integrable.mul_const _;
          ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with t ht using by simpa only [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( Real.rpow_nonneg ( by linarith [ ht.out ] : 0 ‚â§ t ) _ ) ] using mul_le_mul_of_nonneg_left ( le_of_lt ( hT t ht.out.le ) ) ( Real.rpow_nonneg ( by linarith [ ht.out ] : 0 ‚â§ t ) _ ) ;
        -- Evaluating the integral $\int_T^\infty t^{-k-1} dt$, we get $\left[ \frac{t^{-k}}{-k} \right]_T^\infty = \frac{T^{-k}}{k}$.
        have h_integral_eval : ‚à´ t in (Set.Ioi T), t ^ (-k - 1) = T ^ (-k) / k := by
          rw [ integral_Ioi_rpow_of_lt ] <;> try linarith;
          ring;
        rw [ MeasureTheory.integral_mul_const ] at *;
        rw [ abs_mul, abs_of_nonneg hk_pos.le ] ; rw [ h_integral_eval ] at h_integral_bound ; nlinarith [ mul_div_cancel‚ÇÄ ( T ^ ( -k ) ) hk_pos.ne' ];
      -- For the first part: $G$ is bounded on $[1, T]$, say by $M$. So $|G(t) - L| \le M + |L| = K$.
      obtain ‚ü®K, hK‚ü© : ‚àÉ K > 0, ‚àÄ t ‚àà Set.Icc 1 T, |G t - L| ‚â§ K := by
        obtain ‚ü® K, hK ‚ü© := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) ( show ContinuousOn ( fun t => G t - L ) ( Set.Icc 1 T ) from ContinuousOn.sub ( hG_cont.mono ( Set.Icc_subset_Ici_self ) ) continuousOn_const ) ; use Max.max K 1; aesop;
      -- For the first part: $|\int_1^T k t^{-k-1} (G(t) - L) dt| \le \int_1^T k t^{-k-1} K dt = K (1 - T^{-k})$.
      have h_first_part : ‚àÄ k : ‚Ñù, 0 < k ‚Üí |k * ‚à´ t in (Set.Ioc 1 T), t ^ (-k - 1) * (G t - L)| ‚â§ K * (1 - T ^ (-k)) := by
        -- Using the bound $|G(t) - L| \le K$, we can bound the integral.
        intros k hk_pos
        have h_integral_bound : |‚à´ t in (Set.Ioc 1 T), t ^ (-k - 1) * (G t - L)| ‚â§ ‚à´ t in (Set.Ioc 1 T), t ^ (-k - 1) * K := by
          refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ‚Ñù ‚Üí ‚Ñù ) ) ( MeasureTheory.integral_mono_of_nonneg _ _ _ );
          ¬∑ exact Filter.Eventually.of_forall fun x => norm_nonneg _;
          ¬∑ exact ContinuousOn.integrableOn_Icc ( by exact continuousOn_of_forall_continuousAt fun t ht => by exact ContinuousAt.mul ( ContinuousAt.rpow continuousAt_id ( continuousAt_const.sub continuousAt_const ) <| Or.inl <| by linarith [ ht.1 ] ) continuousAt_const ) |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self;
          ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using by simpa only [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( Real.rpow_nonneg ( by linarith [ ht.1 ] : 0 ‚â§ t ) _ ) ] using mul_le_mul_of_nonneg_left ( hK.2 t <| Set.Ioc_subset_Icc_self ht ) ( Real.rpow_nonneg ( by linarith [ ht.1 ] : 0 ‚â§ t ) _ ) ;
        rw [ abs_mul, abs_of_nonneg hk_pos.le ];
        refine le_trans ( mul_le_mul_of_nonneg_left h_integral_bound hk_pos.le ) ?_;
        rw [ ‚Üê intervalIntegral.integral_of_le ( by linarith ), intervalIntegral.integral_mul_const, integral_rpow ] <;> norm_num [ hk_pos.ne' ];
        ¬∑ nlinarith [ mul_div_cancel‚ÇÄ ( T ^ ( -k ) - 1 ) ( by linarith : ( -k ) ‚â† 0 ) ];
        ¬∑ exact Or.inr <| Set.notMem_uIcc_of_lt ( by linarith ) ( by linarith );
      -- As $k \to 0^+$, $T^{-k} \to 1$, so $1 - T^{-k} \to 0$.
      have h_lim : Filter.Tendsto (fun k : ‚Ñù => K * (1 - T ^ (-k))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
        norm_num [ Real.rpow_def_of_pos ( zero_lt_one.trans_le hT_ge_1 ) ];
        exact tendsto_nhdsWithin_of_tendsto_nhds ( Continuous.tendsto' ( by continuity ) _ _ ( by norm_num ) );
      have := Metric.tendsto_nhdsWithin_nhds.mp h_lim ( œµ / 2 ) ( half_pos hœµ_pos );
      obtain ‚ü® Œ¥, hŒ¥_pos, H ‚ü© := this; use Œ¥, hŒ¥_pos; intros k hk; rw [ h_split k hk.1 ] ; refine' abs_lt.mpr ‚ü® _, _ ‚ü© <;> nlinarith [ abs_le.mp ( h_first_part k hk.1 ), abs_le.mp ( h_second_part k hk.1 ), abs_lt.mp ( H hk.1 ( by simpa [ abs_of_pos hk.1 ] using hk.2 ) ), Real.rpow_pos_of_pos ( zero_lt_one.trans_le hT_ge_1 ) ( -k ) ] ;
    rw [ Metric.tendsto_nhds ];
    intro Œµ hŒµ; rcases h_eps Œµ hŒµ with ‚ü® Œ¥, hŒ¥, H ‚ü© ; filter_upwards [ Ioo_mem_nhdsGT ( show 0 < Œ¥ by linarith ) ] with x hx using by simpa only [ dist_zero_right ] using H x ‚ü® hx.1, hx.2 ‚ü© ;
  have h_split : ‚àÄ k > 0, k * ‚à´ t in Set.Ioi (1 : ‚Ñù), t ^ (-k - 1 : ‚Ñù) * G t = k * (‚à´ t in Set.Ioi (1 : ‚Ñù), t ^ (-k - 1 : ‚Ñù) * (G t - L)) + k * (‚à´ t in Set.Ioi (1 : ‚Ñù), t ^ (-k - 1 : ‚Ñù) * L) := by
    intro k hk; rw [ ‚Üê mul_add, ‚Üê MeasureTheory.integral_add ] ; congr ; ext ; ring;
    ¬∑ -- Since $G(t) \to L$ as $t \to \infty$, there exists $M > 0$ such that $|G(t) - L| \leq M$ for all $t \geq 1$.
      obtain ‚ü®M, hM‚ü© : ‚àÉ M > 0, ‚àÄ t ‚â• 1, |G t - L| ‚â§ M := by
        obtain ‚ü® M, hM ‚ü© := Metric.tendsto_atTop.mp hG_lim 1 zero_lt_one;
        -- Since $G$ is continuous on $[1, \infty)$, it is bounded on $[1, M]$.
        have h_bounded : ‚àÉ C > 0, ‚àÄ t ‚àà Set.Icc 1 M, |G t - L| ‚â§ C := by
          obtain ‚ü® C, hC ‚ü© := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) ( hG_cont.sub continuousOn_const |> ContinuousOn.mono <| Set.Icc_subset_Ici_self ) ; use Max.max C 1; aesop;
        exact ‚ü® Max.max h_bounded.choose 1, by positivity, fun t ht => if h : t ‚â§ M then le_trans ( h_bounded.choose_spec.2 t ‚ü® ht, h ‚ü© ) ( le_max_left _ _ ) else le_trans ( le_of_lt ( hM t ( le_of_not_ge h ) ) ) ( le_max_right _ _ ) ‚ü©;
      have h_integrable : MeasureTheory.IntegrableOn (fun t : ‚Ñù => t ^ (-k - 1 : ‚Ñù) * M) (Set.Ioi (1 : ‚Ñù)) := by
        exact ( integrableOn_Ioi_rpow_of_lt ( by linarith ) ( by linarith ) ) |> fun h => h.mul_const _;
      refine' h_integrable.mono' _ _;
      ¬∑ exact MeasureTheory.AEStronglyMeasurable.mul ( measurable_id.pow_const _ |> Measurable.aestronglyMeasurable ) ( ContinuousOn.aestronglyMeasurable ( hG_cont.sub continuousOn_const |> ContinuousOn.mono <| Set.Ioi_subset_Ici_self ) measurableSet_Ioi );
      ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with t ht using by rw [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( Real.rpow_nonneg ( by linarith [ ht.out ] ) _ ) ] ; exact mul_le_mul_of_nonneg_left ( hM.2 t ht.out.le ) ( Real.rpow_nonneg ( by linarith [ ht.out ] ) _ ) ;
    ¬∑ have h_integrable : MeasureTheory.IntegrableOn (fun t : ‚Ñù => t ^ (-k - 1 : ‚Ñù)) (Set.Ioi (1 : ‚Ñù)) := by
        rw [ integrableOn_Ioi_rpow_iff ] <;> linarith;
      exact h_integrable.mul_const _;
  have h_integral : Filter.Tendsto (fun k => k * (‚à´ t in Set.Ioi (1 : ‚Ñù), t ^ (-k - 1 : ‚Ñù) * L)) (ùìù[>] 0) (ùìù L) := by
    have h_integral : ‚àÄ k > 0, ‚à´ t in Set.Ioi (1 : ‚Ñù), t ^ (-k - 1 : ‚Ñù) = 1 / k := by
      intro k hk; rw [ integral_Ioi_rpow_of_lt ] <;> norm_num [ hk ] ; ring ; aesop;
    exact tendsto_const_nhds.congr' ( by filter_upwards [ self_mem_nhdsWithin ] with k hk using by rw [ MeasureTheory.integral_mul_const, h_integral k hk ] ; ring_nf; norm_num [ hk.out.ne' ] );
  simpa using Filter.Tendsto.congr' ( Filter.eventuallyEq_of_mem self_mem_nhdsWithin fun x hx => by rw [ h_split x hx ] ) ( h_tendsto_zero.add h_integral )

/-
Part 1 of Problem 131: Convergence and continuity on $(-\infty, \beta]$ for continuous $f$.
-/
open MeasureTheory Filter Topology Set

lemma problem_131_part1 {f : ‚Ñù ‚Üí ‚Ñù} {Œ≤ : ‚Ñù}
    (hf : ContinuousOn f (Ici 0))
    (h_conv : ‚àÉ I, Tendsto (fun b => ‚à´ t in 1..b, t^Œ≤ * f t) atTop (ùìù I)) :
    (‚àÄ l ‚â§ Œ≤, ‚àÉ I, Tendsto (fun b => ‚à´ t in 1..b, t^l * f t) atTop (ùìù I)) ‚àß
    (‚àÉ F : ‚Ñù ‚Üí ‚Ñù, (‚àÄ l ‚â§ Œ≤, Tendsto (fun b => ‚à´ t in 1..b, t^l * f t) atTop (ùìù (F l))) ‚àß ContinuousOn F (Iic Œ≤)) := by
  -- Let $G(t) = \int_1^t x^\beta f(x) dx$. Since the integral converges, $G(t) \to L$ as $t \to \infty$, so $G$ is bounded.
  obtain ‚ü®I, hI‚ü© := h_conv
  set G : ‚Ñù ‚Üí ‚Ñù := fun t => if t ‚â• 1 then ‚à´ x in (1 : ‚Ñù)..t, x ^ Œ≤ * f x else 0
  have hG_cont : ContinuousOn G (Ici 1) := by
    -- Since $f$ is continuous on $[0, \infty)$, the product $t^\beta f(t)$ is continuous on $[1, \infty)$.
    have h_cont_prod : ContinuousOn (fun t => t ^ Œ≤ * f t) (Set.Ici 1) := by
      exact ContinuousOn.mul ( continuousOn_of_forall_continuousAt fun t ht => by exact ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by linarith [ ht.out ] ) <| hf.mono <| Set.Ici_subset_Ici.2 <| by norm_num;
    have h_cont_int : ContinuousOn (fun t => ‚à´ x in (1 : ‚Ñù)..t, x ^ Œ≤ * f x) (Set.Ici 1) := by
      have h_int_cont : ‚àÄ a b : ‚Ñù, 1 ‚â§ a ‚Üí a ‚â§ b ‚Üí ContinuousOn (fun t => ‚à´ x in a..t, x ^ Œ≤ * f x) (Set.Icc a b) := by
        intro a b _ _; intro t ht; apply_rules [ intervalIntegral.continuousWithinAt_primitive, ContinuousOn.intervalIntegrable ] ; aesop;
        simpa [ *, le_of_lt ] using h_cont_prod.mono ( Set.Icc_subset_Ici_self.trans ( Set.Ici_subset_Ici.2 <| by linarith ) )
      intro t ht;
      have := h_int_cont 1 ( t + 1 ) ( by norm_num ) ( by linarith [ Set.mem_Ici.mp ht ] );
      rw [ Metric.continuousWithinAt_iff ] at *;
      have := Metric.continuousOn_iff.mp this t ‚ü® ht, by linarith [ Set.mem_Ici.mp ht ] ‚ü©;
      exact fun Œµ hŒµ => by obtain ‚ü® Œ¥, hŒ¥, H ‚ü© := this Œµ hŒµ; exact ‚ü® Min.min Œ¥ 1, lt_min hŒ¥ zero_lt_one, fun x hx‚ÇÅ hx‚ÇÇ => H x ‚ü® hx‚ÇÅ, by linarith [ abs_lt.mp hx‚ÇÇ, min_le_left Œ¥ 1, min_le_right Œ¥ 1 ] ‚ü© ( by exact lt_of_lt_of_le hx‚ÇÇ ( min_le_left _ _ ) ) ‚ü© ;
    exact h_cont_int.congr fun t ht => if_pos ht
  have hG_lim : Filter.Tendsto G atTop (ùìù I) := by
    exact hI.congr' ( by filter_upwards [ Filter.eventually_ge_atTop 1 ] with t ht; aesop )
  have hG_bounded : ‚àÉ M, ‚àÄ t ‚â• 1, |G t| ‚â§ M := by
    have := hG_lim.abs;
    rcases Metric.tendsto_atTop.mp this 1 zero_lt_one with ‚ü® M, hM ‚ü©;
    -- Since $|G(t)|$ is bounded above by $|I| + 1$ for $t \geq M$, we can choose $M$ large enough such that $|G(t)| \leq |I| + 1$ for all $t \geq 1$.
    obtain ‚ü®M', hM'‚ü© : ‚àÉ M', ‚àÄ t ‚àà Set.Icc 1 M, |G t| ‚â§ M' := by
      exact IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) ( hG_cont.mono ( Set.Icc_subset_Ici_self ) ) |> Exists.imp fun M' hM' t ht => hM' t ht;
    exact ‚ü® Max.max M' ( |I| + 1 ), fun t ht => if h : t ‚â§ M then le_trans ( hM' t ‚ü® ht, h ‚ü© ) ( le_max_left _ _ ) else le_trans ( le_of_lt ( by linarith [ abs_lt.mp ( hM t ( le_of_not_ge h ) ) ] ) ) ( le_max_right _ _ ) ‚ü©;
  -- For $l < \beta$, we use the integration by parts formula.
  have h_int_parts : ‚àÄ l < Œ≤, ‚àÉ I : ‚Ñù, Filter.Tendsto (fun b : ‚Ñù => ‚à´ t in (1 : ‚Ñù)..b, t ^ l * f t) Filter.atTop (ùìù ((l - Œ≤) * ‚à´ t in Set.Ioi 1, t ^ (l - Œ≤ - 1) * G t * (-1))) := by
    intro l hl
    have h_int_parts_formula : ‚àÄ b ‚â• 1, ‚à´ t in (1 : ‚Ñù)..b, t ^ l * f t = b ^ (l - Œ≤) * G b - ‚à´ t in (1 : ‚Ñù)..b, (l - Œ≤) * t ^ (l - Œ≤ - 1) * G t := by
      intro b hb
      have h_integral : ‚à´ t in (1 : ‚Ñù)..b, t ^ l * f t = b ^ (l - Œ≤) * (‚à´ t in (1 : ‚Ñù)..b, t ^ Œ≤ * f t) - ‚à´ t in (1 : ‚Ñù)..b, (l - Œ≤) * t ^ (l - Œ≤ - 1) * (‚à´ x in (1 : ‚Ñù)..t, x ^ Œ≤ * f x) := by
        have := @problem_131_ibp;
        exact this hb hf;
      convert h_integral using 1;
      norm_num +zetaDelta at *;
      rw [ if_pos hb, intervalIntegral.integral_congr fun x hx => if_pos <| by linarith [ Set.mem_Icc.mp <| by simpa [ hb ] using hx ] ];
    -- The integral $\int_1^\infty t^{l-\beta-1} G(t) dt$ converges absolutely since $|G(t)| \leq M$ and $l-\beta-1 < -1$.
    have h_int_abs_conv : MeasureTheory.IntegrableOn (fun t : ‚Ñù => t ^ (l - Œ≤ - 1) * G t) (Set.Ioi 1) := by
      -- Since $|G(t)| \leq M$ and $l-\beta-1 < -1$, the integral $\int_1^\infty t^{l-\beta-1} G(t) dt$ converges absolutely.
      obtain ‚ü®M, hM‚ü© : ‚àÉ M, ‚àÄ t ‚â• 1, |G t| ‚â§ M := hG_bounded
      have h_int_abs_conv : MeasureTheory.IntegrableOn (fun t : ‚Ñù => t ^ (l - Œ≤ - 1) * M) (Set.Ioi 1) := by
        exact ( integrableOn_Ioi_rpow_of_lt ( by linarith ) ( by linarith ) ) |> fun h => h.mul_const _;
      refine' h_int_abs_conv.mono' _ _;
      ¬∑ exact MeasureTheory.AEStronglyMeasurable.mul ( measurable_id.pow_const _ |> Measurable.aestronglyMeasurable ) ( hG_cont.aestronglyMeasurable ( measurableSet_Ici ) |> fun h => h.mono_set <| Set.Ioi_subset_Ici_self );
      ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with t ht using by rw [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( Real.rpow_nonneg ( by linarith [ ht.out ] ) _ ) ] ; exact mul_le_mul_of_nonneg_left ( hM t ht.out.le ) ( Real.rpow_nonneg ( by linarith [ ht.out ] ) _ ) ;
    have h_int_conv : Filter.Tendsto (fun b : ‚Ñù => ‚à´ t in (1 : ‚Ñù)..b, (l - Œ≤) * t ^ (l - Œ≤ - 1) * G t) Filter.atTop (ùìù ((l - Œ≤) * ‚à´ t in Set.Ioi 1, t ^ (l - Œ≤ - 1) * G t)) := by
      have h_int_conv : Filter.Tendsto (fun b : ‚Ñù => ‚à´ t in (1 : ‚Ñù)..b, t ^ (l - Œ≤ - 1) * G t) Filter.atTop (ùìù (‚à´ t in Set.Ioi 1, t ^ (l - Œ≤ - 1) * G t)) := by
        apply_rules [ MeasureTheory.intervalIntegral_tendsto_integral_Ioi ];
        exact Filter.tendsto_id;
      simpa [ mul_assoc ] using h_int_conv.const_mul ( l - Œ≤ );
    have h_int_conv : Filter.Tendsto (fun b : ‚Ñù => b ^ (l - Œ≤) * G b) Filter.atTop (ùìù 0) := by
      have h_int_conv : Filter.Tendsto (fun b : ‚Ñù => b ^ (l - Œ≤)) Filter.atTop (nhds 0) := by
        simpa using tendsto_rpow_neg_atTop ( sub_pos.mpr hl );
      rw [ tendsto_zero_iff_norm_tendsto_zero ] at *;
      exact squeeze_zero_norm' ( Filter.eventually_atTop.mpr ‚ü® 1, fun x hx => by simpa [ abs_mul ] using mul_le_mul_of_nonneg_left ( hG_bounded.choose_spec x hx ) ( by positivity ) ‚ü© ) ( by simpa using h_int_conv.mul_const _ );
    simp_all +decide [ MeasureTheory.integral_neg, mul_neg ];
    simpa using Filter.Tendsto.congr' ( by filter_upwards [ Filter.eventually_ge_atTop 1 ] with b hb; aesop ) ( h_int_conv.sub ‚ÄπFilter.Tendsto ( fun b : ‚Ñù => ‚à´ t in ( 1 : ‚Ñù )..b, ( l - Œ≤ ) * t ^ ( l - Œ≤ - 1 ) * G t ) Filter.atTop ( ùìù ( ( l - Œ≤ ) * ‚à´ t in Set.Ioi 1, t ^ ( l - Œ≤ - 1 ) * G t ) ) ‚Ä∫ );
  -- Define the function $F$ such that $F(l) = \lim_{b \to \infty} \int_1^b t^l f(t) dt$.
  obtain ‚ü®F, hF‚ü© : ‚àÉ F : ‚Ñù ‚Üí ‚Ñù, (‚àÄ l ‚â§ Œ≤, Filter.Tendsto (fun b : ‚Ñù => ‚à´ t in (1 : ‚Ñù)..b, t ^ l * f t) Filter.atTop (ùìù (F l))) ‚àß (‚àÄ l < Œ≤, F l = (l - Œ≤) * ‚à´ t in Set.Ioi 1, t ^ (l - Œ≤ - 1) * G t * (-1)) ‚àß F Œ≤ = I := by
    use fun l => if l < Œ≤ then (l - Œ≤) * ‚à´ t in Set.Ioi 1, t ^ (l - Œ≤ - 1) * G t * (-1) else I;
    norm_num +zetaDelta at *;
    exact ‚ü® fun l hl => by cases lt_or_eq_of_le hl <;> aesop, fun l hl hl' => by linarith ‚ü©;
  -- Show that $F$ is continuous on $(-\infty, \beta)$.
  have hF_cont : ContinuousOn F (Set.Iio Œ≤) := by
    -- For $l < \beta$, we use the fact that the integral $\int_1^\infty t^{l-\beta-1} G(t) dt$ converges uniformly.
    have h_uniform_conv : ‚àÄ A B : ‚Ñù, A < B ‚Üí B < Œ≤ ‚Üí ContinuousOn (fun l => ‚à´ t in Set.Ioi 1, t ^ (l - Œ≤ - 1) * G t * (-1)) (Set.Icc A B) := by
      intros A B hAB hBŒ≤
      have h_dominate : ‚àÄ l ‚àà Set.Icc A B, ‚àÄ t ‚àà Set.Ioi 1, |t ^ (l - Œ≤ - 1) * G t * (-1)| ‚â§ hG_bounded.choose * t ^ (B - Œ≤ - 1) := by
        intros l hl t ht
        have h_abs : |t ^ (l - Œ≤ - 1) * G t * (-1)| ‚â§ hG_bounded.choose * t ^ (l - Œ≤ - 1) := by
          norm_num [ abs_mul, mul_comm ];
          rw [ abs_of_nonneg ( Real.rpow_nonneg ( by linarith [ ht.out ] ) _ ) ] ; exact mul_le_mul_of_nonneg_left ( hG_bounded.choose_spec t ( by linarith [ ht.out ] ) ) ( Real.rpow_nonneg ( by linarith [ ht.out ] ) _ );
        exact h_abs.trans ( mul_le_mul_of_nonneg_left ( Real.rpow_le_rpow_of_exponent_le ht.out.le ( by linarith [ hl.1, hl.2 ] ) ) ( show 0 ‚â§ hG_bounded.choose by exact le_trans ( abs_nonneg _ ) ( hG_bounded.choose_spec 1 le_rfl ) ) );
      intro l hl;
      refine' MeasureTheory.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _;
      use fun t => hG_bounded.choose * t ^ ( B - Œ≤ - 1 );
      ¬∑ refine' Filter.eventually_of_mem self_mem_nhdsWithin fun n hn => MeasureTheory.AEStronglyMeasurable.mul _ _;
        ¬∑ exact MeasureTheory.AEStronglyMeasurable.mul ( measurable_id.pow_const _ |> Measurable.aestronglyMeasurable ) ( hG_cont.aestronglyMeasurable ( measurableSet_Ici ) |> fun h => h.mono_set <| Set.Ioi_subset_Ici_self );
        ¬∑ exact MeasureTheory.aestronglyMeasurable_const;
      ¬∑ filter_upwards [ self_mem_nhdsWithin ] with n hn using Filter.eventually_of_mem ( MeasureTheory.ae_restrict_mem measurableSet_Ioi ) fun t ht => h_dominate n hn t ht;
      ¬∑ exact ( integrableOn_Ioi_rpow_of_lt ( by linarith ) ( by linarith ) ) |> fun h => h.const_mul _;
      ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with t ht;
        exact Filter.Tendsto.mul ( Filter.Tendsto.mul ( tendsto_const_nhds.rpow ( Continuous.continuousWithinAt ( by continuity ) ) ( Or.inl <| by linarith [ ht.out ] ) ) tendsto_const_nhds ) tendsto_const_nhds;
    intro l hl;
    have h_cont_at_l : ContinuousAt (fun l => (l - Œ≤) * ‚à´ t in Set.Ioi 1, t ^ (l - Œ≤ - 1) * G t * (-1)) l := by
      exact ContinuousAt.mul ( continuousAt_id.sub continuousAt_const ) ( h_uniform_conv ( l - ( Œ≤ - l ) / 2 ) ( l + ( Œ≤ - l ) / 2 ) ( by linarith [ hl.out ] ) ( by linarith [ hl.out ] ) |> ContinuousOn.continuousAt <| Icc_mem_nhds ( by linarith [ hl.out ] ) ( by linarith [ hl.out ] ) );
    exact ContinuousAt.continuousWithinAt ( by exact h_cont_at_l.congr ( Filter.eventuallyEq_of_mem ( Iio_mem_nhds hl ) fun x hx => by rw [ hF.2.1 x hx ] ) );
  -- Show that $F$ is continuous at $\beta$.
  have hF_cont_beta : Filter.Tendsto F (nhdsWithin Œ≤ (Set.Iio Œ≤)) (nhds I) := by
    have hF_cont_beta : Filter.Tendsto (fun k => k * ‚à´ t in Set.Ioi 1, t ^ (-k - 1) * G t) (nhdsWithin 0 (Set.Ioi 0)) (nhds I) := by
      convert limit_of_weighted_average hG_cont hG_lim using 1;
    rw [ Metric.tendsto_nhdsWithin_nhds ] at *;
    intro Œµ hŒµ; rcases hF_cont_beta Œµ hŒµ with ‚ü® Œ¥, hŒ¥, H ‚ü© ; use Œ¥, hŒ¥; intro x hx‚ÇÅ hx‚ÇÇ; rw [ hF.2.1 x hx‚ÇÅ ] ; simp_all +decide [ dist_eq_norm ] ;
    convert H ( show 0 < Œ≤ - x by linarith ) ( by rw [ abs_lt ] at *; constructor <;> linarith ) using 1 ; norm_num [ MeasureTheory.integral_neg ] ; ring;
  refine' ‚ü® fun l hl => ‚ü® _, hF.1 l hl ‚ü©, F, hF.1, _ ‚ü©;
  intro l hl; by_cases hl' : l = Œ≤ <;> simp_all +decide [ ContinuousWithinAt ] ;
  ¬∑ rw [ Metric.tendsto_nhdsWithin_nhds ] at *;
    intro Œµ hŒµ; rcases hF_cont_beta Œµ hŒµ with ‚ü® Œ¥, hŒ¥, H ‚ü© ; exact ‚ü® Œ¥, hŒ¥, fun x hx‚ÇÅ hx‚ÇÇ => by cases lt_or_eq_of_le hx‚ÇÅ.out <;> aesop ‚ü© ;
  ¬∑ exact hF_cont.continuousAt ( Iio_mem_nhds ( lt_of_le_of_ne hl hl' ) ) |> fun h => h.mono_left ( nhdsWithin_le_nhds )

/-
Part 1 of Problem 131: Convergence and continuity on $(-\infty, \beta]$ for continuous $f$.
-/
open MeasureTheory Filter Topology Set

lemma problem_131_part1_v2 {f : ‚Ñù ‚Üí ‚Ñù} {Œ≤ : ‚Ñù}
    (hf : ContinuousOn f (Ici 0))
    (h_conv : ‚àÉ I, Tendsto (fun b => ‚à´ t in 1..b, t^Œ≤ * f t) atTop (ùìù I)) :
    (‚àÄ l ‚â§ Œ≤, ‚àÉ I, Tendsto (fun b => ‚à´ t in 1..b, t^l * f t) atTop (ùìù I)) ‚àß
    (‚àÉ F : ‚Ñù ‚Üí ‚Ñù, (‚àÄ l ‚â§ Œ≤, Tendsto (fun b => ‚à´ t in 1..b, t^l * f t) atTop (ùìù (F l))) ‚àß ContinuousOn F (Iic Œ≤)) := by
  -- Apply the lemma `problem_131_part1` to obtain the required results.
  apply problem_131_part1 hf h_conv

/-
Change of variables $u=1/t$ transforms $\int_x^1 t^l f(t) dt$ to $\int_1^{1/x} u^{-l-2} f(1/u) du$.
-/
open MeasureTheory Filter Topology Set

lemma integral_transformation {f : ‚Ñù ‚Üí ‚Ñù} {l x : ‚Ñù} (hx : 0 < x) (hx' : x ‚â§ 1)
    (hf : ContinuousOn f (Ioc 0 1)) :
    ‚à´ t in x..1, t^l * f t = ‚à´ u in 1..(1/x), u^(-l-2) * f (1/u) := by
  suffices h_suff : ‚àÄ {a b : ‚Ñù}, 0 < a ‚Üí a ‚â§ b ‚Üí b ‚â§ 1 ‚Üí ‚à´ t in a..b, t^l * f t = ‚à´ u in (1 / b).. (1 / a), u^(-l - 2 : ‚Ñù) * f (1 / u) by
    simpa using h_suff hx hx' le_rfl;
  intros a b _ _ _;
  rw [ ‚Üê intervalIntegral.integral_comp_mul_deriv' ];
  any_goals intro x hx; exact HasDerivAt.const_mul _ ( hasDerivAt_inv ( by cases Set.mem_uIcc.mp hx <;> linarith ) );
  ¬∑ rw [ intervalIntegral.integral_symm ];
    rw [ ‚Üê intervalIntegral.integral_neg ] ; refine' intervalIntegral.integral_congr fun x hx => _ ; by_cases hx' : x = 0 <;> simp +decide [ hx', mul_assoc, mul_comm, mul_left_comm, Real.rpow_sub_one ] ;
    ¬∑ cases Set.mem_uIcc.mp hx <;> linarith;
    ¬∑ rw [ Real.inv_rpow ( by cases Set.mem_uIcc.mp hx <;> linarith ) ] ; ring;
      norm_num [ Real.rpow_sub ( show 0 < x by cases Set.mem_uIcc.mp hx <;> linarith ), Real.rpow_neg ( show 0 ‚â§ x by cases Set.mem_uIcc.mp hx <;> linarith ) ] ; ring ; aesop;
  ¬∑ exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.mul continuousAt_const <| ContinuousAt.neg <| ContinuousAt.inv‚ÇÄ ( continuousAt_id.pow 2 ) <| ne_of_gt <| sq_pos_of_pos <| by cases Set.mem_uIcc.mp hx <;> linarith;
  ¬∑ refine' ContinuousOn.mul _ _;
    ¬∑ exact continuousOn_of_forall_continuousAt fun u hu => ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by rcases hu with ‚ü® u, hu, rfl ‚ü© ; cases Set.mem_uIcc.mp hu <;> norm_num <;> linarith;
    ¬∑ refine' hf.comp _ _;
      ¬∑ exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.div continuousAt_const continuousAt_id ( by rcases hx with ‚ü® y, hy, rfl ‚ü© ; exact one_div_ne_zero <| by cases Set.mem_uIcc.mp hy <;> linarith );
      ¬∑ norm_num [ Set.MapsTo ];
        exact fun x hx => ‚ü® inv_pos.mp ( by cases Set.mem_uIcc.mp hx <;> linarith ), by cases Set.mem_uIcc.mp hx <;> nlinarith [ inv_mul_cancel‚ÇÄ ( show x ‚â† 0 by rintro rfl; norm_num at hx ; linarith ) ] ‚ü©

/-
Part 2 of Problem 131: Convergence and continuity on $[\alpha, \infty)$ for continuous $f$ on $(0, 1]$.
-/
open MeasureTheory Filter Topology Set

lemma problem_131_part2 {f : ‚Ñù ‚Üí ‚Ñù} {Œ± : ‚Ñù}
    (hf : ContinuousOn f (Ioc 0 1))
    (h_conv : ‚àÉ I, Tendsto (fun x => ‚à´ t in x..1, t^Œ± * f t) (ùìù[>] 0) (ùìù I)) :
    (‚àÄ l ‚â• Œ±, ‚àÉ I, Tendsto (fun x => ‚à´ t in x..1, t^l * f t) (ùìù[>] 0) (ùìù I)) ‚àß
    (‚àÉ F : ‚Ñù ‚Üí ‚Ñù, (‚àÄ l ‚â• Œ±, Tendsto (fun x => ‚à´ t in x..1, t^l * f t) (ùìù[>] 0) (ùìù (F l))) ‚àß ContinuousOn F (Ici Œ±)) := by
  -- Let $g(u) = u^{-\alpha-2} f(1/u)$ for $u \ge 1$. Extend $g$ to $[0, \infty)$ by setting $g(u) = f(1)$ for $u < 1$ (or similar constant to make it continuous).
  set g : ‚Ñù ‚Üí ‚Ñù := fun u => if u ‚â• 1 then u^(-Œ±-2) * f (1/u) else f 1;
  have hg_cont : ContinuousOn g (Set.Ici 0) := by
    apply_rules [ ContinuousOn.if, continuousOn_const ];
    ¬∑ erw [ frontier_Ici ] ; aesop;
    ¬∑ -- Since $a \geq 1$ on the closure of $\{a | a \geq 1\}$, we can apply the continuity of $a^{-\alpha-2}$ and $f(1/a)$ on this interval.
      have h_cont : ContinuousOn (fun a : ‚Ñù => a ^ (-Œ± - 2) * f (1 / a)) (Set.Ici 1) := by
        exact ContinuousOn.mul ( continuousOn_of_forall_continuousAt fun x hx => by exact ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by linarith [ hx.out ] ) <| hf.comp ( continuousOn_const.div continuousOn_id fun x hx => by norm_num; linarith [ hx.out ] ) fun x hx => ‚ü® by exact one_div_pos.mpr <| by linarith [ hx.out ], by exact div_le_one_of_le‚ÇÄ ( by linarith [ hx.out ] ) <| by linarith [ hx.out ] ‚ü©;
      exact h_cont.mono ( by rw [ show { a : ‚Ñù | a ‚â• 1 } = Set.Ici 1 by rfl ] ; exact fun x hx => hx.2 |> fun hx' => by rw [ closure_Ici ] at hx'; aesop );
  -- By problem_131_part1_v2, the integral $\int_1^\infty u^\lambda g(u) du$ converges for all $\lambda \le 0$ and is continuous in $\lambda$.
  obtain ‚ü®F, hF‚ü© : ‚àÉ F : ‚Ñù ‚Üí ‚Ñù, (‚àÄ l ‚â§ 0, (Filter.Tendsto (fun b => ‚à´ u in (1)..b, u^l * g u) Filter.atTop (ùìù (F l)))) ‚àß (ContinuousOn F (Set.Iic 0)) := by
    have h_conv_g : ‚àÉ I, Filter.Tendsto (fun b => ‚à´ u in (1)..b, u^0 * g u) Filter.atTop (ùìù I) := by
      -- By definition of $g$, we know that $\int_1^b g(u) du = \int_1^b u^{-\alpha-2} f(1/u) du$.
      have h_integral_g : ‚àÄ b ‚â• 1, ‚à´ u in (1)..b, g u = ‚à´ t in (1/b)..1, t^Œ± * f t := by
        intro b hb
        have h_integral_g : ‚à´ u in (1)..b, g u = ‚à´ u in (1)..b, u^(-Œ±-2) * f (1/u) := by
          refine' intervalIntegral.integral_congr fun u hu => _ ; aesop;
        rw [ h_integral_g, eq_comm ];
        convert integral_transformation ( show 0 < 1 / b by positivity ) ( show 1 / b ‚â§ 1 by rw [ div_le_iff‚ÇÄ ] <;> linarith ) ( hf.mono <| Set.Ioc_subset_Ioc ( by positivity ) le_rfl ) using 1 ; norm_num [ hb ];
      simp +zetaDelta at *;
      obtain ‚ü® I, hI ‚ü© := h_conv; use I; rw [ Filter.tendsto_congr' ( by filter_upwards [ Filter.eventually_ge_atTop 1 ] with b hb; rw [ h_integral_g b hb ] ) ] ; exact hI.comp <| Filter.tendsto_inf.mpr ‚ü® tendsto_inv_atTop_zero, Filter.tendsto_principal.mpr <| Filter.eventually_atTop.mpr ‚ü® 1, fun x hx => by norm_num; linarith ‚ü© ‚ü© ;
    have := @problem_131_part1_v2 g 0 ; aesop;
  -- For any $l \ge \alpha$, we have $\int_x^1 t^l f(t) dt = \int_1^{1/x} u^{-l-2} f(1/u) du = \int_1^{1/x} u^{\alpha-l} (u^{-\alpha-2} f(1/u)) du = \int_1^{1/x} u^\lambda g(u) du$ where $\lambda = \alpha - l \le 0$.
  have h_integral_transform : ‚àÄ l ‚â• Œ±, ‚àÄ x ‚àà Set.Ioo 0 1, ‚à´ t in x..1, t^l * f t = ‚à´ u in (1)..(1/x), u^(Œ±-l) * g u := by
    intros l hl x hx
    have h_integral_transform_step : ‚à´ t in x..1, t^l * f t = ‚à´ u in (1)..(1/x), u^(-l-2) * f (1/u) := by
      apply integral_transformation hx.1 hx.2.le;
      assumption;
    norm_num +zetaDelta at *;
    rw [ h_integral_transform_step ];
    refine' intervalIntegral.integral_congr fun u hu => _;
    rw [ if_pos ( by cases Set.mem_uIcc.mp hu <;> nlinarith [ inv_mul_cancel‚ÇÄ hx.1.ne' ] ) ] ; rw [ ‚Üê mul_assoc, ‚Üê Real.rpow_add ( by cases Set.mem_uIcc.mp hu <;> nlinarith [ inv_mul_cancel‚ÇÄ hx.1.ne' ] ) ] ; ring;
  -- Therefore, for any $l \ge \alpha$, the integral $\int_x^1 t^l f(t) dt$ converges as $x \to 0^+$ to $F(\alpha - l)$.
  have h_integral_converge : ‚àÄ l ‚â• Œ±, Filter.Tendsto (fun x => ‚à´ t in x..1, t^l * f t) (ùìù[>] 0) (ùìù (F (Œ± - l))) := by
    intro l hl
    have h_integral_converge_step : Filter.Tendsto (fun x => ‚à´ u in (1)..(1/x), u^(Œ±-l) * g u) (ùìù[>] 0) (ùìù (F (Œ± - l))) := by
      convert hF.1 ( Œ± - l ) ( by linarith ) |> Filter.Tendsto.comp <| tendsto_inv_nhdsGT_zero using 2 ; norm_num;
    refine' h_integral_converge_step.congr' ( by filter_upwards [ Ioo_mem_nhdsGT zero_lt_one ] with x hx using h_integral_transform l hl x hx ‚ñ∏ rfl );
  refine' ‚ü® fun l hl => ‚ü® _, h_integral_converge l hl ‚ü©, fun l => F ( Œ± - l ), fun l hl => h_integral_converge l hl, _ ‚ü©;
  exact hF.2.comp ( continuousOn_const.sub continuousOn_id ) fun x hx => by aesop;

/-
Reduction of Part 2 to Part 1 by constructing a function $g$.
-/
open MeasureTheory Filter Topology Set

lemma problem_131_part2_reduction {f : ‚Ñù ‚Üí ‚Ñù} {Œ± : ‚Ñù} (hf : ContinuousOn f (Ioc 0 1)) :
    ‚àÉ g : ‚Ñù ‚Üí ‚Ñù, ContinuousOn g (Ici 0) ‚àß
    (‚àÄ l : ‚Ñù, ‚àÄ x ‚àà Ioc 0 1, ‚à´ t in x..1, t^l * f t = ‚à´ u in 1..(1/x), u^(Œ±-l) * g u) := by
  -- Define $g(u) = u^{-\alpha-2} f(1/u)$ for $u \ge 1$, and $g(u) = f(1)$ for $u < 1$.
  set g : ‚Ñù ‚Üí ‚Ñù := fun u => if u ‚â• 1 then u^(-Œ± - 2) * f (1 / u) else f 1;
  -- Show that $g$ is continuous on $[0, \infty)$.
  have hg_cont : ContinuousOn g (Set.Ici 0) := by
    apply_rules [ ContinuousOn.if, continuousOn_const ];
    ¬∑ erw [ frontier_Ici ] ; aesop;
    ¬∑ norm_num [ show { a : ‚Ñù | 1 ‚â§ a } = Set.Ici 1 by rfl, closure_Ici ];
      refine' ContinuousOn.mul _ _;
      ¬∑ exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by linarith [ hx.out ] ;
      ¬∑ exact hf.comp ( continuousOn_inv‚ÇÄ.mono fun x hx => ne_of_gt <| zero_lt_one.trans_le hx ) fun x hx => ‚ü® inv_pos.mpr <| zero_lt_one.trans_le hx, inv_le_one_of_one_le‚ÇÄ hx ‚ü©;
  refine ‚ü® g, hg_cont, ?_ ‚ü©;
  intro l x hx
  have h_integral : ‚à´ t in x..1, t^l * f t = ‚à´ u in (1 : ‚Ñù)..1 / x, u^(-l - 2) * f (1 / u) := by
    apply integral_transformation hx.1 hx.2 hf;
  norm_num +zetaDelta at *;
  rw [ h_integral ];
  refine' intervalIntegral.integral_congr fun u hu => _;
  rw [ if_pos ( by cases Set.mem_uIcc.mp hu <;> nlinarith [ inv_mul_cancel‚ÇÄ hx.1.ne' ] ) ] ; rw [ ‚Üê mul_assoc, ‚Üê Real.rpow_add ( by cases Set.mem_uIcc.mp hu <;> nlinarith [ inv_mul_cancel‚ÇÄ hx.1.ne' ] ) ] ; ring