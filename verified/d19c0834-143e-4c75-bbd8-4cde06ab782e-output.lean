/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d19c0834-143e-4c75-bbd8-4cde06ab782e

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open MeasureTheory Filter intervalIntegral

#check volume
#check Tendsto
#check IntervalIntegrable

/-
Necessary condition: If the integral of p_n * f converges to f(x) for all continuous f, then the integral of p_n over the region at distance > ε from x converges to 0.
-/
open MeasureTheory Filter intervalIntegral Set Real Topology

lemma problem_129_necessary {a b x : ℝ} (hab : a ≤ b) (hx : x ∈ Icc a b)
    {p : ℕ → ℝ → ℝ} (hp_integrable : ∀ n, IntervalIntegrable (p n) volume a b)
    (hp_nonneg : ∀ n t, 0 ≤ p n t)
    (hp_norm_one : ∀ n, ∫ t in a..b, p n t = 1)
    (h_conv : ∀ f : ℝ → ℝ, ContinuousOn f (Icc a b) →
        Tendsto (λ n => ∫ t in a..b, p n t * f t) atTop (nhds (f x))) :
    ∀ ε > 0,
        let I1 n := if a ≤ x - ε then ∫ t in a..(x - ε), p n t else 0
        let I2 n := if x + ε ≤ b then ∫ t in (x + ε)..b, p n t else 0
        Tendsto (λ n => I1 n + I2 n) atTop (nhds 0) := by
  intro ε hε_pos
  set I1 : ℕ → ℝ := fun n => if a ≤ x - ε then (∫ t in a..x - ε, (p n t)) else 0
  set I2 : ℕ → ℝ := fun n => if x + ε ≤ b then (∫ t in x + ε..b, (p n t)) else 0
  have h_I1_I2 : ∀ n, I1 n + I2 n ≤ ∫ t in a..b, (p n t) * (max 0 (min 1 (abs (t - x) / ε))) := by
    intro n
    have h_I1_I2 : ∫ t in a..b, (p n t) * (max 0 (min 1 (abs (t - x) / ε))) ≥ (∫ t in Set.Ioc a (x - ε), (p n t)) + (∫ t in Set.Ioc (x + ε) b, (p n t)) := by
      have h_I1_I2 : ∫ t in a..b, (p n t) * (max 0 (min 1 (abs (t - x) / ε))) ≥ (∫ t in Set.Ioc a (x - ε), (p n t) * (max 0 (min 1 (abs (t - x) / ε)))) + (∫ t in Set.Ioc (x + ε) b, (p n t) * (max 0 (min 1 (abs (t - x) / ε)))) := by
        rw [ ← MeasureTheory.setIntegral_union ] <;> norm_num;
        · rw [ intervalIntegral.integral_of_le hab ];
          refine' MeasureTheory.setIntegral_mono_set _ _ _;
          · refine' MeasureTheory.Integrable.mono' _ _ _;
            refine' fun t => p n t;
            · simpa only [ intervalIntegrable_iff_integrableOn_Ioc_of_le hab ] using hp_integrable n;
            · exact MeasureTheory.AEStronglyMeasurable.mul ( hp_integrable n |> fun h => h.aestronglyMeasurable ) ( Measurable.aestronglyMeasurable ( by exact Measurable.max measurable_const ( Measurable.min measurable_const ( by exact Measurable.div_const ( measurable_norm.comp ( measurable_id.sub measurable_const ) ) _ ) ) ) );
            · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using by rw [ Real.norm_of_nonneg ( mul_nonneg ( hp_nonneg n t ) ( by positivity ) ) ] ; exact mul_le_of_le_one_right ( hp_nonneg n t ) ( by cases max_cases ( 0 : ℝ ) ( Min.min 1 ( |t - x| / ε ) ) <;> cases min_cases ( 1 : ℝ ) ( |t - x| / ε ) <;> linarith ) ;
          · exact Filter.Eventually.of_forall fun t => mul_nonneg ( hp_nonneg n t ) ( le_max_left _ _ );
          · exact MeasureTheory.ae_of_all _ fun t ht => by cases ht <;> constructor <;> linarith [ Set.mem_Ioc.mp ‹_›, hx.1, hx.2 ] ;
        · exact Or.inr <| Or.inl <| by linarith;
        · have h_integrable : MeasureTheory.IntegrableOn (fun t => p n t) (Set.Ioc a (x - ε)) := by
            have := hp_integrable n;
            exact this.1.mono_set ( Set.Ioc_subset_Ioc le_rfl ( by linarith [ hx.1, hx.2 ] ) );
          refine' h_integrable.mono' _ _;
          · exact MeasureTheory.AEStronglyMeasurable.mul ( h_integrable.aestronglyMeasurable ) ( Measurable.aestronglyMeasurable ( by exact Measurable.max measurable_const ( Measurable.min measurable_const ( by exact Measurable.div_const ( measurable_norm.comp ( measurable_id.sub measurable_const ) ) _ ) ) ) );
          · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using by rw [ Real.norm_of_nonneg ( mul_nonneg ( hp_nonneg _ _ ) ( by positivity ) ) ] ; exact mul_le_of_le_one_right ( hp_nonneg _ _ ) ( by cases max_cases ( 0 : ℝ ) ( Min.min 1 ( |t - x| / ε ) ) <;> cases min_cases ( 1 : ℝ ) ( |t - x| / ε ) <;> linarith ) ;
        · have h_integrable : MeasureTheory.IntegrableOn (fun t => p n t) (Set.Ioc (x + ε) b) := by
            have := hp_integrable n;
            exact this.1.mono_set ( Set.Ioc_subset_Ioc ( by linarith [ hx.1, hx.2 ] ) le_rfl );
          refine' h_integrable.mono' _ _;
          · exact MeasureTheory.AEStronglyMeasurable.mul ( h_integrable.aestronglyMeasurable ) ( Measurable.aestronglyMeasurable ( by exact Measurable.max measurable_const ( Measurable.min measurable_const ( by exact Measurable.div_const ( measurable_norm.comp ( measurable_id.sub measurable_const ) ) _ ) ) ) );
          · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using by rw [ Real.norm_of_nonneg ( mul_nonneg ( hp_nonneg n t ) ( by positivity ) ) ] ; exact mul_le_of_le_one_right ( hp_nonneg n t ) ( by cases max_cases ( 0 : ℝ ) ( Min.min 1 ( |t - x| / ε ) ) <;> cases min_cases ( 1 : ℝ ) ( |t - x| / ε ) <;> linarith ) ;
      refine le_trans ?_ h_I1_I2;
      refine' add_le_add _ _;
      · refine' MeasureTheory.setIntegral_mono_on _ _ measurableSet_Ioc fun t ht => le_mul_of_one_le_right ( hp_nonneg n t ) _;
        · exact ( hp_integrable n |> fun h => h.1.mono_set <| Set.Ioc_subset_Ioc_right <| by linarith [ hx.1, hx.2 ] );
        · refine' MeasureTheory.IntegrableOn.mono_set _ ( Set.Ioc_subset_Ioc_right ( show x - ε ≤ b by linarith [ hx.2 ] ) );
          refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun t => p n t;
          · simpa only [ intervalIntegrable_iff_integrableOn_Ioc_of_le hab ] using hp_integrable n;
          · exact MeasureTheory.AEStronglyMeasurable.mul ( hp_integrable n |> fun h => h.aestronglyMeasurable ) ( Measurable.aestronglyMeasurable ( by exact Measurable.max measurable_const ( Measurable.min measurable_const ( by exact Measurable.div_const ( measurable_norm.comp ( measurable_id.sub measurable_const ) ) _ ) ) ) );
          · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using by rw [ Real.norm_of_nonneg ( mul_nonneg ( hp_nonneg n t ) ( by positivity ) ) ] ; exact mul_le_of_le_one_right ( hp_nonneg n t ) ( by cases max_cases ( 0 : ℝ ) ( Min.min 1 ( |t - x| / ε ) ) <;> cases min_cases ( 1 : ℝ ) ( |t - x| / ε ) <;> linarith ) ;
        · cases max_cases ( 0 : ℝ ) ( Min.min 1 ( |t - x| / ε ) ) <;> cases min_cases ( 1 : ℝ ) ( |t - x| / ε ) <;> nlinarith [ abs_of_nonpos ( by linarith [ ht.1, ht.2 ] : t - x ≤ 0 ), ht.1, ht.2, mul_div_cancel₀ ( |t - x| ) hε_pos.ne' ];
      · refine' le_of_eq ( MeasureTheory.setIntegral_congr_fun measurableSet_Ioc fun t ht => _ );
        rw [ show Max.max 0 ( Min.min 1 ( |t - x| / ε ) ) = 1 by exact le_antisymm ( by norm_num ) ( by exact le_max_of_le_right ( by exact le_min ( by norm_num ) ( by rw [ le_div_iff₀ hε_pos ] ; cases abs_cases ( t - x ) <;> linarith [ ht.1, ht.2 ] ) ) ) ] ; ring;
    simp +zetaDelta at *;
    split_ifs <;> simp_all +decide [ intervalIntegral.integral_of_le ];
    · exact le_trans ( le_add_of_nonneg_right <| MeasureTheory.setIntegral_nonneg measurableSet_Ioc fun t ht => hp_nonneg n t ) h_I1_I2;
    · exact le_trans ( le_add_of_nonneg_left <| MeasureTheory.setIntegral_nonneg measurableSet_Ioc fun t ht => hp_nonneg n t ) h_I1_I2;
    · exact MeasureTheory.setIntegral_nonneg measurableSet_Ioc fun t ht => mul_nonneg ( hp_nonneg n t ) ( by positivity );
  refine' squeeze_zero ( fun n => _ ) h_I1_I2 _;
  · simp +zetaDelta at *;
    split_ifs <;> norm_num [ intervalIntegral.integral_of_le, hx, hε_pos.le ];
    · exact add_nonneg ( intervalIntegral.integral_nonneg ( by linarith ) fun t ht => hp_nonneg n t ) ( intervalIntegral.integral_nonneg ( by linarith ) fun t ht => hp_nonneg n t );
    · exact intervalIntegral.integral_nonneg ( by linarith ) fun t ht => hp_nonneg n t;
    · exact intervalIntegral.integral_nonneg ( by linarith ) fun t ht => hp_nonneg n t;
  · convert h_conv ( fun t => Max.max 0 ( Min.min 1 ( |t - x| / ε ) ) ) _ using 2 <;> norm_num [ abs_div, hε_pos.ne' ];
    fun_prop (disch := norm_num)

/-
Lemma: The product of an interval integrable function and a continuous function on [a, b] is interval integrable.
-/
open MeasureTheory Filter intervalIntegral Set Real Topology

lemma problem_129_integrable {a b : ℝ} (hab : a ≤ b)
    {p : ℝ → ℝ} (hp : IntervalIntegrable p volume a b)
    {f : ℝ → ℝ} (hf : ContinuousOn f (Icc a b)) :
    IntervalIntegrable (fun t => p t * f t) volume a b := by
  -- Since $f$ is continuous on $[a, b]$, it is bounded on $[a, b]$.
  obtain ⟨M, hM⟩ : ∃ M, ∀ t ∈ Set.Icc a b, |f t| ≤ M := by
    exact IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) hf;
  rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le hab ] at *;
  refine' MeasureTheory.Integrable.mono' _ _ _;
  refine' fun t => |p t| * M;
  · exact MeasureTheory.Integrable.mul_const ( hp.norm ) _;
  · exact hp.1.mul ( hf.aestronglyMeasurable measurableSet_Icc |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self );
  · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using by simpa only [ Real.norm_eq_abs, abs_mul ] using mul_le_mul_of_nonneg_left ( hM t <| Set.Ioc_subset_Icc_self ht ) ( abs_nonneg _ ) ;