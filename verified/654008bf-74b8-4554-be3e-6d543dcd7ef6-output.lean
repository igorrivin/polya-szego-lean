/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 654008bf-74b8-4554-be3e-6d543dcd7ef6
-/

/-
Formalization of Polya-Szego Problem 118.
Part 1 is formalized as a placeholder due to garbled original text, as requested.
Part 2 (Maximum Term and Central Index of a Power Series) is fully formalized and proved.
The maximum term μ(x) and central index ν(x) are defined, and it is shown that μ(x) is the maximum value of the terms and ν(x) is the largest index attaining this maximum.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Part 1 of Polya-Szego Problem 118 (placeholder statement)
-/
theorem problem_118_part1 {r s : ℕ → ℝ} (hr_pos : ∀ m, 0 < r m) (hs_pos : ∀ m, 0 < s m)
    (hr_mono : ∀ m, r m ≤ r (m + 1)) (hs_mono : ∀ m, s m ≤ s (m + 1))
    (h_limit : Filter.Tendsto (λ m => r m / s m) Filter.atTop Filter.atTop) :
    ∀ (k : ℕ), ∀ (N : ℕ), ∃ (n r_val : ℕ), N ≤ n ∧ N ≤ r_val ∧
      True := by
  aesop

/-
Part 2 of Polya-Szego Problem 118: Existence and properties of the maximum term μ(x) and central index ν(x) for a power series with non-negative coefficients.
-/
open ENNReal Filter Topology Set

variable (p : ℕ → ℝ) (x : ℝ)

/-- The maximum term of the power series at x. -/
def mu : ℝ := ⨆ m, p m * x ^ m

/-- The central index of the power series at x (the largest index where the maximum is attained). -/
def nu : ℕ := sSup {m | p m * x ^ m = mu p x}

theorem problem_118_part2 (hp_nonneg : ∀ m, 0 ≤ p m) (hp_nonzero : ∃ m, p m ≠ 0)
    (ρ : ℝ≥0∞) (hρ_pos : ρ > 0)
    (hx_pos : 0 < x) (hx_lt_ρ : ENNReal.ofReal x < ρ)
    (h_conv : HasSum (λ m => p m * x ^ m) (tsum (λ m => p m * x ^ m))) :
    let μ_val := mu p x
    let ν_val := nu p x
    (∃ m, p m * x ^ m = μ_val) ∧ -- The maximum is attained
    (∀ m, p m * x ^ m ≤ μ_val) ∧ -- It is indeed the maximum
    p ν_val * x ^ ν_val = μ_val ∧ -- The central index attains it
    (∀ m, p m * x ^ m = μ_val → m ≤ ν_val) -- The central index is the largest such index
    := by
  -- Since the series converges, the set $\{m \mid p_m x^m = \mu(x)\}$ is non-empty and bounded above.
  have h_set_nonempty : {m | p m * x ^ m = ⨆ m, p m * x ^ m}.Nonempty := by
    have h_sup_exists : ∃ m, ∀ n, p n * x ^ n ≤ p m * x ^ m := by
      have h_max : ∃ m ∈ Set.range (fun m => p m * x ^ m), ∀ n ∈ Set.range (fun m => p m * x ^ m), m ≥ n := by
        have h_max_exists : Filter.Tendsto (fun m => p m * x ^ m) Filter.atTop (nhds 0) := by
          convert h_conv.summable.tendsto_atTop_zero;
        have h_max_exists : ∃ m ∈ Set.range (fun m => p m * x ^ m), ∀ n ∈ Set.range (fun m => p m * x ^ m), m ≥ n := by
          have h_compact : IsCompact (Set.range (fun m => p m * x ^ m) ∪ {0}) := by
            simpa using h_max_exists.isCompact_insert_range
          have := h_compact.exists_isGreatest;
          simp_all +decide [ IsGreatest, mem_upperBounds ];
          exact this.resolve_left fun h => hp_nonzero.elim fun m hm => hm <| by nlinarith [ h m, hp_nonneg m, pow_pos hx_pos m ] ;
        exact h_max_exists;
      aesop;
    exact ⟨ h_sup_exists.choose, le_antisymm ( le_ciSup ( show BddAbove ( Set.range ( fun m => p m * x ^ m ) ) from ⟨ _, Set.forall_mem_range.2 h_sup_exists.choose_spec ⟩ ) _ ) ( ciSup_le h_sup_exists.choose_spec ) ⟩
  have h_set_bounded_above : BddAbove {m | p m * x ^ m = ⨆ m, p m * x ^ m} := by
    have h_set_bounded_above : ∃ M, ∀ m ≥ M, p m * x ^ m < ⨆ m, p m * x ^ m := by
      have := h_conv.summable.tendsto_atTop_zero;
      have := this.eventually ( gt_mem_nhds <| show 0 < ⨆ m, p m * x ^ m from lt_of_lt_of_le ( mul_pos ( lt_of_le_of_ne ( hp_nonneg hp_nonzero.choose ) ( Ne.symm hp_nonzero.choose_spec ) ) ( pow_pos hx_pos _ ) ) ( le_ciSup ( show BddAbove ( Set.range fun m => p m * x ^ m ) from h_conv.summable.tendsto_atTop_zero.bddAbove_range ) _ ) ) ; aesop;
    exact ⟨ h_set_bounded_above.choose, fun m hm => not_lt.1 fun contra => hm.out.not_lt <| h_set_bounded_above.choose_spec m contra.le ⟩;
  refine' ⟨ h_set_nonempty, fun m => le_ciSup ( show BddAbove ( Set.range fun m => p m * x ^ m ) from _ ) m, _, _ ⟩;
  · exact h_conv.summable.tendsto_atTop_zero.bddAbove_range;
  · exact ( IsCompact.sSup_mem ( show IsCompact { m : ℕ | p m * x ^ m = ⨆ m : ℕ, p m * x ^ m } from Set.Finite.isCompact <| Set.finite_iff_bddAbove.mpr h_set_bounded_above ) <| by simpa using h_set_nonempty );
  · exact fun m hm => le_csSup h_set_bounded_above hm