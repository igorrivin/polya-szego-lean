/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: cb40618a-6b52-4fce-8cd5-84b0607fae1f
-/

/-
Formalization of Polya-Szego Problem 144.

We define the Bernstein polynomial operator `bernsteinPoly` and prove two main results:
1. `problem_144_part1`: Computes the Bernstein polynomials for $f(x) = 1, x, x^2, e^x$.
   - For $f(x)=1$, $K_n(x) = 1$.
   - For $f(x)=x$, $K_n(x) = x$.
   - For $f(x)=x^2$, $K_n(x) = x^2 + \frac{x-x^2}{n}$.
   - For $f(x)=e^x$, $K_n(x) = (e^{1/n}x + (1-x))^n$. (Note: The original problem statement had a slightly different form for $e^x$, but this form is equivalent and easier to prove directly from the binomial theorem).

2. `problem_144_part2`: Proves the bound on the tail sum of the binomial distribution.
   - Specifically, we split the sum $1 = \sum_{v=0}^n \binom{n}{v} x^v (1-x)^{n-v}$ into two parts $\Sigma^{\mathrm{I}}$ and $\Sigma^{\mathrm{II}}$ based on whether $|v - nx| \le n^{3/4}$ or $|v - nx| > n^{3/4}$.
   - We prove that $\Sigma^{\mathrm{II}} < \frac{1}{4\sqrt{n}}$.

The proofs utilize properties of the binomial distribution, specifically the first and second moments, and Chebyshev's inequality (or a direct variance bound in this specific case).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Real Finset BigOperators

/-- Bernstein polynomial operator -/
noncomputable def bernsteinPoly (f : ℝ → ℝ) (n : ℕ) (x : ℝ) : ℝ :=
  ∑ v ∈ range (n + 1), f ((v : ℝ) / (n : ℝ)) * (n.choose v : ℝ) * x ^ v * (1 - x) ^ (n - v)

/-- Part 1: Compute Bernstein polynomials for specific functions -/
theorem problem_144_part1 :
  (∀ (n : ℕ) (x : ℝ), n ≠ 0 → bernsteinPoly (λ _ => (1 : ℝ)) n x = 1) ∧
  (∀ (n : ℕ) (x : ℝ), n ≠ 0 → bernsteinPoly (λ t => t) n x = x) ∧
  (∀ (n : ℕ) (x : ℝ), n ≠ 0 → bernsteinPoly (λ t => t^2) n x = x^2 + (x - x^2) / n) ∧
  (∀ (n : ℕ) (x : ℝ), n ≠ 0 → bernsteinPoly Real.exp n x = ((Real.exp (1/n) - 1) * x + 1) ^ n) := by
  refine' ⟨ _, _, _, _ ⟩;
  · -- By the binomial theorem, we know that $(x + (1 - x))^n = 1^n = 1$.
    have h_binom : ∀ x : ℝ, (x + (1 - x))^Nat.succ 0 = 1 := by
      norm_num;
    intro n x hn; rw [ bernsteinPoly ] ; simp +decide [ hn, h_binom ] ;
    exact ( by rw [ show ( ∑ i ∈ Finset.range ( n + 1 ), ( n.choose i : ℝ ) * x ^ i * ( 1 - x ) ^ ( n - i ) ) = ( x + ( 1 - x ) ) ^ n by rw [ add_pow ] ; ac_rfl ] ; aesop );
  · -- By definition of Bernstein polynomials, we know that for the function $f(t) = t$, the Bernstein polynomial of degree $n$ is given by $B_n(t) = \sum_{k=0}^{n} \frac{k}{n} \binom{n}{k} t^k (1-t)^{n-k}$.
    intro n x hn
    simp [bernsteinPoly];
    -- We'll use the fact that $\sum_{v=0}^{n} v \binom{n}{v} x^v (1-x)^{n-v} = nx$.
    have h_sum : ∑ v ∈ Finset.range (n + 1), (v : ℝ) * Nat.choose n v * x ^ v * (1 - x) ^ (n - v) = n * x * (x + (1 - x)) ^ (n - 1) := by
      have h_sum : ∑ v ∈ Finset.range (n + 1), (v : ℝ) * (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) = n * x * ∑ v ∈ Finset.range (n), (Nat.choose (n - 1) v : ℝ) * x ^ v * (1 - x) ^ (n - 1 - v) := by
        norm_num [ Finset.mul_sum _ _ _, Finset.sum_range_succ' ];
        -- Apply the combinatorial identity $(n choose k+1) = n * (n-1 choose k) / (k+1)$ to rewrite the sum.
        have h_identity : ∀ i ∈ Finset.range n, (i + 1) * (Nat.choose n (i + 1) : ℝ) = n * (Nat.choose (n - 1) i : ℝ) := by
          norm_cast;
          cases n <;> simp_all +decide [ Nat.succ_mul_choose_eq ];
          exact fun _ _ => mul_comm _ _;
        exact Finset.sum_congr rfl fun i hi => by rw [ h_identity i hi ] ; rw [ Nat.sub_sub ] ; ring;
      rw [ h_sum, add_pow ];
      exact congrArg _ ( by rw [ Nat.sub_add_cancel ( Nat.pos_of_ne_zero hn ) ] ; ac_rfl );
    simp_all +decide [ div_mul_eq_mul_div, ← Finset.sum_div ];
  · intro n x hn_ne; simp +decide [ bernsteinPoly, hn_ne ] ; ring;
    -- We'll use the fact that $\sum_{v=0}^{n} v^2 \binom{n}{v} x^v (1-x)^{n-v} = n x (1-x) + n^2 x^2$.
    have h_sum : ∑ v ∈ Finset.range (n + 1), (v : ℝ) ^ 2 * (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) = n * x * (1 - x) + n ^ 2 * x ^ 2 := by
      have h_sum : ∑ v ∈ Finset.range (n + 1), (v : ℝ) * (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) = n * x := by
        have h_sum : ∑ v ∈ Finset.range (n + 1), (v : ℝ) * (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) = n * x * ∑ v ∈ Finset.range (n), (Nat.choose (n - 1) v : ℝ) * x ^ v * (1 - x) ^ (n - 1 - v) := by
          rw [ Finset.sum_range_succ' ];
          have h_sum : ∀ k ∈ Finset.range n, (k + 1 : ℝ) * (Nat.choose n (k + 1) : ℝ) = n * (Nat.choose (n - 1) k : ℝ) := by
            norm_cast; cases n <;> simp_all +decide [ Nat.succ_mul_choose_eq ] ;
            exact fun _ _ => mul_comm _ _;
          norm_num [ Finset.mul_sum _ _ _, mul_assoc, mul_left_comm, tsub_tsub, add_comm ];
          exact Finset.sum_congr rfl fun i hi => by linear_combination' h_sum i hi * x ^ ( i + 1 ) * ( 1 - x ) ^ ( n - ( i + 1 ) ) ;
        have h_sum : ∑ v ∈ Finset.range n, (Nat.choose (n - 1) v : ℝ) * x ^ v * (1 - x) ^ (n - 1 - v) = (x + (1 - x)) ^ (n - 1) := by
          rw [ add_pow ];
          rw [ Nat.sub_add_cancel ( Nat.pos_of_ne_zero hn_ne ) ] ; ac_rfl;
        aesop;
      have h_sum_sq : ∑ v ∈ Finset.range (n + 1), (v : ℝ) * (v - 1) * (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) = n * (n - 1) * x ^ 2 := by
        have h_sum_sq : ∑ v ∈ Finset.range (n + 1), (v : ℝ) * (v - 1) * (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) = n * (n - 1) * x ^ 2 * ∑ v ∈ Finset.range (n - 2 + 1), (Nat.choose (n - 2) v : ℝ) * x ^ v * (1 - x) ^ ((n - 2) - v) := by
          have h_sum_sq : ∑ v ∈ Finset.range (n + 1), (v : ℝ) * (v - 1) * (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) = ∑ v ∈ Finset.range (n - 2 + 1), (v + 2 : ℝ) * (v + 1) * (Nat.choose n (v + 2) : ℝ) * x ^ (v + 2) * (1 - x) ^ (n - (v + 2)) := by
            rcases n with ( _ | _ | n ) <;> simp_all +decide [ Finset.sum_range_succ' ];
            norm_cast;
          rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.succ_mul_choose_eq ];
          rw [ Finset.mul_sum _ _ _ ] ; refine' Finset.sum_congr rfl fun i hi => _ ; rw [ Nat.cast_choose, Nat.cast_choose ] <;> try linarith [ Finset.mem_range.mp hi ];
          field_simp;
          rw [ show n + 1 + 1 - ( i + 2 ) = n - i by omega ] ; push_cast [ Nat.factorial_succ ] ; ring;
        have h_sum_sq : ∑ v ∈ Finset.range (n - 2 + 1), (Nat.choose (n - 2) v : ℝ) * x ^ v * (1 - x) ^ ((n - 2) - v) = (x + (1 - x)) ^ (n - 2) := by
          rw [ add_pow ] ; congr ; ext ; ring;
        aesop;
      simp_all +decide [ mul_sub, sub_mul, Finset.sum_add_distrib, Finset.mul_sum _ _ _, Finset.sum_mul _ _ _, sq ] ; ring;
      rw [ add_comm, ← eq_comm ] ; ring_nf at * ; linarith;
    field_simp;
    rw [ add_comm, ← Finset.sum_div _ _ _, h_sum, mul_div, div_eq_iff ] <;> first | positivity | ring;
  · -- By definition of Bernstein polynomial, we have:
    intro n x hn
    have h_def : ∑ v ∈ Finset.range (n + 1), Real.exp (v / n) * (Nat.choose n v) * x ^ v * (1 - x) ^ (n - v) = ((Real.exp (1 / n) * x + (1 - x)) ^ n) := by
      rw [ add_pow ];
      exact Finset.sum_congr rfl fun i hi => by rw [ mul_pow ] ; rw [ ← Real.exp_nat_mul ] ; ring;
    convert h_def using 1 ; ring!

/-- Part 2: Bound on the tail sum of binomial probabilities -/
theorem problem_144_part2 (x : ℝ) (hx : x ∈ Set.Icc (0 : ℝ) 1) (n : ℕ) (hn : n ≥ 1) :
  let indices_I : Finset ℕ := (range (n + 1)).filter (λ v => |(v : ℝ) - n * x| ≤ (n : ℝ) ^ (3/4 : ℝ))
  let S_I := ∑ v ∈ indices_I, (n.choose v : ℝ) * x ^ v * (1 - x) ^ (n - v)
  let indices_II : Finset ℕ := (range (n + 1)).filter (λ v => |(v : ℝ) - n * x| > (n : ℝ) ^ (3/4 : ℝ))
  let S_II := ∑ v ∈ indices_II, (n.choose v : ℝ) * x ^ v * (1 - x) ^ (n - v)
  S_I + S_II = 1 ∧ S_II < (1/4 : ℝ) * (n : ℝ) ^ (-1/2 : ℝ) := by
  have h_sum : let indices_I : Finset ℕ := Finset.filter (fun v => |(v : ℝ) - n * x| ≤ (n : ℝ) ^ (3 / 4 : ℝ)) (Finset.range (n + 1));
    let S_I : ℝ := ∑ v ∈ indices_I, (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v);
    let indices_II : Finset ℕ := Finset.filter (fun v => |(v : ℝ) - n * x| > (n : ℝ) ^ (3 / 4 : ℝ)) (Finset.range (n + 1));
    let S_II : ℝ := ∑ v ∈ indices_II, (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v);
    S_I + S_II = 1 ∧ S_II ≤ (n * x * (1 - x)) / (n ^ (3 / 4 : ℝ)) ^ 2 := by
      have h_sum : let indices_I : Finset ℕ := Finset.filter (fun v => |(v : ℝ) - n * x| ≤ (n : ℝ) ^ (3 / 4 : ℝ)) (Finset.range (n + 1));
        let S_I : ℝ := ∑ v ∈ indices_I, (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v);
        let indices_II : Finset ℕ := Finset.filter (fun v => |(v : ℝ) - n * x| > (n : ℝ) ^ (3 / 4 : ℝ)) (Finset.range (n + 1));
        let S_II : ℝ := ∑ v ∈ indices_II, (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v);
        S_I + S_II = 1 ∧ S_II ≤ (∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * ((v - n * x) ^ 2) / ((n : ℝ) ^ (3 / 4 : ℝ)) ^ 2) := by
          constructor;
          · rw [ Finset.sum_filter, Finset.sum_filter ];
            rw [ ← Finset.sum_add_distrib, Finset.sum_congr rfl fun _ _ => by aesop, Finset.sum_congr rfl fun _ _ => by aesop ];
            have := add_pow x ( 1 - x ) n;
            simpa [ mul_assoc, mul_comm, mul_left_comm ] using this.symm;
          · have h_sum_II : ∀ v ∈ Finset.range (n + 1), |(v : ℝ) - n * x| > (n : ℝ) ^ (3 / 4 : ℝ) → (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) ≤ (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * ((v - n * x) ^ 2) / ((n : ℝ) ^ (3 / 4 : ℝ)) ^ 2 := by
              intros v hv hv_abs
              have hv_sq : ((v : ℝ) - n * x) ^ 2 > ((n : ℝ) ^ (3 / 4 : ℝ)) ^ 2 := by
                simpa using pow_lt_pow_left₀ hv_abs ( by positivity ) two_ne_zero;
              rw [ le_div_iff₀ ( by positivity ) ] ; nlinarith [ show 0 ≤ ( Nat.choose n v : ℝ ) * x ^ v * ( 1 - x ) ^ ( n - v ) by exact mul_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( pow_nonneg hx.1 _ ) ) ( pow_nonneg ( sub_nonneg.2 hx.2 ) _ ) ];
            exact le_trans ( Finset.sum_le_sum fun v hv => h_sum_II v ( Finset.mem_filter.mp hv |>.1 ) ( Finset.mem_filter.mp hv |>.2 ) ) ( Finset.sum_le_sum_of_subset_of_nonneg ( Finset.filter_subset _ _ ) fun _ _ _ => div_nonneg ( mul_nonneg ( mul_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( pow_nonneg hx.1 _ ) ) ( pow_nonneg ( sub_nonneg.mpr hx.2 ) _ ) ) ( sq_nonneg _ ) ) ( sq_nonneg _ ) );
      have h_sum : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * ((v - n * x) ^ 2) = n * x * (1 - x) := by
        have h_sum : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * (v : ℝ) = n * x := by
          have h_sum : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * (v : ℝ) = n * x * ∑ v ∈ Finset.range (n), (Nat.choose (n - 1) v : ℝ) * x ^ v * (1 - x) ^ (n - 1 - v) := by
            rw [ Finset.sum_range_succ' ];
            simp +decide [ Finset.mul_sum _ _ _, mul_assoc, mul_comm, mul_left_comm, tsub_tsub, add_comm ];
            refine Finset.sum_congr rfl fun i hi => ?_;
            rw [ Nat.cast_choose, Nat.cast_choose ] <;> try linarith [ Finset.mem_range.mp hi ];
            · rcases n <;> simp_all +decide [ Nat.factorial, Nat.succ_sub ];
              -- Combine and simplify the fractions
              field_simp
              ring;
            · exact Nat.le_pred_of_lt <| Finset.mem_range.mp hi;
          have h_sum : ∑ v ∈ Finset.range n, (Nat.choose (n - 1) v : ℝ) * x ^ v * (1 - x) ^ (n - 1 - v) = (x + (1 - x)) ^ (n - 1) := by
            rw [ add_pow ];
            rw [ Nat.sub_add_cancel hn ] ; ac_rfl;
          aesop;
        have h_sum : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * (v : ℝ) ^ 2 = n * x * (n * x + 1 - x) := by
          have h_sum : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * (v : ℝ) * (v - 1) = n * (n - 1) * x ^ 2 := by
            have h_sum : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * (v : ℝ) * (v - 1) = n * (n - 1) * x ^ 2 * ∑ v ∈ Finset.range (n - 2 + 1), (Nat.choose (n - 2) v : ℝ) * x ^ v * (1 - x) ^ ((n - 2) - v) := by
              have h_sum : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * (v : ℝ) * (v - 1) = ∑ v ∈ Finset.range (n - 2 + 1), (Nat.choose n (v + 2) : ℝ) * x ^ (v + 2) * (1 - x) ^ (n - (v + 2)) * (v + 2) * (v + 1) := by
                rcases n with ( _ | _ | n ) <;> norm_num [ Finset.sum_range_succ' ] at *;
                norm_cast;
              rw [ h_sum, Finset.mul_sum _ _ _ ];
              refine Finset.sum_congr rfl fun i hi => ?_;
              rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.succ_mul_choose_eq ];
              rw [ Nat.cast_choose, Nat.cast_choose ] <;> try linarith;
              field_simp;
              rw [ show n + 1 + 1 - ( i + 2 ) = n - i by omega ] ; push_cast [ Nat.factorial_succ ] ; ring;
            have h_sum : ∑ v ∈ Finset.range (n - 2 + 1), (Nat.choose (n - 2) v : ℝ) * x ^ v * (1 - x) ^ ((n - 2) - v) = (x + (1 - x)) ^ (n - 2) := by
              rw [ add_pow ] ; congr ; ext ; ring;
            aesop;
          simp_all +decide [ mul_assoc, mul_sub, sq, Finset.sum_add_distrib ];
          linarith;
        have h_sum : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * ((v : ℝ) - n * x) ^ 2 = ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * (v : ℝ) ^ 2 - 2 * n * x * ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * (v : ℝ) + n ^ 2 * x ^ 2 * ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) := by
          simp +decide only [mul_assoc, mul_left_comm, pow_two, Finset.mul_sum _ _ _] ; ring;
          simpa only [ ← Finset.sum_sub_distrib, ← Finset.sum_add_distrib ] using Finset.sum_congr rfl fun _ _ => by ring;
        have h_sum : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) = 1 := by
          have := add_pow x ( 1 - x ) n;
          simpa [ mul_assoc, mul_comm, mul_left_comm ] using this.symm;
        grind;
      simp_all +decide [ ← Finset.sum_div ];
  have h_bound : (n * x * (1 - x)) / (n ^ (3 / 4 : ℝ)) ^ 2 ≤ (n * (1 / 4)) / (n ^ (3 / 4 : ℝ)) ^ 2 := by
    exact div_le_div_of_nonneg_right ( by nlinarith only [ sq_nonneg ( x - 1 / 2 ), hx.1, hx.2 ] ) ( sq_nonneg _ );
  -- Simplify the right-hand side of the inequality.
  have h_simplify : (n * (1 / 4)) / (n ^ (3 / 4 : ℝ)) ^ 2 = (1 / 4) * (n : ℝ) ^ (-1 / 2 : ℝ) := by
    rw [ ← Real.rpow_natCast, ← Real.rpow_mul ( by positivity ) ] ; ring;
    rw [ ← Real.rpow_neg ( by positivity ), ← Real.rpow_one_add' ( by positivity ) ] <;> norm_num;
  simp_all +decide [ abs_le ];
  refine lt_of_le_of_ne ( h_sum.2.trans h_bound ) ?_;
  intro H;
  -- Since $x \neq 0$ and $x \neq 1$, we have $0 < x < 1$.
  have hx_pos : 0 < x ∧ x < 1 := by
    -- If $x = 0$ or $x = 1$, then the sum $S_II$ would be zero because all terms would be zero. But $H$ says that $S_II$ is equal to $(1/4) * n^(-1/2)$, which is positive. Therefore, $x$ cannot be $0$ or $1$.
    by_cases hx0 : x = 0 ∨ x = 1;
    · rcases hx0 with ( rfl | rfl ) <;> norm_num at *;
      · exact absurd H ( by exact ne_of_lt ( lt_of_le_of_lt h_sum.2 ( by positivity ) ) );
      · linarith [ show ( 0 : ℝ ) < ( n : ℝ ) ^ ( - ( 1 / 2 ) : ℝ ) by positivity ];
    · exact ⟨ lt_of_le_of_ne hx.1 ( Ne.symm <| by tauto ), lt_of_le_of_ne hx.2 ( by tauto ) ⟩;
  have h_contra : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * (if |(v : ℝ) - n * x| > (n : ℝ) ^ (3 / 4 : ℝ) then 1 else 0) < ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * ((v - n * x) ^ 2 / ((n : ℝ) ^ (3 / 4 : ℝ)) ^ 2) := by
    fapply Finset.sum_lt_sum;
    · intro i hi; split_ifs <;> norm_num;
      · exact le_mul_of_one_le_right ( mul_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( pow_nonneg hx_pos.1.le _ ) ) ( pow_nonneg ( sub_nonneg.2 hx_pos.2.le ) _ ) ) ( by rw [ le_div_iff₀ ( by positivity ) ] ; nlinarith [ abs_mul_abs_self ( ( i : ℝ ) - n * x ), show ( n : ℝ ) ^ ( 3 / 4 : ℝ ) > 0 by positivity ] );
      · exact mul_nonneg ( mul_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( pow_nonneg hx_pos.1.le _ ) ) ( pow_nonneg ( sub_nonneg.2 hx_pos.2.le ) _ ) ) ( div_nonneg ( sq_nonneg _ ) ( sq_nonneg _ ) );
    · refine' ⟨ 0, _, _ ⟩ <;> norm_num [ hn ];
      split_ifs <;> norm_num [ abs_of_pos hx_pos.1 ] at *;
      · exact lt_mul_of_one_lt_right ( pow_pos ( by linarith ) _ ) ( by rw [ one_lt_div ( by positivity ) ] ; nlinarith [ show ( n : ℝ ) ^ ( 3 / 4 : ℝ ) > 0 by positivity ] );
      · exact mul_pos ( pow_pos ( by linarith ) _ ) ( div_pos ( sq_pos_of_pos ( mul_pos ( Nat.cast_pos.mpr hn ) hx_pos.1 ) ) ( sq_pos_of_pos ( Real.rpow_pos_of_pos ( Nat.cast_pos.mpr hn ) _ ) ) );
  -- Evaluate the sum $\sum_{v=0}^{n} \binom{n}{v} x^v (1-x)^{n-v} (v - nx)^2$.
  have h_sum_sq : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * (v - n * x) ^ 2 = n * x * (1 - x) := by
    have h_sum_sq : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * v ^ 2 = n * x * (n * x + 1 - x) := by
      have h_sum_sq : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * v = n * x := by
        have h_sum_sq : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * v = n * x * ∑ v ∈ Finset.range (n), (Nat.choose (n - 1) v : ℝ) * x ^ v * (1 - x) ^ (n - 1 - v) := by
          rw [ Finset.sum_range_succ' ] ; norm_num [ Finset.mul_sum _ _ _, mul_assoc, mul_comm, mul_left_comm, Nat.cast_succ, Nat.choose_succ_succ ];
          refine Finset.sum_congr rfl fun i hi => ?_;
          rw [ Nat.cast_choose, Nat.cast_choose ] <;> try linarith [ Finset.mem_range.mp hi ];
          · rcases n <;> simp_all +decide [ Nat.factorial, Nat.succ_sub ] ; ring;
            -- Combine like terms and simplify the expression.
            field_simp
            ring;
          · exact Nat.le_pred_of_lt ( Finset.mem_range.mp hi );
        have h_sum_sq : ∑ v ∈ Finset.range n, (Nat.choose (n - 1) v : ℝ) * x ^ v * (1 - x) ^ (n - 1 - v) = (x + (1 - x)) ^ (n - 1) := by
          rw [ add_pow ];
          rw [ Nat.sub_add_cancel hn ] ; ac_rfl;
        aesop;
      have h_sum_sq : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * v * (v - 1) = n * (n - 1) * x ^ 2 := by
        have h_sum_sq : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * v * (v - 1) = n * (n - 1) * x ^ 2 * ∑ v ∈ Finset.range (n - 2 + 1), (Nat.choose (n - 2) v : ℝ) * x ^ v * (1 - x) ^ ((n - 2) - v) := by
          have h_sum_sq : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * v * (v - 1) = ∑ v ∈ Finset.range (n - 2 + 1), (Nat.choose n (v + 2) : ℝ) * x ^ (v + 2) * (1 - x) ^ (n - (v + 2)) * (v + 2) * (v + 1) := by
            rcases n with ( _ | _ | n ) <;> norm_num [ Finset.sum_range_succ' ] at *;
            norm_cast;
          rw [ h_sum_sq, Finset.mul_sum _ _ _ ];
          refine Finset.sum_congr rfl fun i hi => ?_;
          rcases n with ( _ | _ | n ) <;> norm_num [ Nat.succ_mul_choose_eq ] at *;
          rw [ Nat.cast_choose, Nat.cast_choose ] <;> try linarith [ Nat.sub_add_cancel ( by linarith : 2 ≤ n + 1 + 1 ) ];
          field_simp;
          rw [ show n + 1 + 1 - 2 = n by omega ] ; norm_num [ Nat.factorial_succ ] ; ring;
          grind;
        have h_sum_sq : ∑ v ∈ Finset.range (n - 2 + 1), (Nat.choose (n - 2) v : ℝ) * x ^ v * (1 - x) ^ ((n - 2) - v) = (x + (1 - x)) ^ (n - 2) := by
          rw [ add_pow ] ; congr ; ext ; ring;
        aesop;
      simp_all +decide [ mul_sub, sub_mul, Finset.sum_add_distrib, Finset.mul_sum _ _ _, Finset.sum_mul _ _ _, sq ];
      simp_all +decide [ mul_assoc, Finset.sum_mul _ _ _ ] ; linarith;
    have h_sum_sq : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * v = n * x := by
      have h_sum_sq : ∑ v ∈ Finset.range (n + 1), (Nat.choose n v : ℝ) * x ^ v * (1 - x) ^ (n - v) * v = n * x * ∑ v ∈ Finset.range (n), (Nat.choose (n - 1) v : ℝ) * x ^ v * (1 - x) ^ (n - 1 - v) := by
        rw [ Finset.sum_range_succ' ];
        norm_num [ Finset.mul_sum _ _ _ ];
        refine Finset.sum_congr rfl fun i hi => ?_;
        rw [ Nat.cast_choose, Nat.cast_choose ] <;> try linarith [ Finset.mem_range.mp hi ];
        · rcases n <;> simp_all +decide [ Nat.factorial, Nat.succ_sub ];
          -- Combine and simplify the fractions
          field_simp
          ring;
        · exact Nat.le_pred_of_lt ( Finset.mem_range.mp hi );
      have h_sum_sq : ∑ v ∈ Finset.range n, (Nat.choose (n - 1) v : ℝ) * x ^ v * (1 - x) ^ (n - 1 - v) = (x + (1 - x)) ^ (n - 1) := by
        rw [ add_pow ];
        rw [ Nat.sub_add_cancel hn ] ; ac_rfl;
      aesop;
    convert congr_arg₂ ( · - · ) ( congr_arg₂ ( · + · ) ‹∑ v ∈ Finset.range ( n + 1 ), ( n.choose v : ℝ ) * x ^ v * ( 1 - x ) ^ ( n - v ) * ( v : ℝ ) ^ 2 = ( n : ℝ ) * x * ( ( n : ℝ ) * x + 1 - x ) › ( show ∑ v ∈ Finset.range ( n + 1 ), ( n.choose v : ℝ ) * x ^ v * ( 1 - x ) ^ ( n - v ) * ( x * n ) ^ 2 = ( x * n ) ^ 2 by
                                                                                                                                                                                                            rw [ ← Finset.sum_mul _ _ _ ] ; rw [ show ( ∑ v ∈ Finset.range ( n + 1 ), ( n.choose v : ℝ ) * x ^ v * ( 1 - x ) ^ ( n - v ) ) = ( x + ( 1 - x ) ) ^ n by rw [ add_pow ] ; congr ; ext ; ring ] ; norm_num; ) ) ( show ∑ v ∈ Finset.range ( n + 1 ), ( n.choose v : ℝ ) * x ^ v * ( 1 - x ) ^ ( n - v ) * ( 2 * v * x * n ) = 2 * x * n * ( n * x ) by
                                                                                                                                                                                                                                                                                                                                                rw [ ← h_sum_sq ] ; rw [ Finset.mul_sum _ _ _ ] ; exact Finset.sum_congr rfl fun _ _ => by ring; ) using 1 <;> ring;
    rw [ ← Finset.sum_sub_distrib, ← Finset.sum_add_distrib ] ; congr ; ext ; ring;
  simp_all +decide [ ← Finset.sum_div _ _ _, mul_div ];
  simp_all +decide [ Finset.sum_ite ];
  linarith