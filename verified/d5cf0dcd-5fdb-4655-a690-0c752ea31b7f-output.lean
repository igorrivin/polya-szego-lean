/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d5cf0dcd-5fdb-4655-a690-0c752ea31b7f
-/

/-
We have formalized and proven Polya-Szego Problem 160, which states that $\int_{0}^{1} x^{-x} d x=\sum_{n=1}^{\infty} n^{-n}$. The proof involves expanding $x^{-x} = e^{-x \ln x}$ as a power series, integrating term by term using the substitution $u = -\ln x$ and the Gamma function integral definition, and justifying the exchange of sum and integral using the Dominated Convergence Theorem (via Fubini/Tonelli on the absolute values).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
∫₀¹ x^(-x) dx = ∑_{n=1}^∞ n^(-n)
-/
theorem problem_160 : ∫ x in (0:ℝ)..1, Real.rpow x (-x) = ∑' n : ℕ, Real.rpow (n + 1 : ℝ) (-(n + 1 : ℝ)) := by
  -- By Fubini's theorem, we can interchange the sum and the integral.
  have h_fubini : ∫ x in (0 : ℝ)..1, ∑' n : ℕ, (-x * Real.log x) ^ n / Nat.factorial n = ∑' n : ℕ, ∫ x in (0 : ℝ)..1, (-x * Real.log x) ^ n / Nat.factorial n := by
    norm_num [ intervalIntegral.integral_of_le zero_le_one ];
    rw [ MeasureTheory.integral_tsum ];
    · exact fun i => ContinuousOn.aestronglyMeasurable ( by exact ContinuousOn.div_const ( ContinuousOn.pow ( ContinuousOn.neg ( Real.continuous_mul_log.continuousOn ) ) _ ) _ ) measurableSet_Ioc;
    · -- We'll use the fact that |(-x log x)^n / n!| ≤ (1/n!) for all x in [0,1].
      have h_bound : ∀ n : ℕ, ∫⁻ x in Set.Ioc (0 : ℝ) 1, ‖(-(x * Real.log x)) ^ n / (Nat.factorial n : ℝ)‖ₑ ∂MeasureTheory.MeasureSpace.volume ≤ ENNReal.ofReal (1 / (Nat.factorial n : ℝ)) := by
        intro n
        have h_abs : ∀ x ∈ Set.Ioc (0 : ℝ) 1, |(-(x * Real.log x)) ^ n / (Nat.factorial n)| ≤ 1 / (Nat.factorial n) := by
          norm_num [ abs_div ];
          exact fun x hx₁ hx₂ => mul_le_of_le_one_left ( by positivity ) ( pow_le_one₀ ( by positivity ) ( by rw [ abs_of_nonneg hx₁.le, abs_of_nonpos ( Real.log_nonpos hx₁.le hx₂ ) ] ; nlinarith [ Real.log_inv x ▸ Real.log_le_sub_one_of_pos ( inv_pos.mpr hx₁ ), mul_inv_cancel₀ hx₁.ne' ] ) );
        refine' le_trans ( MeasureTheory.lintegral_mono_ae _ ) _;
        use fun x => ENNReal.ofReal ( 1 / ( n.factorial : ℝ ) );
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx using by simpa only [ Real.enorm_eq_ofReal_abs ] using ENNReal.ofReal_le_ofReal ( h_abs x hx ) ;
        · norm_num;
      refine' ne_of_lt ( lt_of_le_of_lt ( ENNReal.tsum_le_tsum h_bound ) _ );
      rw [ ← ENNReal.ofReal_tsum_of_nonneg ] <;> norm_num;
      simpa using Real.summable_pow_div_factorial 1;
  have h_ftc : ∀ n : ℕ, ∫ x in (0 : ℝ)..1, x ^ n * (-Real.log x) ^ n = (Nat.factorial n) / ((n + 1 : ℝ) ^ (n + 1)) := by
    -- Let's use the substitution $u = -\ln x$. Then $du = -\frac{1}{x} dx$ or $dx = -e^{-u} du$.
    have h_subst : ∀ n : ℕ, ∫ x in (0 : ℝ)..1, x ^ n * (-Real.log x) ^ n = ∫ u in Set.Ioi 0, u ^ n * Real.exp (-(n + 1) * u) := by
      intro n
      have h_subst : ∫ x in (0 : ℝ)..1, x ^ n * (-Real.log x) ^ n = ∫ u in (Set.image (fun x => -Real.log x) (Set.Ioo (0 : ℝ) 1)), u ^ n * Real.exp (-(n + 1) * u) := by
        rw [ intervalIntegral.integral_of_le zero_le_one, MeasureTheory.integral_Ioc_eq_integral_Ioo ];
        rw [ MeasureTheory.integral_image_eq_integral_abs_deriv_smul ];
        any_goals intro x hx; exact HasDerivAt.hasDerivWithinAt ( by simpa using HasDerivAt.neg ( Real.hasDerivAt_log hx.1.ne' ) );
        · refine' MeasureTheory.setIntegral_congr_fun measurableSet_Ioo fun x hx => _ ; norm_num [ abs_of_pos, hx.1, hx.2 ] ; ring;
          rw [ Real.exp_add, Real.exp_mul, Real.exp_log hx.1 ] ; norm_cast ; ring;
          grind;
        · norm_num;
        · exact fun x hx y hy hxy => Real.log_injOn_pos hx.1 hy.1 <| by linarith;
      rw [ h_subst, show ( fun x => -Real.log x ) '' Set.Ioo 0 1 = Set.Ioi 0 from ?_ ];
      exact Set.ext fun x => ⟨ fun hx => by rcases hx with ⟨ y, hy, rfl ⟩ ; exact neg_pos.mpr ( Real.log_neg hy.1 hy.2 ), fun hx => ⟨ Real.exp ( -x ), ⟨ Real.exp_pos _, by simpa using hx ⟩, by simp +decide ⟩ ⟩;
    intro n; rw [ h_subst n ] ; have := @integral_rpow_mul_exp_neg_mul_rpow 1;
    convert @this n ( n + 1 ) ( by norm_num ) ( by linarith ) ( by linarith ) using 1 <;> norm_num [ Real.rpow_add, Real.rpow_neg, Real.Gamma_nat_eq_factorial ];
    rw [ div_eq_inv_mul, ← Real.rpow_natCast, ← Real.rpow_neg ] <;> norm_num ; ring ; positivity;
  convert h_fubini using 1;
  · norm_num [ Real.rpow_def_of_nonneg ];
    rw [ intervalIntegral.integral_of_le zero_le_one, intervalIntegral.integral_of_le zero_le_one ];
    exact MeasureTheory.setIntegral_congr_fun measurableSet_Ioc fun x hx => by rw [ Real.rpow_def_of_pos hx.1 ] ; rw [ Real.exp_eq_exp_ℝ ] ; rw [ NormedSpace.exp_eq_tsum_div ] ; ring;
  · congr! 1;
    ext n; specialize h_ftc n; norm_cast at *; simp_all +decide [ mul_pow, div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ] ;
    rw [ show ( fun x : ℝ => ( - ( x * Real.log x ) ) ^ n ) = fun x : ℝ => x ^ n * ( -Real.log x ) ^ n by ext; ring ] ; rw [ h_ftc ] ; norm_num [ Real.rpow_add, Real.rpow_neg, Nat.factorial_ne_zero ] ; ring;
    rw [ show ( -1 - n : ℝ ) = - ( n + 1 ) by ring, Real.rpow_neg ( by positivity ) ] ; norm_cast ; norm_num ; ring