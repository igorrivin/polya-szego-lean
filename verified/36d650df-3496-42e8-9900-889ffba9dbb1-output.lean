/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 36d650df-3496-42e8-9900-889ffba9dbb1

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Filter
open Topology

def has_infinite_radius (a : ℕ → ℝ) : Prop :=
  ∀ (x : ℝ), Summable fun m : ℕ => a m * x ^ m

def terms_become_maximum (b : ℕ → ℝ) : Prop :=
  ∀ (m : ℕ), b m > 0 ∧ 
    ∃ (y : ℝ) (h : y > 0), 
      (∀ (k : ℕ), b k * y ^ k ≤ b m * y ^ m) ∧
      (∀ (n : ℕ), n < m → ∃ (y' : ℝ) (h' : y' > 0), 
        (∀ (k : ℕ), b k * (y') ^ k ≤ b n * (y') ^ n) ∧ 
        ¬(∀ (k : ℕ), b k * (y') ^ k ≤ b m * (y') ^ m))

def central_subscript (a b : ℕ → ℝ) (x y : ℝ) (n : ℕ) : Prop :=
  x > 0 ∧ y > 0 ∧ a n * x ^ n > 0 ∧ b n * y ^ n > 0 ∧
  (∀ (k : ℕ), a k * x ^ k / (a n * x ^ n) ≤ b k * y ^ k / (b n * y ^ n)) ∧
  (∀ (k : ℕ), b k * y ^ k / (b n * y ^ n) ≤ 1)

def has_finite_radius (b : ℕ → ℝ) (ρ : ENNReal) : Prop :=
  ρ > 0 ∧ ρ < ⊤ ∧ 
  (∀ (y : ℝ), ENNReal.ofReal (abs y) < ρ → Summable fun m : ℕ => b m * y ^ m) ∧
  (∀ (y : ℝ), ρ < ENNReal.ofReal (abs y) → ¬Summable fun m : ℕ => b m * y ^ m)

def is_max_index (a : ℕ → ℝ) (y : ℝ) (n : ℕ) : Prop :=
  ∀ k, a k * y ^ k ≤ a n * y ^ n

theorem exists_max_index {a : ℕ → ℝ} {y : ℝ} (ha_pos : ∀ n, a n ≥ 0) (hy : 0 < y)
    (h_tendsto : Filter.Tendsto (fun n => a n * y ^ n) Filter.atTop (nhds 0)) :
    ∃ n, is_max_index a y n := by
  have h_max : IsCompact (Set.range (fun n => a n * y ^ n) ∪ {0}) := by
    simpa using h_tendsto.isCompact_insert_range;
  have := h_max.exists_isGreatest;
  simp_all +decide [ IsGreatest, mem_upperBounds ];
  exact this.elim ( fun h => ⟨ 0, fun n => by nlinarith [ h n, h 0, ha_pos n, ha_pos 0, pow_pos hy n, pow_pos hy 0 ] ⟩ ) fun ⟨ n, hn ⟩ => ⟨ n, hn ⟩

theorem max_index_monotone {a : ℕ → ℝ} {y₁ y₂ : ℝ} {n₁ n₂ : ℕ}
    (ha : ∀ n, a n ≥ 0) (hy₁ : 0 < y₁) (hy₂ : y₁ < y₂)
    (h₁ : is_max_index a y₁ n₁) (h₂ : is_max_index a y₂ n₂)
    (ha_nonzero : ∃ k, a k ≠ 0) :
    n₁ ≤ n₂ := by
  -- Assume for contradiction that $n_1 > n_2$.
  by_contra h_contra
  have h_ratio : (a n₁ * y₂^n₁) / (a n₂ * y₂^n₂) > (a n₁ * y₁^n₁) / (a n₂ * y₁^n₂) := by
    have h_ratio : (y₂^n₁ / y₁^n₁) > (y₂^n₂ / y₁^n₂) := by
      rw [ ← div_pow, ← div_pow ] ; exact pow_lt_pow_right₀ ( by rw [ lt_div_iff₀ hy₁ ] ; linarith ) ( by linarith ) ;
    by_cases hn₁ : a n₁ = 0 <;> by_cases hn₂ : a n₂ = 0 <;> simp_all +decide [ mul_div_mul_comm ];
    · have := h₂ ( Classical.choose ha_nonzero ) ; have := h₁ ( Classical.choose ha_nonzero ) ; simp_all +decide [ is_max_index ] ;
      exact ha_nonzero.elim fun k hk => hk <| by nlinarith [ ha k, h₁ k, h₂ k, pow_pos hy₁ k, pow_pos ( lt_trans hy₁ hy₂ ) k ] ;
    · have := h₁ n₂; have := h₂ n₁; simp_all +decide [ is_max_index ] ;
      exact hn₂ ( by nlinarith [ h₁ n₂, h₂ n₂, pow_pos hy₁ n₂, pow_pos ( by linarith : 0 < y₂ ) n₂ ] );
    · have := h₂ n₁; simp_all +decide [ is_max_index ] ;
      exact hn₁ ( by have := h₂ n₁; exact le_antisymm ( le_of_not_gt fun h => by nlinarith [ pow_pos ( by linarith : 0 < y₂ ) n₁ ] ) ( ha n₁ ) );
    · -- Since $a n₁ / a n₂$ is positive, we can divide both sides of the inequality by it.
      have h_div : y₁^n₁ / y₁^n₂ < y₂^n₁ / y₂^n₂ := by
        rw [ div_lt_div_iff₀ ] at * <;> try positivity;
        · linarith;
        · exact pow_pos ( by linarith ) _;
      exact mul_lt_mul_of_pos_left h_div ( div_pos ( lt_of_le_of_ne ( ha _ ) ( Ne.symm hn₁ ) ) ( lt_of_le_of_ne ( ha _ ) ( Ne.symm hn₂ ) ) );
  have := h₂ n₁; have := h₁ n₂; simp_all +decide [ div_le_iff₀, mul_pos, pow_pos ] ;
  rw [ div_lt_div_iff₀ ] at h_ratio <;> nlinarith [ show 0 < a n₂ * y₁ ^ n₂ from mul_pos ( lt_of_le_of_ne ( ha _ ) ( Ne.symm <| by rintro h; norm_num [ h ] at * ) ) ( pow_pos hy₁ _ ), show 0 < a n₂ * y₂ ^ n₂ from mul_pos ( lt_of_le_of_ne ( ha _ ) ( Ne.symm <| by rintro h; norm_num [ h ] at * ) ) ( pow_pos ( by linarith ) _ ) ] ;

def MaxIndices (a : ℕ → ℝ) (y : ℝ) : Set ℕ := { n | is_max_index a y n }

theorem MaxIndices_nonempty {a : ℕ → ℝ} {y : ℝ} (ha_pos : ∀ n, a n ≥ 0) (hy : 0 < y)
    (h_tendsto : Filter.Tendsto (fun n => a n * y ^ n) Filter.atTop (nhds 0)) :
    (MaxIndices a y).Nonempty := by
  exact exists_max_index ha_pos hy h_tendsto

theorem tendsto_zero_of_infinite_radius {a : ℕ → ℝ} (h : has_infinite_radius a) (x : ℝ) :
    Filter.Tendsto (fun n => a n * x ^ n) Filter.atTop (nhds 0) := by
  -- Since the series converges for all x, the terms a_n x^n must tend to zero as n goes to infinity.
  have h_term_zero : Summable (fun n => a n * x ^ n) := by
    -- By definition of has_infinite_radius, for any x, the series ∑ a_n x^n converges.
    apply h;
  -- Apply the fact that if a series is summable, then its terms tend to zero.
  apply h_term_zero.tendsto_atTop_zero

lemma log_concave_of_terms_become_maximum (b : ℕ → ℝ) (hb_pos : ∀ n, b n > 0)
    (h : terms_become_maximum b) :
    ∀ n, b (n + 1) ^ 2 ≥ b n * b (n + 2) := by
  -- By definition of terms_become_maximum, for each n, there exists y > 0 such that b n * y^n is the maximum term in the series.
  have h_max_term : ∀ n, ∃ y > 0, ∀ k, b k * y^k ≤ b n * y^n := by
    intro n; specialize h n; aesop;
  intro n
  obtain ⟨y, hy_pos, hy_max⟩ := h_max_term (n + 1);
  -- By AM-GM inequality, we have $b(n+1)y^{n+1} \geq \sqrt{b(n)y^n \cdot b(n+2)y^{n+2}}$.
  have h_am_gm : b (n + 1) * y ^ (n + 1) ≥ Real.sqrt (b n * y ^ n * b (n + 2) * y ^ (n + 2)) := by
    have h_am_gm : b n * y ^ n * b (n + 2) * y ^ (n + 2) ≤ (b (n + 1) * y ^ (n + 1)) ^ 2 := by
      convert mul_le_mul ( hy_max n ) ( hy_max ( n + 2 ) ) ( by exact mul_nonneg ( le_of_lt ( hb_pos _ ) ) ( pow_nonneg hy_pos.le _ ) ) ( by exact mul_nonneg ( le_of_lt ( hb_pos _ ) ) ( pow_nonneg hy_pos.le _ ) ) using 1 <;> ring;
    exact Real.sqrt_le_iff.mpr ⟨ by exact mul_nonneg ( le_of_lt ( hb_pos _ ) ) ( pow_nonneg hy_pos.le _ ), h_am_gm ⟩;
  contrapose! h_am_gm;
  exact Real.lt_sqrt_of_sq_lt ( by convert mul_lt_mul_of_pos_right h_am_gm ( pow_pos hy_pos ( 2 * n + 2 ) ) using 1 <;> ring )

lemma ratio_decreasing (b : ℕ → ℝ) (hb_pos : ∀ n, b n > 0)
    (h_log_concave : ∀ n, b (n + 1) ^ 2 ≥ b n * b (n + 2)) :
    ∀ n, b (n + 2) / b (n + 1) ≤ b (n + 1) / b n := by
  intro n
  have h := h_log_concave n
  have hb_n_pos : b n > 0 := hb_pos n
  have hb_n1_pos : b (n + 1) > 0 := hb_pos (n + 1)
  rw [div_le_div_iff₀ hb_n1_pos hb_n_pos]
  linarith

lemma radius_eq_inv_limit_ratio (b : ℕ → ℝ) (hb_pos : ∀ n, b n > 0)
    (ρ : ENNReal) (hρ : has_finite_radius b ρ)
    (h_ratio_decreasing : ∀ n, b (n + 2) / b (n + 1) ≤ b (n + 1) / b n) :
    ∃ (l : ℝ), Filter.Tendsto (fun n => b (n + 1) / b n) Filter.atTop (nhds l) ∧
    (l = 0 ↔ ρ = ⊤) ∧ (l > 0 ↔ ρ < ⊤) ∧
    (ρ ≠ ⊤ → ρ = ENNReal.ofReal (1 / l)) := by
  cases eq_or_ne ρ ⊤ <;> simp_all +decide [ has_finite_radius ];
  -- Let $l = \lim_{n \to \infty} \frac{b_{n+1}}{b_n}$.
  obtain ⟨l, hl⟩ : ∃ l, Filter.Tendsto (fun n => b (n + 1) / b n) Filter.atTop (nhds l) ∧ 0 < l := by
    have h_ratio_bounded : ∃ l, Filter.Tendsto (fun n => b (n + 1) / b n) Filter.atTop (nhds l) ∧ 0 ≤ l := by
      have h_ratio_bounded : BddBelow (Set.range (fun n => b (n + 1) / b n)) := by
        exact ⟨ 0, Set.forall_mem_range.mpr fun n => div_nonneg ( le_of_lt ( hb_pos _ ) ) ( le_of_lt ( hb_pos _ ) ) ⟩;
      exact ⟨ _, tendsto_atTop_ciInf ( show Antitone fun n => b ( n + 1 ) / b n from antitone_nat_of_succ_le fun n => h_ratio_decreasing n ) h_ratio_bounded, le_ciInf fun n => div_nonneg ( le_of_lt ( hb_pos _ ) ) ( le_of_lt ( hb_pos _ ) ) ⟩;
    -- If the limit were zero, then the series would converge for all y, contradicting the finite radius of convergence.
    by_contra h_contra
    have h_zero : Filter.Tendsto (fun n => b (n + 1) / b n) Filter.atTop (nhds 0) := by
      exact h_ratio_bounded.choose_spec.1.trans ( by rw [ show h_ratio_bounded.choose = 0 by exact le_antisymm ( le_of_not_gt fun h => h_contra ⟨ _, h_ratio_bounded.choose_spec.1, h ⟩ ) h_ratio_bounded.choose_spec.2 ] );
    -- If the limit is zero, then for any $y$, there exists $N$ such that for all $n \geq N$, $\frac{b_{n+1}}{b_n} |y| < \frac{1}{2}$.
    have h_ratio_lt_half : ∀ y : ℝ, ∃ N, ∀ n ≥ N, b (n + 1) / b n * |y| < 1 / 2 := by
      exact fun y => by rcases Metric.tendsto_atTop.mp ( h_zero.mul_const |y| ) ( 1 / 2 ) ( by norm_num ) with ⟨ N, hN ⟩ ; exact ⟨ N, fun n hn => by linarith [ abs_lt.mp ( hN n hn ) ] ⟩ ;
    -- If the limit is zero, then for any $y$, the series $\sum_{n=0}^{\infty} b_n y^n$ converges.
    have h_series_converges : ∀ y : ℝ, Summable (fun n => b n * y ^ n) := by
      intro y
      obtain ⟨N, hN⟩ : ∃ N, ∀ n ≥ N, b (n + 1) / b n * |y| < 1 / 2 := h_ratio_lt_half y
      have h_series_converges : Summable (fun n => b (n + N) * y ^ (n + N)) := by
        have h_series_converges : ∀ n ≥ N, b (n + 1) * |y| ^ (n + 1) ≤ (1 / 2) * b n * |y| ^ n := by
          intro n hn; have := hN n hn; rw [ div_mul_eq_mul_div, div_lt_iff₀ ( hb_pos _ ) ] at this; ring_nf at *; nlinarith [ pow_nonneg ( abs_nonneg y ) n ] ;
        refine' summable_of_ratio_norm_eventually_le _ _;
        exact 1 / 2;
        · norm_num;
        · simp_all +decide [ abs_of_pos, mul_assoc, mul_comm, mul_left_comm ];
          exact ⟨ 0, fun n hn => by simpa only [ add_right_comm ] using h_series_converges ( n + N ) ( by linarith ) ⟩;
      rw [ ← summable_nat_add_iff N ] ; aesop;
    obtain ⟨y, hy⟩ : ∃ y : ℝ, ρ < ENNReal.ofReal |y| := by
      -- Since ρ is finite, we can choose y to be a real number greater than ρ.
      obtain ⟨y, hy⟩ : ∃ y : ℝ, ρ < ENNReal.ofReal y := by
        rcases ENNReal.lt_iff_exists_real_btwn.mp hρ.2.1 with ⟨ y, hy ⟩ ; use y ; aesop;
      exact ⟨ y, hy.trans_le <| ENNReal.ofReal_le_ofReal <| le_abs_self _ ⟩;
    exact hρ.2.2.2 y hy <| h_series_converges y;
  -- By the ratio test, the series $\sum_{m=0}^\infty b_m y^m$ converges if $|y| < \frac{1}{l}$ and diverges if $|y| > \frac{1}{l}$.
  have h_ratio_test : ∀ y, |y| < 1 / l → Summable (fun m => b m * y ^ m) := by
    -- By the ratio test, if the limit of |b_{n+1}/b_n| is l, then for |y| < 1/l, the series converges.
    intros y hy
    have h_ratio_test : ∃ r < 1, ∃ N, ∀ n ≥ N, |b (n + 1) * y ^ (n + 1)| ≤ r * |b n * y ^ n| := by
      have h_ratio_test : ∃ r < 1, ∃ N, ∀ n ≥ N, |b (n + 1) / b n| * |y| ≤ r := by
        have h_ratio_test : Filter.Tendsto (fun n => |b (n + 1) / b n| * |y|) Filter.atTop (nhds (l * |y|)) := by
          simpa only [ abs_of_nonneg ( le_of_lt ( div_pos ( hb_pos _ ) ( hb_pos _ ) ) ) ] using hl.1.mul_const _;
        exact ⟨ ( l * |y| + 1 ) / 2, by nlinarith [ abs_nonneg y, mul_div_cancel₀ 1 hl.2.ne' ], by simpa using h_ratio_test.eventually ( ge_mem_nhds <| show l * |y| < ( l * |y| + 1 ) / 2 by nlinarith [ abs_nonneg y, mul_div_cancel₀ 1 hl.2.ne' ] ) ⟩;
      simp_all +decide [ abs_div, abs_mul, pow_succ, mul_assoc, div_le_iff₀, ne_of_gt ];
      obtain ⟨ r, hr, N, hN ⟩ := h_ratio_test; exact ⟨ r, hr, N, fun n hn => by have := hN n hn; rw [ div_mul_eq_mul_div, div_le_iff₀ ( abs_pos.mpr ( ne_of_gt ( hb_pos n ) ) ) ] at this; nlinarith [ pow_nonneg ( abs_nonneg y ) n ] ⟩ ;
    obtain ⟨ r, hr, N, hN ⟩ := h_ratio_test;
    refine' summable_of_ratio_norm_eventually_le _ _;
    exacts [ r, hr, Filter.eventually_atTop.mpr ⟨ N, fun n hn => hN n hn ⟩ ];
  -- By the ratio test, the series $\sum_{m=0}^\infty b_m y^m$ diverges if $|y| > \frac{1}{l}$.
  have h_ratio_test_diverge : ∀ y, |y| > 1 / l → ¬Summable (fun m => b m * y ^ m) := by
    intros y hy
    have h_ratio_test_diverge_step : ∃ N, ∀ n ≥ N, |b (n + 1) * y ^ (n + 1)| ≥ |b n * y ^ n| := by
      have h_ratio_test_diverge_step : ∃ N, ∀ n ≥ N, |b (n + 1) / b n| * |y| ≥ 1 := by
        have h_ratio_test_diverge_step : Filter.Tendsto (fun n => |b (n + 1) / b n| * |y|) Filter.atTop (nhds (l * |y|)) := by
          exact Filter.Tendsto.mul ( by simpa only [ abs_of_pos hl.2 ] using hl.1.abs ) tendsto_const_nhds;
        exact Filter.eventually_atTop.mp ( h_ratio_test_diverge_step.eventually ( le_mem_nhds <| by nlinarith [ abs_nonneg y, one_div_mul_cancel hl.2.ne' ] ) );
      simp_all +decide [ abs_div, abs_mul, div_mul_eq_mul_div ];
      obtain ⟨ N, hN ⟩ := h_ratio_test_diverge_step; use N; intros n hn; have := hN n hn; rw [ le_div_iff₀ ( abs_pos.mpr <| ne_of_gt <| hb_pos _ ) ] at this; ring_nf at this ⊢; nlinarith [ pow_nonneg ( abs_nonneg y ) n ] ;
    obtain ⟨ N, hN ⟩ := h_ratio_test_diverge_step;
    -- Since $|b_n y^n|$ is bounded below by a positive constant for $n \geq N$, the series $\sum_{m=0}^\infty b_m y^m$ cannot converge.
    have h_not_summable : ¬ Summable (fun m => |b (N + m) * y ^ (N + m)|) := by
      have h_not_summable : ∀ m, |b (N + m) * y ^ (N + m)| ≥ |b N * y ^ N| := by
        exact fun m => Nat.recOn m ( by norm_num ) fun n ihn => by simpa only [ Nat.add_succ ] using le_trans ihn ( hN _ ( Nat.le_add_right _ _ ) ) ;
      by_cases h : b N * y ^ N = 0 <;> simp_all +decide [ summable_const_iff ];
      · cases h <;> simp_all +decide [ ne_of_gt ];
        linarith [ hl.2 ];
      · exact fun H => absurd ( H.tendsto_atTop_zero ) fun H' => absurd ( le_of_tendsto_of_tendsto' tendsto_const_nhds H' h_not_summable ) ( by norm_num [ h ] ; linarith [ abs_pos.mpr h.1, pow_pos ( abs_pos.mpr ( show y ≠ 0 by rintro rfl; norm_num at hy; linarith [ inv_pos.mpr hl.2 ] ) ) N ] );
    exact fun h => h_not_summable <| h.abs.comp_injective <| add_right_injective N;
  -- By combining the results from the ratio test and the hypothesis hρ, we can conclude that ρ must be equal to 1/l.
  have hρ_eq : ρ = ENNReal.ofReal (1 / l) := by
    have h_le : ρ ≤ ENNReal.ofReal (1 / l) := by
      contrapose! h_ratio_test_diverge;
      -- Choose $y$ such that $1/l < |y| < \rho$.
      obtain ⟨y, hy₁, hy₂⟩ : ∃ y : ℝ, 1 / l < |y| ∧ |y| < ρ.toReal := by
        -- Since $1/l < \rho.toReal$, we can choose $y$ such that $1/l < |y| < \rho.toReal$.
        obtain ⟨ε, hε_pos, hε⟩ : ∃ ε > 0, 1 / l + ε < ρ.toReal := by
          have hε : 1 / l < ρ.toReal := by
            rw [ ← ENNReal.toReal_ofReal ( one_div_nonneg.mpr hl.2.le ) ] ; exact ENNReal.toReal_strict_mono ( by aesop ) h_ratio_test_diverge;
          exact ⟨ ( ρ.toReal - 1 / l ) / 2, half_pos ( sub_pos.mpr hε ), by linarith ⟩;
        exact ⟨ 1 / l + ε / 2, by rw [ abs_of_nonneg ] <;> linarith [ one_div_nonneg.2 hl.2.le ], by rw [ abs_of_nonneg ] <;> linarith [ one_div_nonneg.2 hl.2.le ] ⟩;
      refine' ⟨ y, hy₁, hρ.2.2.1 y _ ⟩;
      rw [ ENNReal.ofReal_lt_iff_lt_toReal ] <;> aesop
    have h_ge : ENNReal.ofReal (1 / l) ≤ ρ := by
      contrapose! hρ;
      intro hρ_pos hρ_lt_top hρ_summable
      obtain ⟨y, hy⟩ : ∃ y : ℝ, ρ < ENNReal.ofReal |y| ∧ |y| < 1 / l := by
        -- Since ρ is less than ENNReal.ofReal (1 / l), there must be some real number y such that ρ < ENNReal.ofReal |y| and |y| < 1 / l.
        obtain ⟨y, hy⟩ : ∃ y : ℝ, ρ < ENNReal.ofReal |y| ∧ |y| < 1 / l := by
          have h_exists_y : ∃ y : ℝ, ρ < ENNReal.ofReal |y| ∧ |y| < 1 / l := by
            have h_lt : ρ < ENNReal.ofReal (1 / l) := hρ
            obtain ⟨ y, hy ⟩ := ENNReal.lt_iff_exists_real_btwn.mp h_lt;
            exact ⟨ y, by simpa only [ abs_of_nonneg hy.1 ] using hy.2.1, by simpa only [ abs_of_nonneg hy.1 ] using ENNReal.ofReal_lt_ofReal_iff ( by linarith [ one_div_pos.mpr hl.2 ] ) |>.1 hy.2.2 ⟩
          exact h_exists_y;
        use y;
      exact ⟨ y, hy.1, h_ratio_test y hy.2 ⟩
    exact le_antisymm h_le h_ge;
  aesop

lemma b_lower_bound (b : ℕ → ℝ) (hb_pos : ∀ n, b n > 0)
    (ρ : ENNReal) (hρ : has_finite_radius b ρ)
    (h_ratio_decreasing : ∀ n, b (n + 2) / b (n + 1) ≤ b (n + 1) / b n) :
    ∃ (r : ℝ), r > 0 ∧ ρ = ENNReal.ofReal r ∧ ∀ n, b n ≥ b 0 * (1 / r) ^ n := by
      obtain ⟨l, hl_tendsto, hl_eq, hl_pos⟩ : ∃ l : ℝ, Filter.Tendsto (fun n => b (n + 1) / b n) Filter.atTop (nhds l) ∧ 0 < l ∧ ρ = ENNReal.ofReal (1 / l) := by
        have := radius_eq_inv_limit_ratio b hb_pos ρ hρ h_ratio_decreasing;
        cases hρ ; aesop;
      -- Since $b_n$ is non-increasing and positive, we have $b_n \geq b_0 \cdot (l)^n$.
      have h_bound : ∀ n, b n ≥ b 0 * l ^ n := by
        -- Since $b_n$ is non-increasing and positive, we have $b_{n+1} / b_n \geq l$ for all $n$.
        have h_ratio_ge_l : ∀ n, b (n + 1) / b n ≥ l := by
          exact fun n => le_of_tendsto hl_tendsto ( Filter.eventually_atTop.mpr ⟨ n, fun m hm => by induction hm <;> [ tauto; linarith [ h_ratio_decreasing ‹_› ] ] ⟩ );
        intro n; induction' n with n ih <;> norm_num [ pow_succ, mul_assoc ] at * ; nlinarith [ hb_pos n, hb_pos ( n + 1 ), h_ratio_ge_l n, mul_div_cancel₀ ( b ( n + 1 ) ) ( ne_of_gt ( hb_pos n ) ) ] ;
      exact ⟨ 1 / l, one_div_pos.mpr hl_eq, by aesop, fun n => by simpa using h_bound n ⟩

theorem c_infinite_radius (a b : ℕ → ℝ) (ha_pos : ∀ m, a m ≥ 0) (hb_pos : ∀ m, b m > 0)
    (ha_infinite : has_infinite_radius a) (hb_finite : ∃ ρ, has_finite_radius b ρ)
    (h_ratio_decreasing : ∀ n, b (n + 2) / b (n + 1) ≤ b (n + 1) / b n) :
    has_infinite_radius (fun k => a k / b k) := by
      -- Since $b$ has a finite radius, there exists some $r > 0$ such that for all $n$, $b n \geq b 0 \cdot (1/r)^n$.
      obtain ⟨r, hr_pos, hr⟩ : ∃ r > 0, ∀ n, b n ≥ b 0 * (1 / r) ^ n := by
        -- Apply the lemma `b_lower_bound` to obtain the existence of such an r.
        obtain ⟨r, hr_pos, hr⟩ := b_lower_bound b hb_pos (hb_finite.choose) hb_finite.choose_spec h_ratio_decreasing;
        use r;
        aesop;
      -- Since $a$ has infinite radius, for any $x$, the series $\sum a_k x^k$ converges. Now, if we take $x$ to be any real number, then $|a_k x^k / b_k| \leq |a_k x^k| / (b 0 * (1/r)^k)$.
      have h_bound : ∀ x : ℝ, ∀ k, |a k * x ^ k / b k| ≤ |a k * (x * r) ^ k| / b 0 := by
        intros x k
        have h_abs : |a k * x ^ k / b k| ≤ |a k * x ^ k| / (b 0 * (1 / r) ^ k) := by
          rw [ abs_div, abs_of_nonneg ( le_of_lt ( hb_pos k ) ) ] ; gcongr ; aesop;
          exact hr k;
        convert h_abs using 1 ; norm_num [ abs_mul, abs_div, abs_of_pos hr_pos ] ; ring;
        norm_num ; ring;
      intro x
      have h_summable : Summable (fun k => |a k * (x * r) ^ k| / b 0) := by
        exact Summable.mul_right _ <| by simpa [ abs_mul, abs_of_nonneg ( ha_pos _ ) ] using ha_infinite ( x * r ) |> Summable.abs;
      generalize_proofs at *;
      -- Since the absolute value of the terms of the series (a_k / b_k) * x^k is bounded by a convergent series, the original series must also converge absolutely.
      have h_abs_summable : Summable (fun k => |(a k / b k) * x ^ k|) := by
        exact Summable.of_nonneg_of_le ( fun k => abs_nonneg _ ) ( fun k => by simpa only [ div_mul_eq_mul_div ] using h_bound x k ) h_summable;
      exact h_abs_summable.of_abs

theorem MaxIndices_is_interval {b : ℕ → ℝ} (hb_pos : ∀ n, b n > 0)
    (h_log_concave : ∀ n, b (n + 1) ^ 2 ≥ b n * b (n + 2)) (y : ℝ) (hy : y > 0) :
    ∀ n m k, n ∈ MaxIndices b y → m ∈ MaxIndices b y → n ≤ k → k ≤ m → k ∈ MaxIndices b y := by
  intro n m k hn hm hnk hkm
  -- b_k y^k ≥ b_n y^n ? No, we know b_n y^n is max.
  -- We need to show b_k y^k is also max.
  -- i.e. b_k y^k = b_n y^n.
  -- Since b is log-concave, the sequence b_i y^i is log-concave.
  -- A log-concave sequence is unimodal.
  -- So the set of maxima is an interval.
  -- By the properties of the log-concave sequence, the function $k \mapsto b(k) * y^k$ is maximized at a unique point.
  have h_unique_max : ∀ k l, n ≤ k → k ≤ l → l ≤ m → b k * y ^ k ≥ b l * y ^ l := by
    intros k l hnk hkl hlm;
    -- By the properties of the log-concave sequence, the sequence $b(k) * y^k$ is non-increasing for $k \geq n$.
    have h_noninc : ∀ k ≥ n, b k * y ^ k ≥ b (k + 1) * y ^ (k + 1) := by
      -- By the properties of the log-concave sequence, if $b k * y^k \geq b (k + 1) * y^(k + 1)$, then $b (k + 1) * y^(k + 1) \geq b (k + 2) * y^(k + 2)$.
      have h_inductive_step : ∀ k ≥ n, b k * y ^ k ≥ b (k + 1) * y ^ (k + 1) → b (k + 1) * y ^ (k + 1) ≥ b (k + 2) * y ^ (k + 2) := by
        intros k hk h_inductive_step
        have h_log_concave_step : b (k + 1) ^ 2 ≥ b k * b (k + 2) := h_log_concave k
        have h_div : b (k + 1) * y ^ (k + 1) ≥ b (k + 2) * y ^ (k + 2) := by
          norm_num [ pow_succ' ] at *;
          nlinarith [ hb_pos k, hb_pos ( k + 1 ), hb_pos ( k + 2 ), pow_pos hy k, pow_pos hy ( k + 1 ), pow_pos hy ( k + 2 ), mul_le_mul_of_nonneg_left h_inductive_step ( le_of_lt hy ), mul_le_mul_of_nonneg_left h_log_concave_step ( le_of_lt hy ), mul_le_mul_of_nonneg_left h_inductive_step ( le_of_lt ( hb_pos k ) ), mul_le_mul_of_nonneg_left h_log_concave_step ( le_of_lt ( hb_pos k ) ), mul_le_mul_of_nonneg_left h_inductive_step ( le_of_lt ( hb_pos ( k + 1 ) ) ), mul_le_mul_of_nonneg_left h_log_concave_step ( le_of_lt ( hb_pos ( k + 1 ) ) ) ]
        exact h_div;
      intro k hk; induction hk <;> aesop;
    -- By induction on $l - k$, we can show that $b k * y^k \geq b l * y^l$.
    induction' hkl with l hl ih;
    · norm_num;
    · exact le_trans ( h_noninc _ ( Nat.le_trans hnk hl ) ) ( ih ( Nat.le_of_succ_le hlm ) );
  intro l; by_cases hlk : l ≤ m <;> simp_all +decide [ MaxIndices ] ;
  · have h_max_k : b k * y ^ k ≥ b m * y ^ m := by
      exact h_unique_max _ _ hnk hkm le_rfl;
    have h_max_m : b m * y ^ m ≥ b l * y ^ l := by
      exact hm l;
    linarith;
  · exact le_trans ( hm l ) ( h_unique_max _ _ hnk hkm le_rfl )

theorem c_tendsto_zero (a b : ℕ → ℝ) (ha_pos : ∀ m, a m ≥ 0) (hb_pos : ∀ m, b m > 0)
    (ha_infinite : has_infinite_radius a) (hb_finite : ∃ ρ, has_finite_radius b ρ)
    (h_ratio_decreasing : ∀ n, b (n + 2) / b (n + 1) ≤ b (n + 1) / b n)
    (z : ℝ) (hz : z > 0) :
    Filter.Tendsto (fun k => (a k / b k) * z ^ k) Filter.atTop (nhds 0) := by
  have h_inf := c_infinite_radius a b ha_pos hb_pos ha_infinite hb_finite h_ratio_decreasing
  exact tendsto_zero_of_infinite_radius h_inf z

def is_left_of (A B : Set ℝ) : Prop := ∀ a ∈ A, ∀ b ∈ B, a < b

def transition_point (b : ℕ → ℝ) (n : ℕ) : ℝ := b n / b (n + 1)

lemma transition_point_nondecreasing (b : ℕ → ℝ) (hb_pos : ∀ n, b n > 0)
    (h_log_concave : ∀ n, b (n + 1) ^ 2 ≥ b n * b (n + 2)) :
    Monotone (transition_point b) := by
  intro n m hnm
  induction' hnm with m hnm ih
  · exact le_rfl
  · apply le_trans ih
    unfold transition_point
    -- b m / b (m+1) ≤ b (m+1) / b (m+2)
    -- b m * b (m+2) ≤ b (m+1)^2
    rw [div_le_div_iff₀ (hb_pos (m + 1)) (hb_pos (m + 2))]
    have := h_log_concave m
    linarith

#check transition_point

def is_left_of_nat (A B : Set ℕ) : Prop := ∀ a ∈ A, ∀ b ∈ B, a < b

def is_right_of_nat (A B : Set ℕ) : Prop := ∀ a ∈ A, ∀ b ∈ B, b < a

theorem MaxIndices_finite {b : ℕ → ℝ} {y : ℝ} (hb_pos : ∀ n, b n > 0) (hy : y > 0)
    (h_tendsto : Filter.Tendsto (fun n => b n * y ^ n) Filter.atTop (nhds 0)) :
    (MaxIndices b y).Finite := by
      -- Since $b_n y^n \to 0$, there exists some $N$ such that for all $n \geq N$, $b_n y^n < b_0 y^0$.
      obtain ⟨N, hN⟩ : ∃ N, ∀ n ≥ N, b n * y ^ n < b 0 * y ^ 0 := by
        simpa using h_tendsto.eventually ( gt_mem_nhds <| mul_pos ( hb_pos 0 ) <| pow_pos hy 0 );
      refine Set.finite_iff_bddAbove.mpr ⟨ N, fun n hn => le_of_not_gt fun hnn => not_le_of_gt ( hN n hnn.le ) ( hn 0 ) ⟩

lemma transition_point_is_max (b : ℕ → ℝ) (hb_pos : ∀ n, b n > 0)
    (h_log_concave : ∀ n, b (n + 1) ^ 2 ≥ b n * b (n + 2))
    (n : ℕ) :
    let y := transition_point b n
    n ∈ MaxIndices b y ∧ (n + 1) ∈ MaxIndices b y := by
  -- By definition of $transition\_point$, we know that $b n * y^n = b (n + 1) * y^(n + 1)$.
  have h_eq : b n * (transition_point b n) ^ n = b (n + 1) * (transition_point b n) ^ (n + 1) := by
    unfold transition_point;
    grind;
  -- For any $k \leq n$, we have $b k * t^k \leq b n * t^n$.
  have h_le_n : ∀ k ≤ n, b k * (transition_point b n) ^ k ≤ b n * (transition_point b n) ^ n := by
    intro k hk_le_n
    have h_log_concave_k : ∀ i < n, b (i + 1) / b i ≥ b (n + 1) / b n := by
      intro i hi_lt_n
      have h_log_concave_i : ∀ j, i < j → j ≤ n → b (j + 1) / b j ≤ b (i + 1) / b i := by
        intro j hj_lt_n hj_le_n
        induction' hj_lt_n with j hj ih;
        · rw [ div_le_div_iff₀ ] <;> nlinarith [ hb_pos i, hb_pos ( i + 1 ), hb_pos ( i + 2 ), h_log_concave i ];
        · exact le_trans ( by rw [ div_le_div_iff₀ ] <;> nlinarith [ hb_pos j, hb_pos ( j + 1 ), hb_pos ( j + 2 ), h_log_concave j ] ) ( ih ( Nat.le_of_succ_le hj_le_n ) );
      exact h_log_concave_i n hi_lt_n le_rfl;
    -- By repeatedly applying the log-concavity condition, we can show that $b k * y^k \leq b n * y^n$ for $k \leq n$.
    have h_log_concave_chain : ∀ i < n, b i * (transition_point b n) ^ i ≤ b (i + 1) * (transition_point b n) ^ (i + 1) := by
      -- By dividing both sides of the inequality by $b_i * transition\_point b n^i$, we get $1 \leq (b_{i+1} / b_i) * transition\_point b n$.
      intro i hi
      have h_div : 1 ≤ (b (i + 1) / b i) * transition_point b n := by
        have h_div : 1 ≤ (b (n + 1) / b n) * (b n / b (n + 1)) := by
          rw [ div_mul_div_cancel₀ ( ne_of_gt ( hb_pos _ ) ), div_self ( ne_of_gt ( hb_pos _ ) ) ];
        exact le_trans h_div ( mul_le_mul ( h_log_concave_k i hi ) le_rfl ( by exact div_nonneg ( le_of_lt ( hb_pos _ ) ) ( le_of_lt ( hb_pos _ ) ) ) ( by exact div_nonneg ( le_of_lt ( hb_pos _ ) ) ( le_of_lt ( hb_pos _ ) ) ) );
      rw [ div_mul_eq_mul_div, le_div_iff₀ ] at h_div <;> ring_nf at * <;> nlinarith [ hb_pos i, hb_pos ( i + 1 ), pow_pos ( show 0 < transition_point b n from div_pos ( hb_pos _ ) ( hb_pos _ ) ) i ];
    have h_log_concave_chain : ∀ i j, i ≤ j → j ≤ n → b i * (transition_point b n) ^ i ≤ b j * (transition_point b n) ^ j := by
      intros i j hij hjn
      induction' hij with j hj ih;
      · norm_num;
      · exact le_trans ( ih ( Nat.le_of_succ_le hjn ) ) ( h_log_concave_chain _ ( Nat.lt_of_succ_le hjn ) );
    exact h_log_concave_chain _ _ hk_le_n le_rfl;
  -- For any $k \geq n + 1$, we have $b k * t^k \leq b (n + 1) * t^(n + 1)$.
  have h_le_n1 : ∀ k ≥ n + 1, b k * (transition_point b n) ^ k ≤ b (n + 1) * (transition_point b n) ^ (n + 1) := by
    intro k hk
    induction' hk with k hk ih;
    · norm_num;
    · -- By definition of $transition\_point$, we know that $b (k + 1) * t \leq b k$.
      have h_trans : b (k + 1) * (transition_point b n) ≤ b k := by
        -- Since $k \geq n + 1$, we have $transition\_point b n \leq transition\_point b k$ by the monotonicity of the transition points.
        have h_trans_le : transition_point b n ≤ transition_point b k := by
          apply_rules [ transition_point_nondecreasing ];
          exact Nat.le_of_succ_le hk;
        exact le_trans ( mul_le_mul_of_nonneg_left h_trans_le <| le_of_lt <| hb_pos _ ) <| by unfold transition_point; nlinarith [ hb_pos k, hb_pos ( k + 1 ), mul_div_cancel₀ ( b k ) ( ne_of_gt <| hb_pos ( k + 1 ) ) ] ;
      rw [ pow_succ' ];
      nlinarith [ hb_pos k, hb_pos ( k + 1 ), pow_pos ( show 0 < transition_point b n from div_pos ( hb_pos _ ) ( hb_pos _ ) ) k ];
  constructor <;> intro k <;> cases le_or_gt k n <;> aesop

lemma local_increasing_below (b : ℕ → ℝ) (hb_pos : ∀ n, b n > 0)
    (h_log_concave : ∀ n, b (n + 1) ^ 2 ≥ b n * b (n + 2))
    (n : ℕ) (y : ℝ) (hy_eq : y = b n / b (n + 1)) :
    ∀ k < n, b k * y ^ k ≤ b (k + 1) * y ^ (k + 1) := by
      -- By definition of $y$, we know that $y = \frac{b_n}{b_{n+1}}$. Therefore, for any $k < n$, we have $b_k * y^k \leq b_{k+1} * y^{k+1}$.
      intros k hk
      have h_ratio : b k / b (k + 1) ≤ y := by
        -- Since $k < n$, we have $b k / b (k + 1) \leq b n / b (n + 1)$ by the monotonicity of the transition points.
        have h_monotone : ∀ m n, m ≤ n → b m / b (m + 1) ≤ b n / b (n + 1) := by
          have h_monotone : ∀ m, b m / b (m + 1) ≤ b (m + 1) / b (m + 2) := by
            exact fun m => by rw [ div_le_div_iff₀ ] <;> nlinarith [ hb_pos m, hb_pos ( m + 1 ), hb_pos ( m + 2 ), h_log_concave m ] ;
          exact fun m n mn => by induction mn <;> [ tauto; linarith [ h_monotone ‹_› ] ] ;
        exact hy_eq ▸ h_monotone _ _ hk.le;
      rw [ div_le_iff₀ ( hb_pos _ ) ] at h_ratio ; ring_nf at * ; nlinarith [ pow_pos ( show 0 < y by rw [ hy_eq ] ; exact div_pos ( hb_pos _ ) ( hb_pos _ ) ) k ] ;

lemma local_decreasing_above (b : ℕ → ℝ) (hb_pos : ∀ n, b n > 0)
    (h_log_concave : ∀ n, b (n + 1) ^ 2 ≥ b n * b (n + 2))
    (n : ℕ) (y : ℝ) (hy_eq : y = b n / b (n + 1)) :
    ∀ k ≥ n, b (k + 1) * y ^ (k + 1) ≤ b k * y ^ k := by
      -- By the properties of the transition point and the log-concavity condition, we can show that for any $k \geq n$, $b (k + 1) * y \leq b k$.
      have h_ineq : ∀ k ≥ n, b (k + 1) * y ≤ b k := by
        intro k hk;
        -- By induction on $k$, we can show that $b(k+1) * y \leq b(k)$ for all $k \geq n$.
        induction' hk with k hk ih;
        · rw [ hy_eq, mul_div_cancel₀ _ ( ne_of_gt ( hb_pos _ ) ) ];
        · nlinarith [ hb_pos k, hb_pos ( k + 1 ), hb_pos ( k + 2 ), h_log_concave k, mul_div_cancel₀ ( b n ) ( ne_of_gt ( hb_pos ( n + 1 ) ) ) ];
      exact fun k hk => by convert mul_le_mul_of_nonneg_right ( h_ineq k hk ) ( pow_nonneg ( show 0 ≤ y by rw [ hy_eq ] ; exact div_nonneg ( le_of_lt ( hb_pos _ ) ) ( le_of_lt ( hb_pos _ ) ) ) k ) using 1 ; ring;

lemma MaxIndices_covers (b : ℕ → ℝ) (hb_max : terms_become_maximum b) :
  ∀ n, ∃ y > 0, n ∈ MaxIndices b y := by
  intro n
  obtain ⟨_, y, hy_pos, hy_max, _⟩ := hb_max n
  use y, hy_pos
  exact hy_max