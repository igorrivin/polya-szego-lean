/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5a32732c-b976-4c97-a69b-87ae33845bcf

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Set
open Filter
open Finset
open BigOperators

open scoped Topology

/-
Definition of an equidistributed sequence on [0,1].
-/
def equidistributed (x : â„• â†’ â„) : Prop :=
  âˆ€ (Î± Î² : â„) (hÎ± : 0 â‰¤ Î±) (hÎ² : Î² â‰¤ 1) (h : Î± â‰¤ Î²),
    Tendsto (Î» n : â„• â†¦ ((Finset.range n).filter (Î» v â†¦ Î± â‰¤ x v âˆ§ x v â‰¤ Î²)).card / (n : â„))
      atTop (ğ“ (Î² - Î±))

/-
If a sequence is equidistributed, then the average of any continuous function converges to its integral.
-/
theorem equidistributed_implies_continuous (x : â„• â†’ â„) (hx : âˆ€ n, 0 â‰¤ x n âˆ§ x n â‰¤ 1) (h : equidistributed x) :
    âˆ€ f : â„ â†’ â„, ContinuousOn f (Set.Icc 0 1) â†’
      Tendsto (Î» n : â„• â†¦ ((Finset.range n).sum (Î» i â†¦ f (x i))) / (n : â„))
        atTop (ğ“ (âˆ« t in (0)..1, f t)) := by
  -- Fix a continuous function $f$ on $[0, 1]$.
  intro f hf;
  -- Since $f$ is continuous on $[0,1]$, it can be uniformly approximated by polynomials.
  have h_poly : âˆ€ Îµ > 0, âˆƒ p : Polynomial â„, âˆ€ t âˆˆ Set.Icc 0 1, abs (f t - p.eval t) < Îµ := by
    have h_weierstrass : âˆ€ Îµ > 0, âˆƒ p : Polynomial â„, âˆ€ t âˆˆ Set.Icc 0 1, abs (p.eval t - f t) < Îµ := by
      apply_rules [ exists_polynomial_near_of_continuousOn ];
    simpa only [ abs_sub_comm ] using h_weierstrass;
  -- By the equidistribution theorem, the average of $p(x_i)$ converges to the integral of $p$ over $[0,1]$.
  have h_poly_avg : âˆ€ p : Polynomial â„, Filter.Tendsto (fun n => (âˆ‘ i âˆˆ Finset.range n, p.eval (x i)) / (n : â„)) Filter.atTop (ğ“ (âˆ« t in (0 : â„)..1, p.eval t)) := by
    -- By the properties of the equidistribution theorem, the average of $x_i^k$ converges to the integral of $x^k$ over $[0,1]$.
    have h_moments : âˆ€ k : â„•, Filter.Tendsto (fun n => (âˆ‘ i âˆˆ Finset.range n, (x i) ^ k) / (n : â„)) Filter.atTop (ğ“ (âˆ« t in (0 : â„)..1, t ^ k)) := by
      intro k;
      induction' k with k ih;
      Â· exact tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_ne_atTop 0 ] with n hn; simp +decide [ hn ] );
      Â· -- By the properties of the equidistribution theorem, the average of $x_i^k$ converges to the integral of $x^k$ over $[0,1]$. We can use the fact that the integral of $x^k$ over $[0,1]$ is $\frac{1}{k+1}$.
        have h_integral : âˆ€ Î± Î² : â„, 0 â‰¤ Î± â†’ Î± â‰¤ Î² â†’ Î² â‰¤ 1 â†’ Filter.Tendsto (fun n => (âˆ‘ i âˆˆ Finset.range n, (if x i âˆˆ Set.Icc Î± Î² then 1 else 0)) / (n : â„)) Filter.atTop (ğ“ (Î² - Î±)) := by
          aesop;
        -- By the properties of the equidistribution theorem, the average of $x_i^k$ converges to the integral of $x^k$ over $[0,1]$. We can use the fact that the integral of $x^k$ over $[0,1]$ is $\frac{1}{k+1}$ and the linearity of the integral.
        have h_integral : Filter.Tendsto (fun n => (âˆ‘ i âˆˆ Finset.range n, (âˆ« t in (0 : â„)..x i, t ^ k)) / (n : â„)) Filter.atTop (ğ“ (âˆ« t in (0 : â„)..1, âˆ« u in (0 : â„)..t, u ^ k)) := by
          have h_integral : âˆ€ n, (âˆ‘ i âˆˆ Finset.range n, (âˆ« t in (0 : â„)..x i, t ^ k)) = âˆ« t in (0 : â„)..1, (âˆ‘ i âˆˆ Finset.range n, (if x i â‰¥ t then 1 else 0)) * t ^ k := by
            intro n
            have h_integral : âˆ‘ i âˆˆ Finset.range n, (âˆ« t in (0 : â„)..x i, t ^ k) = âˆ« t in (0 : â„)..1, (âˆ‘ i âˆˆ Finset.range n, (if x i â‰¥ t then t ^ k else 0)) := by
              rw [ intervalIntegral.integral_finset_sum ];
              Â· refine' Finset.sum_congr rfl fun i _ => _;
                rw [ intervalIntegral.integral_of_le ( hx i |>.1 ), intervalIntegral.integral_of_le zero_le_one ];
                rw [ â† MeasureTheory.integral_indicator, â† MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
                grind;
              Â· intro i hi; apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ];
                exact MeasureTheory.Integrable.indicator ( continuous_pow k |> Continuous.integrableOn_Icc ) ( measurableSet_Iic );
            simpa only [ Finset.sum_mul _ _ _ ] using h_integral.trans ( by congr; ext; congr; ext; split_ifs <;> ring );
          have h_integral : Filter.Tendsto (fun n => (âˆ« t in (0 : â„)..1, (âˆ‘ i âˆˆ Finset.range n, (if x i â‰¥ t then 1 else 0)) * t ^ k) / (n : â„)) Filter.atTop (ğ“ (âˆ« t in (0 : â„)..1, (âˆ« u in (0 : â„)..t, u ^ k))) := by
            have h_integral : âˆ€ t âˆˆ Set.Icc (0 : â„) 1, Filter.Tendsto (fun n => (âˆ‘ i âˆˆ Finset.range n, (if x i â‰¥ t then 1 else 0)) / (n : â„)) Filter.atTop (ğ“ (1 - t)) := by
              grind
            have h_integral : Filter.Tendsto (fun n => âˆ« t in (0 : â„)..1, (âˆ‘ i âˆˆ Finset.range n, (if x i â‰¥ t then 1 else 0)) * t ^ k / (n : â„)) Filter.atTop (ğ“ (âˆ« t in (0 : â„)..1, (1 - t) * t ^ k)) := by
              refine' intervalIntegral.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _;
              use fun t => t ^ k;
              Â· simp +zetaDelta at *;
                use 1;
                intro n hn;
                refine' Measurable.aestronglyMeasurable _;
                refine' Measurable.mul _ _;
                Â· refine' Measurable.mul _ _;
                  Â· refine' measurable_of_tendsto_metrizable _ _;
                    use fun i t => ( âˆ‘ j âˆˆ Finset.range n, if t â‰¤ x j then 1 else 0 ) / ( i : â„ ) * i;
                    Â· exact fun i => Measurable.mul ( Measurable.div_const ( Finset.measurable_sum _ fun j _ => measurable_const.indicator ( measurableSet_Iic ) ) _ ) measurable_const;
                    Â· exact tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_ne_atTop 0 ] with i hi; aesop );
                  Â· exact measurable_id.pow_const _;
                Â· exact measurable_const;
              Â· norm_num +zetaDelta at *;
                use 1;
                intro n hn; filter_upwards [ ] with t htâ‚ htâ‚‚; rw [ abs_of_nonneg htâ‚.le ] ; rw [ div_le_iffâ‚€ ( by positivity ) ] ;
                rw [ mul_comm ] ; gcongr ; exact le_trans ( Finset.card_filter_le _ _ ) ( by norm_num );
              Â· norm_num;
              Â· filter_upwards [ ] with t ht using by simpa [ mul_div_right_comm ] using h_integral t ( by constructor <;> cases Set.mem_uIoc.mp ht <;> linarith ) |> Filter.Tendsto.mul_const _;
            convert h_integral using 2 <;> norm_num [ sub_mul ];
            norm_num [ â† pow_succ' ];
            rw [ inv_eq_one_div, inv_eq_one_div, div_div, div_sub_div, div_eq_div_iff ] <;> ring <;> positivity;
          aesop;
        convert h_integral.mul_const ( k + 1 : â„ ) using 2 <;> norm_num [ integral_pow ] ; ring;
        Â· norm_num [ â† Finset.sum_mul _ _ _ ] ; ring;
          -- Combine like terms and simplify the expression.
          field_simp
          ring;
        Â· rw [ div_mul_cancelâ‚€ _ ( by positivity ) ];
    simp_all +decide [ Polynomial.eval_eq_sum_range ];
    intro p; simp +decide [ Finset.sum_div _ _ _, Finset.mul_sum _ _ _, mul_div_assoc ] ;
    simp_all +decide [ â† Finset.mul_sum _ _ _, â† Finset.sum_div, â† Finset.sum_mul, div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Finset.sum_mul ];
    simp_all +decide [ â† Finset.mul_sum _ _ _, â† Finset.sum_mul, â† Finset.sum_comm, intervalIntegral.integral_finset_sum ];
    exact tendsto_finset_sum _ fun i hi => by simpa [ mul_assoc, mul_comm, mul_left_comm ] using h_moments i |> Filter.Tendsto.mul_const ( p.coeff i ) ;
  -- By the properties of the integral, we can bound the difference between the averages of $f$ and $p$.
  have h_diff : âˆ€ Îµ > 0, âˆƒ p : Polynomial â„, âˆ€ n : â„•, abs ((âˆ‘ i âˆˆ Finset.range n, f (x i)) / (n : â„) - (âˆ‘ i âˆˆ Finset.range n, p.eval (x i)) / (n : â„)) â‰¤ Îµ âˆ§ abs ((âˆ« t in (0 : â„)..1, f t) - (âˆ« t in (0 : â„)..1, p.eval t)) â‰¤ Îµ := by
    intro Îµ hÎµ; obtain âŸ¨ p, hp âŸ© := h_poly ( Îµ / 2 ) ( half_pos hÎµ ) ; use p; intro n; refine' âŸ¨ _, _ âŸ©;
    Â· rw [ â† sub_div, abs_div ];
      exact div_le_of_le_mulâ‚€ ( by positivity ) ( by positivity ) ( by rw [ â† Finset.sum_sub_distrib ] ; exact le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( le_trans ( Finset.sum_le_sum fun i hi => le_of_lt ( hp _ ( hx i ) ) ) ( by norm_num; nlinarith ) ) );
    Â· rw [ â† intervalIntegral.integral_sub ];
      Â· rw [ intervalIntegral.integral_of_le zero_le_one ];
        refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : â„ â†’ â„ ) ) ( le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ );
        refine' fun t => Îµ / 2;
        Â· exact Filter.Eventually.of_forall fun x => norm_nonneg _;
        Â· norm_num;
        Â· filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using le_of_lt ( hp t <| Set.Ioc_subset_Icc_self ht );
        Â· norm_num ; linarith;
      Â· exact hf.intervalIntegrable_of_Icc ( by norm_num );
      Â· exact p.continuous.intervalIntegrable _ _;
  rw [ Metric.tendsto_nhds ];
  intro Îµ hÎµ; rcases h_diff ( Îµ / 3 ) ( by positivity ) with âŸ¨ p, hp âŸ© ; filter_upwards [ h_poly_avg p |> fun h => h.eventually ( Metric.ball_mem_nhds _ <| show 0 < Îµ / 3 by positivity ) ] with n hn; exact abs_lt.mpr âŸ¨ by linarith [ abs_lt.mp hn, abs_le.mp ( hp n |>.1 ), abs_le.mp ( hp n |>.2 ) ], by linarith [ abs_lt.mp hn, abs_le.mp ( hp n |>.1 ), abs_le.mp ( hp n |>.2 ) ] âŸ© ;

/-
If the average of any continuous function converges to its integral, then the sequence is equidistributed.
-/
theorem continuous_implies_equidistributed (x : â„• â†’ â„) (hx : âˆ€ n, 0 â‰¤ x n âˆ§ x n â‰¤ 1)
    (h : âˆ€ f : â„ â†’ â„, ContinuousOn f (Set.Icc 0 1) â†’
      Tendsto (Î» n : â„• â†¦ ((Finset.range n).sum (Î» i â†¦ f (x i))) / (n : â„))
        atTop (ğ“ (âˆ« t in (0)..1, f t))) :
    equidistributed x := by
  intro Î± Î² hÎ± hÎ² hÎ±Î²;
  -- Define a sequence of continuous functions $f_\epsilon$ that approximate the indicator function of $[\alpha, \beta]$.
  have h_seq : âˆ€ Îµ > 0, âˆƒ f : â„ â†’ â„, ContinuousOn f (Set.Icc 0 1) âˆ§ (âˆ€ t âˆˆ Set.Icc 0 1, f t â‰¥ if Î± â‰¤ t âˆ§ t â‰¤ Î² then 1 else 0) âˆ§ (âˆ€ t âˆˆ Set.Icc 0 1, f t â‰¤ if Î± - Îµ â‰¤ t âˆ§ t â‰¤ Î² + Îµ then 1 else 0) := by
    intro Îµ hÎµ_pos
    use fun t => max 0 (min 1 ((t - (Î± - Îµ)) / Îµ)) * max 0 (min 1 ((Î² + Îµ - t) / Îµ));
    refine' âŸ¨ _, _, _ âŸ©;
    Â· fun_prop;
    Â· field_simp;
      intro t ht; split_ifs;
      Â· rw [ max_eq_right, max_eq_right ] <;> norm_num;
        Â· rw [ min_def, min_def ] ; split_ifs <;> nlinarith [ mul_div_cancelâ‚€ ( t - ( Î± - Îµ ) ) hÎµ_pos.ne', mul_div_cancelâ‚€ ( Î² + Îµ - t ) hÎµ_pos.ne' ];
        Â· exact div_nonneg ( by linarith ) hÎµ_pos.le;
        Â· exact div_nonneg ( by linarith ) hÎµ_pos.le;
      Â· positivity;
    Â· intro t ht; split_ifs <;> norm_num;
      Â· exact mul_le_oneâ‚€ ( max_le_iff.mpr âŸ¨ by norm_num, min_le_of_left_le <| by norm_num âŸ© ) ( by positivity ) ( max_le_iff.mpr âŸ¨ by norm_num, min_le_of_left_le <| by norm_num âŸ© );
      Â· cases max_cases ( 0 : â„ ) ( Min.min 1 ( ( t - ( Î± - Îµ ) ) / Îµ ) ) <;> cases max_cases ( 0 : â„ ) ( Min.min 1 ( ( Î² + Îµ - t ) / Îµ ) ) <;> simp_all +decide;
        linarith [ â€¹Î± â‰¤ t + Îµ â†’ Î² + Îµ < tâ€º ( by linarith ) ];
  have h_seq_approx : âˆ€ Îµ > 0, âˆƒ f : â„ â†’ â„, ContinuousOn f (Set.Icc 0 1) âˆ§ (âˆ€ t âˆˆ Set.Icc 0 1, f t â‰¥ if Î± â‰¤ t âˆ§ t â‰¤ Î² then 1 else 0) âˆ§ (âˆ€ t âˆˆ Set.Icc 0 1, f t â‰¤ if Î± - Îµ â‰¤ t âˆ§ t â‰¤ Î² + Îµ then 1 else 0) âˆ§ (âˆ« t in (0)..1, f t) â‰¤ (Î² - Î±) + 2 * Îµ := by
    intro Îµ hÎµ_pos
    obtain âŸ¨f, hf_cont, hf_approxâŸ© := h_seq Îµ hÎµ_pos
    have h_integral_approx : âˆ« t in (0)..1, f t â‰¤ âˆ« t in (max 0 (Î± - Îµ))..(min 1 (Î² + Îµ)), 1 := by
      have h_integral_approx : âˆ« t in (0)..1, f t â‰¤ âˆ« t in (0)..1, (if Î± - Îµ â‰¤ t âˆ§ t â‰¤ Î² + Îµ then 1 else 0) := by
        apply_rules [ intervalIntegral.integral_mono_on ];
        Â· norm_num;
        Â· exact hf_cont.intervalIntegrable_of_Icc ( by norm_num );
        Â· rw [ intervalIntegrable_iff ];
          refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun t => 1;
          Â· norm_num;
          Â· exact Measurable.aestronglyMeasurable ( by exact Measurable.ite ( measurableSet_Icc ) measurable_const measurable_const );
          Â· exact Filter.Eventually.of_forall fun x => by split_ifs <;> norm_num;
        Â· exact hf_approx.2;
      refine le_trans h_integral_approx ?_;
      rw [ intervalIntegral.integral_of_le, intervalIntegral.integral_of_le ];
      Â· rw [ â† MeasureTheory.integral_Icc_eq_integral_Ioc, â† MeasureTheory.integral_Icc_eq_integral_Ioc ];
        rw [ â† MeasureTheory.integral_indicator, â† MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
        grind;
      Â· cases max_cases ( 0 : â„ ) ( Î± - Îµ ) <;> cases min_cases ( 1 : â„ ) ( Î² + Îµ ) <;> linarith;
      Â· norm_num;
    norm_num at *;
    exact âŸ¨ f, hf_cont, hf_approx.1, hf_approx.2, by cases max_cases 0 ( Î± - Îµ ) <;> cases min_cases 1 ( Î² + Îµ ) <;> linarith âŸ©;
  have h_seq_approx_lower : âˆ€ Îµ > 0, âˆƒ f : â„ â†’ â„, ContinuousOn f (Set.Icc 0 1) âˆ§ (âˆ€ t âˆˆ Set.Icc 0 1, f t â‰¤ if Î± â‰¤ t âˆ§ t â‰¤ Î² then 1 else 0) âˆ§ (âˆ€ t âˆˆ Set.Icc 0 1, f t â‰¥ if Î± + Îµ â‰¤ t âˆ§ t â‰¤ Î² - Îµ then 1 else 0) âˆ§ (âˆ« t in (0)..1, f t) â‰¥ (Î² - Î±) - 2 * Îµ := by
    intros Îµ hÎµ_pos
    by_cases h_case : Î± + Îµ â‰¤ Î² - Îµ;
    Â· -- Define a continuous function $f$ that is 1 on $[\alpha + \epsilon, \beta - \epsilon]$ and 0 outside $[\alpha, \beta]$.
      obtain âŸ¨f, hf_cont, hf_boundsâŸ© : âˆƒ f : â„ â†’ â„, ContinuousOn f (Set.Icc 0 1) âˆ§ (âˆ€ t âˆˆ Set.Icc 0 1, f t â‰¤ if Î± â‰¤ t âˆ§ t â‰¤ Î² then 1 else 0) âˆ§ (âˆ€ t âˆˆ Set.Icc 0 1, f t â‰¥ if Î± + Îµ â‰¤ t âˆ§ t â‰¤ Î² - Îµ then 1 else 0) := by
        use fun t => min 1 (max 0 ((min (t - (Î± + Îµ)) (Î² - Îµ - t)) / Îµ + 1));
        refine' âŸ¨ _, _, _ âŸ©;
        Â· fun_prop;
        Â· field_simp;
          intro t ht; split_ifs <;> norm_num;
          rw [ div_le_iffâ‚€ hÎµ_pos ];
          cases min_cases ( t - ( Î± + Îµ ) ) ( Î² - Îµ - t ) <;> cases lt_or_ge t Î± <;> cases lt_or_ge t Î² <;> first | linarith | exact False.elim <| â€¹Â¬ ( Î± â‰¤ t âˆ§ t â‰¤ Î² ) â€º âŸ¨ by linarith, by linarith âŸ©;
        Â· norm_num +zetaDelta at *;
          intro t htâ‚ htâ‚‚; split_ifs <;> norm_num ;
          exact div_nonneg ( le_min ( by linarith ) ( by linarith ) ) hÎµ_pos.le;
      refine' âŸ¨ f, hf_cont, hf_bounds.1, hf_bounds.2, _ âŸ©;
      have h_integral_lower_bound : âˆ« t in (0)..1, f t â‰¥ âˆ« t in (Î± + Îµ)..(Î² - Îµ), f t := by
        apply_rules [ intervalIntegral.integral_mono_interval ];
        Â· linarith;
        Â· linarith;
        Â· filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using le_trans ( by positivity ) ( hf_bounds.2 t <| Set.Ioc_subset_Icc_self ht );
        Â· exact hf_cont.intervalIntegrable_of_Icc ( by norm_num );
      have h_integral_lower_bound : âˆ« t in (Î± + Îµ)..(Î² - Îµ), f t â‰¥ âˆ« t in (Î± + Îµ)..(Î² - Îµ), 1 := by
        refine' intervalIntegral.integral_mono_on _ _ _ _ <;> norm_num;
        Â· linarith;
        Â· apply_rules [ ContinuousOn.intervalIntegrable, hf_cont ];
          exact hf_cont.mono ( by rw [ Set.uIcc_of_le ( by linarith ) ] ; exact Set.Icc_subset_Icc ( by linarith ) ( by linarith ) );
        Â· exact fun t htâ‚ htâ‚‚ => hf_bounds.2 t âŸ¨ by linarith, by linarith âŸ© |> le_trans ( by rw [ if_pos âŸ¨ htâ‚, htâ‚‚ âŸ© ] );
      norm_num at *; linarith;
    Â· use fun _ => 0;
      norm_num;
      exact âŸ¨ continuousOn_const, fun t htâ‚ htâ‚‚ => by split_ifs <;> norm_num, fun t htâ‚ htâ‚‚ => by split_ifs <;> linarith, by linarith âŸ©;
  -- By the properties of the average and the integral, we can bound the average of the indicator function.
  have h_bound : âˆ€ Îµ > 0, âˆƒ N : â„•, âˆ€ n â‰¥ N, (âˆ‘ i âˆˆ Finset.range n, (if Î± â‰¤ x i âˆ§ x i â‰¤ Î² then 1 else 0)) / (n : â„) â‰¤ (Î² - Î±) + 2 * Îµ + Îµ âˆ§ (âˆ‘ i âˆˆ Finset.range n, (if Î± â‰¤ x i âˆ§ x i â‰¤ Î² then 1 else 0)) / (n : â„) â‰¥ (Î² - Î±) - 2 * Îµ - Îµ := by
    intro Îµ hÎµ_pos
    obtain âŸ¨f_upper, hf_upper_cont, hf_upper_ge, hf_upper_le, hf_upper_integralâŸ© := h_seq_approx Îµ hÎµ_pos
    obtain âŸ¨f_lower, hf_lower_cont, hf_lower_le, hf_lower_ge, hf_lower_integralâŸ© := h_seq_approx_lower Îµ hÎµ_pos;
    have h_bound_upper : âˆƒ N : â„•, âˆ€ n â‰¥ N, (âˆ‘ i âˆˆ Finset.range n, f_upper (x i)) / (n : â„) â‰¤ (Î² - Î±) + 2 * Îµ + Îµ := by
      have := h f_upper hf_upper_cont;
      exact Filter.eventually_atTop.mp ( this.eventually ( ge_mem_nhds <| by linarith ) )
    have h_bound_lower : âˆƒ N : â„•, âˆ€ n â‰¥ N, (âˆ‘ i âˆˆ Finset.range n, f_lower (x i)) / (n : â„) â‰¥ (Î² - Î±) - 2 * Îµ - Îµ := by
      have := h f_lower hf_lower_cont;
      exact Filter.eventually_atTop.mp ( this.eventually ( le_mem_nhds <| by linarith ) );
    obtain âŸ¨ Nâ‚, hNâ‚ âŸ© := h_bound_upper; obtain âŸ¨ Nâ‚‚, hNâ‚‚ âŸ© := h_bound_lower; use Max.max Nâ‚ Nâ‚‚; intro n hn; refine' âŸ¨ _, _ âŸ© <;> norm_num at *;
    Â· refine' le_trans _ ( hNâ‚ n hn.1 );
      gcongr;
      exact le_trans ( by norm_num ) ( Finset.sum_le_sum fun i hi => hf_upper_ge ( x i ) ( hx i |>.1 ) ( hx i |>.2 ) );
    Â· refine' le_trans ( hNâ‚‚ n hn.2 ) _;
      gcongr;
      exact le_trans ( Finset.sum_le_sum fun i hi => hf_lower_le ( x i ) ( hx i |>.1 ) ( hx i |>.2 ) ) ( by norm_num [ Finset.sum_ite ] );
  rw [ Metric.tendsto_nhds ];
  simp +zetaDelta at *;
  exact fun Îµ hÎµ => by obtain âŸ¨ N, hN âŸ© := h_bound ( Îµ / 6 ) ( by positivity ) ; exact âŸ¨ N, fun n hn => abs_lt.mpr âŸ¨ by linarith [ hN n hn ], by linarith [ hN n hn ] âŸ© âŸ© ;

/-
Equidistribution is equivalent to the convergence of averages for all continuous functions.
-/
theorem equidistributed_iff_continuous_iff (x : â„• â†’ â„) (hx : âˆ€ n, 0 â‰¤ x n âˆ§ x n â‰¤ 1) :
    equidistributed x â†”
    âˆ€ f : â„ â†’ â„, ContinuousOn f (Set.Icc 0 1) â†’
      Tendsto (Î» n : â„• â†¦ ((Finset.range n).sum (Î» i â†¦ f (x i))) / (n : â„))
        atTop (ğ“ (âˆ« t in (0)..1, f t)) := by
  constructor
  Â· exact equidistributed_implies_continuous x hx
  Â· exact continuous_implies_equidistributed x hx

/-
A continuous trapezoidal function that is 0 outside (a, d), 1 on [b, c], and linear in between.
-/
def continuous_trap (a b c d : â„) (x : â„) : â„ :=
  max 0 (min 1 (min ((x - a) / (b - a)) ((d - x) / (d - c))))

/-
The trapezoidal function is continuous.
-/
lemma continuous_trap_continuous (a b c d : â„) (h1 : a < b) (h2 : c < d) :
    Continuous (continuous_trap a b c d) := by
  unfold continuous_trap;
  fun_prop (disch := norm_num)

/-
The trapezoidal function is bounded between 0 and 1.
-/
lemma continuous_trap_bounds (a b c d : â„) (h1 : a < b) (h2 : b â‰¤ c) (h3 : c < d) (x : â„) :
    0 â‰¤ continuous_trap a b c d x âˆ§ continuous_trap a b c d x â‰¤ 1 := by
  unfold continuous_trap; aesop

/-
Support properties of the trapezoidal function.
-/
lemma continuous_trap_support (a b c d : â„) (h1 : a < b) (h2 : b â‰¤ c) (h3 : c < d) (x : â„) :
    (continuous_trap a b c d x â‰  0 â†’ a < x âˆ§ x < d) âˆ§
    (b â‰¤ x âˆ§ x â‰¤ c â†’ continuous_trap a b c d x = 1) := by
  constructor <;> intro h;
  Â· unfold continuous_trap at h;
    aesop;
  Â· -- By definition of continuous_trap, we know that for $b \leq x \leq c$, both $(x - a) / (b - a) \geq 1$ and $(d - x) / (d - c) \geq 1$.
    have h_ge_one : (x - a) / (b - a) â‰¥ 1 âˆ§ (d - x) / (d - c) â‰¥ 1 := by
      exact âŸ¨ by rw [ ge_iff_le ] ; rw [ le_div_iffâ‚€ ] <;> linarith, by rw [ ge_iff_le ] ; rw [ le_div_iffâ‚€ ] <;> linarith âŸ©;
    exact Eq.symm ( by unfold continuous_trap; aesop )

/-
Upper trapezoidal approximation of the indicator function of [Î±, Î²].
-/
def trap_upper (Î± Î² Îµ : â„) (x : â„) : â„ := continuous_trap (Î± - Îµ) Î± Î² (Î² + Îµ) x

/-
Lower trapezoidal approximation of the indicator function of [Î±, Î²].
-/
def trap_lower (Î± Î² Îµ : â„) (x : â„) : â„ := continuous_trap Î± (Î± + Îµ) (Î² - Îµ) Î² x

/-
The upper trapezoidal approximation is integrable.
-/
lemma trap_upper_integrable (Î± Î² Îµ : â„) (hÎµ : 0 < Îµ) :
    IntervalIntegrable (trap_upper Î± Î² Îµ) MeasureTheory.volume 0 1 := by
  apply Continuous.intervalIntegrable
  apply continuous_trap_continuous
  linarith
  linarith

/-
The lower trapezoidal approximation is integrable.
-/
lemma trap_lower_integrable (Î± Î² Îµ : â„) (hÎµ : 0 < Îµ) :
    IntervalIntegrable (trap_lower Î± Î² Îµ) MeasureTheory.volume 0 1 := by
  apply Continuous.intervalIntegrable
  apply continuous_trap_continuous
  linarith
  linarith

/-
The integral of the difference between the upper and lower trapezoidal approximations is bounded by 4Îµ.
-/
lemma trap_integral_diff (Î± Î² Îµ : â„) (hÎ± : 0 â‰¤ Î±) (hÎ² : Î² â‰¤ 1) (hÎ±Î² : Î± â‰¤ Î²) (hÎµ : 0 < Îµ) :
    âˆ« x in Set.Ioc 0 1, (trap_upper Î± Î² Îµ x - trap_lower Î± Î² Îµ x) â‰¤ 4 * Îµ := by
  rw [ MeasureTheory.integral_Ioc_eq_integral_Ioo ];
  -- The integral of the difference between the upper and lower trapezoidal approximations over (0,1) is at most the integral over the interval where the difference is non-zero, which is (Î± - Îµ, Î± + Îµ) âˆª (Î² - Îµ, Î² + Îµ).
  have h_diff_nonzero : âˆ€ t âˆˆ Set.Ioo 0 1, trap_upper Î± Î² Îµ t - trap_lower Î± Î² Îµ t â‰¤ if t âˆˆ Set.Ioo (Î± - Îµ) (Î± + Îµ) âˆª Set.Ioo (Î² - Îµ) (Î² + Îµ) then 1 else 0 := by
    intro t ht
    by_cases h_case : t âˆˆ Set.Ioo (Î± - Îµ) (Î± + Îµ) âˆª Set.Ioo (Î² - Îµ) (Î² + Îµ);
    Â· -- Since $t \in (\beta - \epsilon, \beta + \epsilon)$, we have $trap_upper Î± Î² Îµ t \leq 1$ and $trap_lower Î± Î² Îµ t \geq 0$.
      have h_bounds : trap_upper Î± Î² Îµ t â‰¤ 1 âˆ§ trap_lower Î± Î² Îµ t â‰¥ 0 := by
        exact âŸ¨ by unfold trap_upper; exact max_le_iff.mpr âŸ¨ by norm_num, min_le_of_left_le <| by norm_num âŸ©, by unfold trap_lower; exact le_max_of_le_left <| by norm_num âŸ©;
      grind;
    Â· simp [h_case];
      unfold trap_upper trap_lower;
      unfold continuous_trap;
      norm_num [ sub_sub_eq_add_sub ] at *;
      by_cases h_case1 : Î± - Îµ < t <;> by_cases h_case2 : Î² - Îµ < t <;> simp_all +decide [ div_le_iffâ‚€, le_div_iffâ‚€ ];
      Â· exact Or.inr âŸ¨ âŸ¨ by linarith, Or.inl <| by linarith âŸ©, by linarith, Or.inl <| by linarith âŸ©;
      Â· exact Or.inl <| Or.inl <| by linarith;
  refine' le_trans ( MeasureTheory.setIntegral_mono_on _ _ measurableSet_Ioo h_diff_nonzero ) _;
  Â· refine' Continuous.integrableOn_Icc _ |> fun h => h.mono_set <| Set.Ioo_subset_Icc_self;
    exact Continuous.sub ( continuous_trap_continuous _ _ _ _ ( by linarith ) ( by linarith ) ) ( continuous_trap_continuous _ _ _ _ ( by linarith ) ( by linarith ) );
  Â· refine' MeasureTheory.Integrable.mono' _ _ _;
    exacts [ fun _ => 1, by norm_num, by exact Measurable.aestronglyMeasurable ( by exact Measurable.ite ( by exact MeasurableSet.union ( measurableSet_Ioo ) ( measurableSet_Ioo ) ) measurable_const measurable_const ), Filter.Eventually.of_forall fun x => by split_ifs <;> norm_num ];
  Â· -- The integral of the indicator function over the union of intervals is just the sum of the lengths of those intervals.
    have h_indicator_integral : âˆ« x in Set.Ioo 0 1, (if x âˆˆ Set.Ioo (Î± - Îµ) (Î± + Îµ) âˆª Set.Ioo (Î² - Îµ) (Î² + Îµ) then 1 else 0) â‰¤ âˆ« x in Set.Ioo (Î± - Îµ) (Î± + Îµ) âˆª Set.Ioo (Î² - Îµ) (Î² + Îµ), (1 : â„) := by
      rw [ â† MeasureTheory.integral_indicator, â† MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
      refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
      Â· exact Filter.Eventually.of_forall fun x => by positivity;
      Â· refine' MeasureTheory.Integrable.congr _ _;
        refine' fun x => Set.indicator ( Set.Ioo ( Î± - Îµ ) ( Î± + Îµ ) âˆª Set.Ioo ( Î² - Îµ ) ( Î² + Îµ ) ) ( fun _ => 1 ) x;
        Â· rw [ MeasureTheory.integrable_indicator_iff ] <;> norm_num;
        Â· norm_num [ Filter.EventuallyEq, Set.indicator ];
      Â· filter_upwards [ ] with x using by aesop;
    norm_num +zetaDelta at *;
    refine' le_trans h_indicator_integral _;
    refine' le_trans ( ENNReal.toReal_mono _ <| MeasureTheory.measure_union_le _ _ ) _ <;> norm_num;
    rw [ ENNReal.toReal_add ] <;> norm_num ; linarith [ ENNReal.toReal_ofReal ( show 0 â‰¤ Îµ + Îµ by linarith ) ]

/-
Lower approximation of x * indicator.
-/
def trap_x_lower (Î± Î² Îµ : â„) (x : â„) : â„ := x * trap_lower Î± Î² Îµ x

/-
Upper approximation of x * indicator.
-/
def trap_x_upper (Î± Î² Îµ : â„) (x : â„) : â„ := x * trap_upper Î± Î² Îµ x

/-
The sandwich inequality for x * indicator.
-/
lemma trap_x_sandwich (Î± Î² Îµ : â„) (hÎ± : 0 â‰¤ Î±) (hÎ² : Î² â‰¤ 1) (hÎ±Î² : Î± â‰¤ Î²) (hÎµ : 0 < Îµ) (x : â„) (hx : 0 â‰¤ x âˆ§ x â‰¤ 1) :
    trap_x_lower Î± Î² Îµ x â‰¤ (if Î± â‰¤ x âˆ§ x â‰¤ Î² then x else 0) âˆ§
    (if Î± â‰¤ x âˆ§ x â‰¤ Î² then x else 0) â‰¤ trap_x_upper Î± Î² Îµ x := by
  -- Let's split into cases based on whether x is in [Î±, Î²].
  by_cases h : Î± â‰¤ x âˆ§ x â‰¤ Î²;
  Â· -- Since $x \in [\alpha, \beta]$, we have $\text{trap\_upper} \alpha \beta \epsilon x = 1$ and $\text{trap\_lower} \alpha \beta \epsilon x \leq 1$.
    have h_upper : trap_upper Î± Î² Îµ x = 1 := by
      apply (continuous_trap_support (Î± - Îµ) Î± Î² (Î² + Îµ) (by linarith) (by linarith) (by linarith) x).right h;
    simp_all +decide [ trap_x_lower, trap_x_upper ];
    exact mul_le_of_le_one_right hx.1 ( by exact ( show trap_lower Î± Î² Îµ x â‰¤ 1 from by exact ( show continuous_trap Î± ( Î± + Îµ ) ( Î² - Îµ ) Î² x â‰¤ 1 from by exact ( show max 0 ( min 1 ( min ( ( x - Î± ) / ( Î± + Îµ - Î± ) ) ( ( Î² - x ) / ( Î² - ( Î² - Îµ ) ) ) ) ) â‰¤ 1 from by exact max_le ( by norm_num ) ( min_le_left _ _ ) ) ) ) );
  Â· split_ifs ; simp_all +decide [ trap_x_lower, trap_x_upper ];
    constructor;
    Â· unfold trap_lower;
      unfold continuous_trap;
      rw [ max_eq_left ] <;> norm_num;
      exact Classical.or_iff_not_imp_left.2 fun h' => by rw [ div_le_iffâ‚€ hÎµ ] at *; contrapose! h; constructor <;> linarith;
    Â· exact mul_nonneg hx.1 ( by unfold trap_upper; exact le_max_of_le_left ( by norm_num ) )

/-
The integral of the difference of the sandwich functions is small.
-/
lemma trap_x_integral_diff (Î± Î² Îµ : â„) (hÎ± : 0 â‰¤ Î±) (hÎ² : Î² â‰¤ 1) (hÎ±Î² : Î± â‰¤ Î²) (hÎµ : 0 < Îµ) :
    âˆ« x in Set.Ioc 0 1, (trap_x_upper Î± Î² Îµ x - trap_x_lower Î± Î² Îµ x) â‰¤ 4 * Îµ := by
  -- Since $x \leq 1$ for all $x \in [0, 1]$, we have $\int_{0}^{1} x \cdot (\text{trap}_{\text{upper}} - \text{trap}_{\text{lower}}) \leq \int_{0}^{1} (\text{trap}_{\text{upper}} - \text{trap}_{\text{lower}})$.
  have h_integral_le : âˆ« x in Set.Ioc 0 1, x * (trap_upper Î± Î² Îµ x - trap_lower Î± Î² Îµ x) â‰¤ âˆ« x in Set.Ioc 0 1, (trap_upper Î± Î² Îµ x - trap_lower Î± Î² Îµ x) := by
    refine' MeasureTheory.setIntegral_mono_on _ _ measurableSet_Ioc fun x hx => mul_le_of_le_one_left ( _ ) hx.2;
    Â· exact Continuous.integrableOn_Ioc ( by exact Continuous.mul continuous_id ( by exact Continuous.sub ( continuous_trap_continuous _ _ _ _ ( by linarith ) ( by linarith ) ) ( continuous_trap_continuous _ _ _ _ ( by linarith ) ( by linarith ) ) ) );
    Â· exact Continuous.integrableOn_Ioc ( by exact Continuous.sub ( continuous_trap_continuous _ _ _ _ ( by linarith ) ( by linarith ) ) ( continuous_trap_continuous _ _ _ _ ( by linarith ) ( by linarith ) ) );
    Â· unfold trap_upper trap_lower;
      unfold continuous_trap;
      grind;
  simpa only [ mul_sub, mul_one ] using h_integral_le.trans ( by simpa only [ mul_sub, mul_one ] using trap_integral_diff Î± Î² Îµ hÎ± hÎ² hÎ±Î² hÎµ )

/-
The integrals of the upper and lower approximations are close to the target value (beta^2 - alpha^2)/2.
-/
lemma trap_x_integral_close (Î± Î² Îµ : â„) (hÎ± : 0 â‰¤ Î±) (hÎ² : Î² â‰¤ 1) (hÎ±Î² : Î± â‰¤ Î²) (hÎµ : 0 < Îµ) :
    abs (âˆ« x in Set.Ioc 0 1, trap_x_upper Î± Î² Îµ x - (Î²^2 - Î±^2) / 2) â‰¤ 4 * Îµ âˆ§
    abs (âˆ« x in Set.Ioc 0 1, trap_x_lower Î± Î² Îµ x - (Î²^2 - Î±^2) / 2) â‰¤ 4 * Îµ := by
  -- By the properties of the trapezoidal functions, we have that $\int_0^1 \text{trap}_x \text{lower}(\alpha, \beta, \epsilon, x) \, dx \leq \int_0^1 \text{trap}_x \text{upper}(\alpha, \beta, \epsilon, x) \, dx$.
  have h_integral_bounds : âˆ« x in (Set.Ioc 0 1), trap_x_lower Î± Î² Îµ x â‰¤ (Î²^2 - Î±^2) / 2 âˆ§ (Î²^2 - Î±^2) / 2 â‰¤ âˆ« x in (Set.Ioc 0 1), trap_x_upper Î± Î² Îµ x := by
    have h_integral_bounds : âˆ« x in (Set.Ioc 0 1), (if Î± â‰¤ x âˆ§ x â‰¤ Î² then x else 0) = (Î²^2 - Î±^2) / 2 := by
      -- Split the integral into two parts: over $[Î±, Î²]$ and over $[0, 1] \setminus [Î±, Î²]$.
      have h_split : âˆ« x in Set.Ioc 0 1, (if Î± â‰¤ x âˆ§ x â‰¤ Î² then x else 0) = âˆ« x in Set.Icc Î± Î², x := by
        rw [ â† MeasureTheory.integral_Icc_eq_integral_Ioc, â† MeasureTheory.integral_indicator, â† MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
        grind;
      rw [ h_split, MeasureTheory.integral_Icc_eq_integral_Ioc, â† intervalIntegral.integral_of_le ] <;> norm_num ; linarith;
    refine' âŸ¨ h_integral_bounds â–¸ MeasureTheory.setIntegral_mono_on _ _ _ _, h_integral_bounds â–¸ MeasureTheory.setIntegral_mono_on _ _ _ _ âŸ©;
    any_goals norm_num;
    any_goals intro x hxâ‚ hxâ‚‚; exact trap_x_sandwich Î± Î² Îµ hÎ± hÎ² hÎ±Î² hÎµ x âŸ¨ hxâ‚.le, hxâ‚‚ âŸ© |>.2;
    Â· exact Continuous.integrableOn_Ioc ( by exact Continuous.mul continuous_id ( by exact continuous_iff_continuousAt.mpr fun x => by exact ContinuousAt.tendsto ( by exact continuous_iff_continuousAt.mp ( continuous_trap_continuous _ _ _ _ ( by linarith ) ( by linarith ) ) _ ) ) );
    Â· refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => |x|;
      Â· exact Continuous.integrableOn_Ioc ( by continuity );
      Â· exact Measurable.aestronglyMeasurable ( by exact Measurable.ite ( measurableSet_Icc ) measurable_id measurable_const );
      Â· filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx using by split_ifs <;> norm_num;
    Â· exact fun x hxâ‚ hxâ‚‚ => trap_x_sandwich Î± Î² Îµ hÎ± hÎ² hÎ±Î² hÎµ x âŸ¨ hxâ‚.le, hxâ‚‚ âŸ© |>.1;
    Â· refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => |x|;
      Â· exact Continuous.integrableOn_Ioc ( by continuity );
      Â· exact Measurable.aestronglyMeasurable ( by exact Measurable.ite ( measurableSet_Icc ) measurable_id measurable_const );
      Â· filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx using by split_ifs <;> norm_num;
    Â· exact Continuous.integrableOn_Ioc ( by exact Continuous.mul continuous_id <| by exact continuous_trap_continuous _ _ _ _ ( by linarith ) ( by linarith ) );
  rw [ MeasureTheory.integral_sub, MeasureTheory.integral_sub ] <;> norm_num [ â† intervalIntegral.integral_of_le ] at *;
  Â· have h_integral_diff : âˆ« x in (Set.Ioc 0 1), (trap_x_upper Î± Î² Îµ x - trap_x_lower Î± Î² Îµ x) â‰¤ 4 * Îµ := by
      exact?;
    rw [ â† intervalIntegral.integral_of_le zero_le_one, intervalIntegral.integral_sub ] at * <;> norm_num at *;
    Â· exact âŸ¨ abs_le.mpr âŸ¨ by linarith, by linarith âŸ©, abs_le.mpr âŸ¨ by linarith, by linarith âŸ© âŸ©;
    Â· apply_rules [ Continuous.intervalIntegrable ];
      apply_rules [ Continuous.mul, Continuous.max, Continuous.min, continuous_id, continuous_const ];
      Â· continuity;
      Â· fun_prop;
    Â· apply_rules [ ContinuousOn.intervalIntegrable ];
      exact ContinuousOn.mul continuousOn_id <| ContinuousOn.congr ( show ContinuousOn ( fun x => continuous_trap Î± ( Î± + Îµ ) ( Î² - Îµ ) Î² x ) ( Set.uIcc 0 1 ) from Continuous.continuousOn <| by exact continuous_trap_continuous _ _ _ _ ( by linarith ) ( by linarith ) ) fun x hx => rfl;
  Â· exact Continuous.integrableOn_Ioc ( by exact Continuous.mul continuous_id ( continuous_trap_continuous Î± ( Î± + Îµ ) ( Î² - Îµ ) Î² ( by linarith ) ( by linarith ) ) );
  Â· refine' Continuous.integrableOn_Ioc _;
    exact Continuous.mul continuous_id <| continuous_trap_continuous _ _ _ _ ( by linarith ) ( by linarith )