/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b726c85d-1b34-461e-8c4e-a3a957585d7f

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Real.digits

#check Int.fract

/-
v_g(n) is the number of integers k <= n such that the j-th decimal digit of sqrt(k) is g.
-/
open Filter Real Set Topology

noncomputable def v_g (j g n : ‚Ñï) : ‚Ñï :=
  ((Finset.Icc 1 n).filter (Œª k =>
    (Real.digits (Int.fract (Real.sqrt k)) 10 (j - 1) : ‚Ñï) = g
  )).card

/-
A sequence u_n is equidistributed modulo 1 if for every interval [a, b) in [0, 1), the proportion of fractional parts falling in [a, b) converges to b - a.
-/
open Filter Real Set Topology

def IsEquidistributed (u : ‚Ñï ‚Üí ‚Ñù) : Prop :=
  ‚àÄ a b, 0 ‚â§ a ‚Üí a < b ‚Üí b ‚â§ 1 ‚Üí
    Tendsto (Œª n => ((Finset.range n).filter (Œª k => a ‚â§ Int.fract (u k) ‚àß Int.fract (u k) < b)).card / (n : ‚Ñù)) atTop (ùìù (b - a))

/-
The n-th digit of the fractional part of x in base b is g iff the fractional part of x * b^n is in [g/b, (g+1)/b).
-/
open Filter Real Set Topology

lemma digits_iff_fract (x : ‚Ñù) (b : ‚Ñï) [NeZero b] (n : ‚Ñï) (g : ‚Ñï) (hb : 1 < b) (hg : g < b) :
    (Real.digits (Int.fract x) b n : ‚Ñï) = g ‚Üî
    (g : ‚Ñù) / b ‚â§ Int.fract (x * (b : ‚Ñù) ^ n) ‚àß Int.fract (x * (b : ‚Ñù) ^ n) < (g + 1 : ‚Ñù) / b := by
  have h_digits_fract : Int.fract (x * b ^ n) = b ^ n * (Int.fract x) - ‚åäb ^ n * (Int.fract x)‚åã := by
    simp +decide [ mul_comm, Int.fract_eq_iff ];
    exact ‚ü® Int.fract_lt_one _, ‚ü® ‚åäx‚åã * b ^ n + ‚åäInt.fract x * b ^ n‚åã, by push_cast; nlinarith [ Int.fract_add_floor x, Int.fract_add_floor ( Int.fract x * b ^ n ), show ( b : ‚Ñù ) ^ n > 0 by positivity ] ‚ü© ‚ü©;
  -- By definition of `digits`, the j-th digit of `Int.fract x` in base `b` is given by `‚åäb^j * Int.fract x‚åã % b`.
  have h_digit_def : (Real.digits (Int.fract x) b n : ‚Ñï) = ‚åäb ^ (n + 1) * Int.fract x‚åã % b := by
    norm_num [ Real.digits ];
    norm_num [ mul_comm ];
    erw [ Int.toNat_of_nonneg <| Int.floor_nonneg.mpr <| by exact mul_nonneg ( Int.fract_nonneg x ) <| by positivity ];
  have h_digit_def : ‚åäb ^ (n + 1) * Int.fract x‚åã % b = g ‚Üî ‚åäb * (b ^ n * Int.fract x)‚åã % b = g := by
    ring;
  have h_floor_eq : ‚åäb * (b ^ n * Int.fract x)‚åã = b * ‚åäb ^ n * Int.fract x‚åã + ‚åäb * (b ^ n * Int.fract x - ‚åäb ^ n * Int.fract x‚åã)‚åã := by
    rw [ ‚Üê Int.floor_intCast_add ] ; push_cast ; ring;
  have h_floor_eq : ‚åäb * (b ^ n * Int.fract x - ‚åäb ^ n * Int.fract x‚åã)‚åã = g ‚Üî (g : ‚Ñù) / b ‚â§ b ^ n * Int.fract x - ‚åäb ^ n * Int.fract x‚åã ‚àß b ^ n * Int.fract x - ‚åäb ^ n * Int.fract x‚åã < (g + 1) / b := by
    norm_num [ Int.floor_eq_iff ];
    field_simp;
  simp_all +decide [ ‚Üê Int.natCast_inj ];
  rw [ ‚Üê h_floor_eq ];
  rw [ Int.emod_eq_of_lt ];
  ¬∑ exact Int.floor_nonneg.mpr ( mul_nonneg ( Nat.cast_nonneg _ ) ( Int.fract_nonneg _ ) );
  ¬∑ exact Int.floor_lt.mpr ( by norm_num; nlinarith [ Int.fract_nonneg ( ( b : ‚Ñù ) ^ n * Int.fract x ), Int.fract_lt_one ( ( b : ‚Ñù ) ^ n * Int.fract x ), show ( b : ‚Ñù ) > 1 by norm_cast ] )

/-
The Weyl Criterion for a sequence u_n states that for all non-zero integers h, the average of exp(2*pi*i*h*u_n) tends to 0.
-/
open Filter Real Set Topology Complex

def WeylCriterion (u : ‚Ñï ‚Üí ‚Ñù) : Prop :=
  ‚àÄ h : ‚Ñ§, h ‚â† 0 ‚Üí Tendsto (Œª N => (‚àë n ‚àà Finset.range N, exp (2 * œÄ * I * h * (u n : ‚ÑÇ))) / N) atTop (ùìù 0)

/-
The integral of exp(i*c*sqrt(x)) from 0 to N is O(sqrt(N)).
-/
open Filter Real Set Topology Complex

lemma integral_exp_sqrt_bound (c : ‚Ñù) (hc : c ‚â† 0) :
    (Œª N : ‚Ñù => ‚à´ x in (0)..N, exp (I * c * Real.sqrt x)) =O[atTop] (Œª N => Real.sqrt N) := by
  -- Use integration by parts with $u = \sqrt{x}$ and $dv = e^{i c \sqrt{x}} dx$.
  have h_parts : ‚àÄ N : ‚Ñù, 0 ‚â§ N ‚Üí ‚à´ x in (0 : ‚Ñù)..N, Complex.exp (Complex.I * c * Real.sqrt x) = (2 / (Complex.I * c)) * (Complex.exp (Complex.I * c * Real.sqrt N) * Real.sqrt N - Complex.exp (Complex.I * c * Real.sqrt 0) * Real.sqrt 0) - (2 / (Complex.I * c)) * ‚à´ x in (0 : ‚Ñù)..N, (1 / (2 * Real.sqrt x)) * Complex.exp (Complex.I * c * Real.sqrt x) := by
    intro N hN
    have h_parts : ‚àÄ a b : ‚Ñù, 0 ‚â§ a ‚Üí a ‚â§ b ‚Üí ‚à´ x in a..b, Complex.exp (Complex.I * c * Real.sqrt x) = (2 / (Complex.I * c)) * (Complex.exp (Complex.I * c * Real.sqrt b) * Real.sqrt b - Complex.exp (Complex.I * c * Real.sqrt a) * Real.sqrt a) - (2 / (Complex.I * c)) * ‚à´ x in a..b, (1 / (2 * Real.sqrt x)) * Complex.exp (Complex.I * c * Real.sqrt x) := by
      intros a b ha hb
      have h_parts : ‚àÄ x ‚àà Set.Ioo a b, HasDerivAt (fun x => (2 / (Complex.I * c)) * Complex.exp (Complex.I * c * Real.sqrt x) * Real.sqrt x) (Complex.exp (Complex.I * c * Real.sqrt x) + (2 / (Complex.I * c)) * (1 / (2 * Real.sqrt x)) * Complex.exp (Complex.I * c * Real.sqrt x)) x := by
        intro x hx;
        convert HasDerivAt.mul ( HasDerivAt.mul ( hasDerivAt_const _ _ ) ( HasDerivAt.comp x ( Complex.hasDerivAt_exp _ ) <| HasDerivAt.const_mul _ <| HasDerivAt.ofReal_comp <| Real.hasDerivAt_sqrt <| by linarith [ hx.1 ] ) ) ( HasDerivAt.ofReal_comp <| Real.hasDerivAt_sqrt <| by linarith [ hx.1 ] ) using 1 ; ring;
        norm_num [ Complex.ext_iff, mul_assoc, mul_comm, mul_left_comm, hc ] ; ring;
        norm_num [ ne_of_gt ( Real.sqrt_pos.mpr ( show 0 < x by linarith [ hx.1 ] ) ) ];
      have h_parts : ‚à´ x in a..b, (Complex.exp (Complex.I * c * Real.sqrt x) + (2 / (Complex.I * c)) * (1 / (2 * Real.sqrt x)) * Complex.exp (Complex.I * c * Real.sqrt x)) = (2 / (Complex.I * c)) * (Complex.exp (Complex.I * c * Real.sqrt b) * Real.sqrt b - Complex.exp (Complex.I * c * Real.sqrt a) * Real.sqrt a) := by
        rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le hb ];
        rotate_right;
        use fun x => 2 / ( Complex.I * c ) * Complex.exp ( Complex.I * c * Real.sqrt x ) * Real.sqrt x;
        ¬∑ ring;
        ¬∑ fun_prop (disch := norm_num);
        ¬∑ exact h_parts;
        ¬∑ rw [ intervalIntegrable_iff_integrableOn_Ioo_of_le hb ];
          refine' MeasureTheory.Integrable.add _ _;
          ¬∑ exact Continuous.integrableOn_Icc ( by continuity ) |> fun h => h.mono_set <| Set.Ioo_subset_Icc_self;
          ¬∑ refine' MeasureTheory.Integrable.mono' _ _ _;
            refine' fun x => 2 / |c| * ( 1 / ( 2 * Real.sqrt x ) );
            ¬∑ -- The function $1 / (2 * \sqrt{x})$ is integrable on $(a, b)$ since it is continuous and bounded.
              have h_integrable : MeasureTheory.IntegrableOn (fun x => 1 / Real.sqrt x) (Set.Ioo a b) := by
                have h_integrable : MeasureTheory.IntegrableOn (fun x => x ^ (-1 / 2 : ‚Ñù)) (Set.Ioo a b) := by
                  exact ( intervalIntegral.intervalIntegrable_rpow' ( by norm_num ) ).1.mono_set ( Set.Ioo_subset_Ioc_self );
                exact h_integrable.congr_fun ( fun x hx => by norm_num [ Real.sqrt_eq_rpow, Real.rpow_neg ( by linarith [ hx.1 ] : 0 ‚â§ x ) ] ) measurableSet_Ioo;
              convert h_integrable.const_mul ( 2 / |c| * ( 1 / 2 ) ) using 2 ; ring;
            ¬∑ exact Measurable.aestronglyMeasurable ( by exact Measurable.mul ( Measurable.mul ( measurable_const ) ( measurable_one.div ( measurable_const.mul ( Complex.continuous_ofReal.measurable.comp ( Real.continuous_sqrt.measurable ) ) ) ) ) ( Complex.continuous_exp.measurable.comp ( measurable_const.mul ( Complex.continuous_ofReal.measurable.comp ( Real.continuous_sqrt.measurable ) ) ) ) );
            ¬∑ norm_num [ Complex.norm_exp ];
              exact Filter.eventually_inf_principal.mpr ( Filter.Eventually.of_forall fun x hx => by rw [ abs_of_nonneg ( Real.sqrt_nonneg x ) ] );
      rw [ ‚Üê h_parts, intervalIntegral.integral_add ];
      ¬∑ norm_num [ mul_assoc ];
      ¬∑ exact Continuous.intervalIntegrable ( by continuity ) _ _;
      ¬∑ rw [ intervalIntegrable_iff_integrableOn_Ioo_of_le hb ];
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun x => 2 / |c| * ( 1 / ( 2 * Real.sqrt x ) );
        ¬∑ -- The function $1 / (2 * \sqrt{x})$ is integrable on $(a, b)$ since it is continuous and bounded.
          have h_integrable : MeasureTheory.IntegrableOn (fun x => 1 / Real.sqrt x) (Set.Ioo a b) := by
            have h_integrable : MeasureTheory.IntegrableOn (fun x => x ^ (-1 / 2 : ‚Ñù)) (Set.Ioo a b) := by
              exact ( intervalIntegral.intervalIntegrable_rpow' ( by norm_num ) ).1.mono_set ( Set.Ioo_subset_Ioc_self );
            exact h_integrable.congr_fun ( fun x hx => by norm_num [ Real.sqrt_eq_rpow, Real.rpow_neg ( by linarith [ hx.1 ] : 0 ‚â§ x ) ] ) measurableSet_Ioo;
          convert h_integrable.const_mul ( 2 / |c| * ( 1 / 2 ) ) using 2 ; ring;
        ¬∑ exact Measurable.aestronglyMeasurable ( by exact Measurable.mul ( Measurable.mul ( measurable_const ) ( measurable_one.div ( measurable_const.mul ( Complex.continuous_ofReal.measurable.comp ( Real.continuous_sqrt.measurable ) ) ) ) ) ( Complex.continuous_exp.measurable.comp ( measurable_const.mul ( Complex.continuous_ofReal.measurable.comp ( Real.continuous_sqrt.measurable ) ) ) ) );
        ¬∑ norm_num [ Complex.norm_exp ];
          exact Filter.eventually_inf_principal.mpr ( Filter.Eventually.of_forall fun x hx => by rw [ abs_of_nonneg ( Real.sqrt_nonneg x ) ] );
    exact h_parts 0 N le_rfl hN;
  -- Evaluate the remaining integral $\int_0^N \frac{1}{2\sqrt{x}} e^{i c \sqrt{x}} dx$.
  have h_remaining : ‚àÄ N : ‚Ñù, 0 ‚â§ N ‚Üí ‚à´ x in (0 : ‚Ñù)..N, (1 / (2 * Real.sqrt x)) * Complex.exp (Complex.I * c * Real.sqrt x) = (1 / (Complex.I * c)) * (Complex.exp (Complex.I * c * Real.sqrt N) - Complex.exp (Complex.I * c * Real.sqrt 0)) := by
    intro N hN; rw [ intervalIntegral.integral_eq_sub_of_hasDeriv_right ];
    rotate_right;
    use fun x => ( 1 / ( Complex.I * c ) ) * Complex.exp ( Complex.I * c * Real.sqrt x );
    ¬∑ ring;
    ¬∑ exact Continuous.continuousOn ( by continuity );
    ¬∑ field_simp;
      intro x hx; convert HasDerivAt.hasDerivWithinAt <| HasDerivAt.div_const ( HasDerivAt.comp x ( Complex.hasDerivAt_exp _ ) <| HasDerivAt.const_mul _ <| HasDerivAt.ofReal_comp <| Real.hasDerivAt_sqrt <| by cases min_cases 0 N <;> cases max_cases 0 N <;> linarith [ hx.1, hx.2 ] ) _ using 1 ; norm_num ; ring;
      norm_num [ mul_assoc, mul_comm, mul_left_comm, hc ];
      norm_num [ ‚Üê mul_assoc ];
    ¬∑ rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le hN ];
      refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => 1 / ( 2 * Real.sqrt x );
      ¬∑ -- The integral of $1 / (2 * \sqrt{x})$ over $(0, N)$ is convergent.
        have h_integrable : MeasureTheory.IntegrableOn (fun x : ‚Ñù => x ^ (-1 / 2 : ‚Ñù)) (Set.Ioc 0 N) := by
          exact ( intervalIntegral.intervalIntegrable_rpow' ( by norm_num ) ).1;
        refine' h_integrable.const_mul _ |> fun h => h.congr _;
        exacts [ 1 / 2, Filter.eventuallyEq_of_mem ( MeasureTheory.ae_restrict_mem measurableSet_Ioc ) fun x hx => by norm_num [ Real.sqrt_eq_rpow, Real.rpow_neg hx.1.le ] ; ring ];
      ¬∑ exact Measurable.aestronglyMeasurable ( by exact Measurable.mul ( measurable_one.div ( measurable_const.mul ( Complex.continuous_ofReal.measurable.comp ( Real.continuous_sqrt.measurable ) ) ) ) ( Complex.continuous_exp.measurable.comp ( measurable_const.mul ( Complex.continuous_ofReal.measurable.comp ( Real.continuous_sqrt.measurable ) ) ) ) );
      ¬∑ norm_num [ Complex.norm_exp ];
        exact Filter.eventually_inf_principal.mpr ( Filter.Eventually.of_forall fun x hx => by rw [ abs_of_nonneg ( Real.sqrt_nonneg x ) ] );
  -- Substitute the result of the remaining integral into the expression from integration by parts.
  have h_final : ‚àÄ N : ‚Ñù, 0 ‚â§ N ‚Üí ‚à´ x in (0 : ‚Ñù)..N, Complex.exp (Complex.I * c * Real.sqrt x) = (2 / (Complex.I * c)) * (Complex.exp (Complex.I * c * Real.sqrt N) * Real.sqrt N) - (2 / (Complex.I * c)) * (1 / (Complex.I * c)) * (Complex.exp (Complex.I * c * Real.sqrt N) - 1) := by
    intro N hN; rw [ h_parts N hN, h_remaining N hN ] ; norm_num ; ring;
  rw [ Asymptotics.isBigO_iff ];
  refine' ‚ü® 2 * ‚Äñ2 / ( Complex.I * c )‚Äñ + 2 * ‚Äñ2 / ( Complex.I * c ) * ( 1 / ( Complex.I * c ) )‚Äñ, Filter.eventually_atTop.mpr ‚ü® 1, fun N hN => _ ‚ü© ‚ü© ; rw [ h_final N <| by positivity ] ; norm_num [ Complex.norm_exp ];
  refine' le_trans ( norm_add_le _ _ ) _;
  norm_num [ Complex.norm_exp ];
  refine' le_trans ( add_le_add_left ( mul_le_mul_of_nonneg_left ( norm_sub_le _ _ ) ( by positivity ) ) _ ) _ ; norm_num [ Complex.norm_exp ] ; ring_nf ; norm_num [ abs_of_nonneg, Real.sqrt_nonneg, hN ];
  nlinarith [ inv_nonneg.2 ( abs_nonneg c ), inv_nonneg.2 ( sq_nonneg c ), Real.sqrt_nonneg N, Real.sq_sqrt ( show 0 ‚â§ N by positivity ), mul_le_mul_of_nonneg_left ( Real.sqrt_nonneg N ) ( inv_nonneg.2 ( abs_nonneg c ) ), mul_le_mul_of_nonneg_left ( Real.sqrt_nonneg N ) ( inv_nonneg.2 ( sq_nonneg c ) ) ]

/-
The difference between the sum and the integral of a differentiable function is bounded by the initial value plus the integral of the derivative's norm.
-/
open Filter Real Set Topology Complex

lemma sum_sub_integral_norm_bound {f : ‚Ñù ‚Üí ‚ÑÇ} (N : ‚Ñï) (hN : N ‚â• 1)
    (hf : DifferentiableOn ‚Ñù f (Set.Icc 1 N))
    (hf' : ContinuousOn (deriv f) (Set.Icc 1 N)) :
    ‚Äñ(‚àë n ‚àà Finset.Icc 1 N, f n) - ‚à´ x in (1)..N, f x‚Äñ ‚â§
    ‚Äñf 1‚Äñ + ‚à´ x in (1)..N, ‚Äñderiv f x‚Äñ := by
  -- We use the identity: sum_{n=1}^N f(n) - int_1^N f(x) dx = f(1) + sum_{n=1}^{N-1} (f(n+1) - int_n^{n+1} f(x) dx).
  have h_identity : ‚àë n ‚àà Finset.Icc 1 N, f n - ‚à´ x in (1 : ‚Ñù)..N, f x = f 1 + ‚àë k ‚àà Finset.Icc 1 (N - 1), (f (k + 1) - ‚à´ x in (k : ‚Ñù).. (k + 1 : ‚Ñù), f x) := by
    induction hN;
    ¬∑ norm_num;
    ¬∑ rename_i k hk ih; specialize ih ( hf.mono <| Set.Icc_subset_Icc_right <| by norm_num ) ( hf'.mono <| Set.Icc_subset_Icc_right <| by norm_num ) ; simp_all +decide [ Finset.sum_Ioc_succ_top, Nat.Icc_succ_left ] ;
      have h_split : ‚à´ x in (1 : ‚Ñù)..k + 1, f x = (‚à´ x in (1 : ‚Ñù)..k, f x) + (‚à´ x in (k : ‚Ñù)..k + 1, f x) := by
        rw [ intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ ContinuousOn.intervalIntegrable, hf.continuousOn ];
        ¬∑ exact hf.continuousOn.mono ( by rw [ Set.uIcc_of_le ( by norm_cast ) ] ; exact Set.Icc_subset_Icc_right ( by norm_num ) );
        ¬∑ exact hf.continuousOn.mono ( by rw [ Set.uIcc_of_le ( by norm_num ) ] ; exact Set.Icc_subset_Icc ( by norm_cast ) le_rfl );
      cases k <;> norm_num [ Finset.sum_Ioc_succ_top ] at * ; linear_combination ih + h_split.symm;
  -- For each term in the sum, we have $|f(k+1) - \int_k^{k+1} f(x) dx| \leq \int_k^{k+1} |f'(x)| dx$.
  have h_term_bound : ‚àÄ k ‚àà Finset.Icc 1 (N - 1), ‚Äñf (k + 1) - ‚à´ x in (k : ‚Ñù).. (k + 1 : ‚Ñù), f x‚Äñ ‚â§ ‚à´ x in (k : ‚Ñù).. (k + 1 : ‚Ñù), ‚Äñderiv f x‚Äñ := by
    -- By the properties of the derivative, we have $f(k+1) - \int_k^{k+1} f(x) dx = \int_k^{k+1} (f(k+1) - f(x)) dx$.
    intro k hk
    have h_ftc : f (k + 1) - ‚à´ x in (k : ‚Ñù).. (k + 1 : ‚Ñù), f x = ‚à´ x in (k : ‚Ñù).. (k + 1 : ‚Ñù), (f (k + 1) - f x) := by
      rw [ intervalIntegral.integral_sub ] <;> norm_num;
      apply_rules [ ContinuousOn.intervalIntegrable ];
      exact hf.continuousOn.mono ( by rw [ Set.uIcc_of_le ( by linarith ) ] ; exact Set.Icc_subset_Icc ( by norm_cast; linarith [ Finset.mem_Icc.mp hk ] ) ( by norm_cast; linarith [ Finset.mem_Icc.mp hk, Nat.sub_add_cancel hN ] ) );
    -- By the properties of the derivative, we have $|f(k+1) - f(x)| \leq \int_x^{k+1} |f'(t)| dt$.
    have h_deriv_bound : ‚àÄ x ‚àà Set.Icc (k : ‚Ñù) (k + 1), ‚Äñf (k + 1) - f x‚Äñ ‚â§ ‚à´ t in (x : ‚Ñù).. (k + 1 : ‚Ñù), ‚Äñderiv f t‚Äñ := by
      intros x hx
      have h_deriv_bound : f (k + 1) - f x = ‚à´ t in (x : ‚Ñù).. (k + 1 : ‚Ñù), deriv f t := by
        rw [ intervalIntegral.integral_eq_sub_of_hasDeriv_right ];
        ¬∑ exact hf.continuousOn.mono ( by rw [ Set.uIcc_of_le ( by linarith [ hx.1, hx.2 ] ) ] ; exact Set.Icc_subset_Icc ( by linarith [ hx.1, hx.2, show ( k : ‚Ñù ) ‚â• 1 by norm_cast; linarith [ Finset.mem_Icc.mp hk ] ] ) ( by linarith [ hx.1, hx.2, show ( k : ‚Ñù ) + 1 ‚â§ N by norm_cast; linarith [ Finset.mem_Icc.mp hk, Nat.sub_add_cancel hN ] ] ) );
        ¬∑ intro y hy; exact DifferentiableAt.hasDerivAt ( hf.differentiableAt ( Icc_mem_nhds ( by cases min_cases x ( k + 1 ) <;> cases max_cases x ( k + 1 ) <;> linarith [ hy.1, hy.2, hx.1, hx.2, show ( k : ‚Ñù ) ‚â• 1 by norm_cast; linarith [ Finset.mem_Icc.mp hk ] ] ) ( by cases min_cases x ( k + 1 ) <;> cases max_cases x ( k + 1 ) <;> linarith [ hy.1, hy.2, hx.1, hx.2, show ( k : ‚Ñù ) + 1 ‚â§ N by norm_cast; linarith [ Finset.mem_Icc.mp hk, Nat.sub_add_cancel hN ] ] ) ) ) |> HasDerivAt.hasDerivWithinAt;
        ¬∑ apply_rules [ ContinuousOn.intervalIntegrable, hf' ];
          exact hf'.mono ( by rw [ Set.uIcc_of_le ( by linarith [ hx.1, hx.2 ] ) ] ; exact Set.Icc_subset_Icc ( by linarith [ hx.1, hx.2, show ( k : ‚Ñù ) ‚â• 1 by norm_cast; linarith [ Finset.mem_Icc.mp hk ] ] ) ( by linarith [ hx.1, hx.2, show ( k : ‚Ñù ) + 1 ‚â§ N by norm_cast; linarith [ Finset.mem_Icc.mp hk, Nat.sub_add_cancel hN ] ] ) );
      simpa only [ h_deriv_bound ] using by simpa only [ intervalIntegral.integral_of_le ( show x ‚â§ ( k : ‚Ñù ) + 1 by linarith [ hx.2 ] ) ] using MeasureTheory.norm_integral_le_integral_norm ( deriv f ) ;
    rw [ h_ftc, intervalIntegral.integral_of_le ] <;> norm_num;
    refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) ( le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ );
    refine' fun x => ‚à´ t in ( k : ‚Ñù ).. ( k + 1 : ‚Ñù ), ‚Äñderiv f t‚Äñ;
    ¬∑ exact Filter.Eventually.of_forall fun x => norm_nonneg _;
    ¬∑ norm_num;
    ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx;
      refine' le_trans ( h_deriv_bound x ‚ü® hx.1.le, hx.2 ‚ü© ) _;
      apply_rules [ intervalIntegral.integral_mono_interval, hx.1.le, hx.2 ];
      ¬∑ norm_num;
      ¬∑ exact Filter.Eventually.of_forall fun x => norm_nonneg _;
      ¬∑ apply_rules [ ContinuousOn.intervalIntegrable ];
        exact ContinuousOn.norm ( hf'.mono ( by rw [ Set.uIcc_of_le ( by linarith ) ] ; exact Set.Icc_subset_Icc ( by norm_cast; linarith [ Finset.mem_Icc.mp hk ] ) ( by norm_cast; linarith [ Finset.mem_Icc.mp hk, Nat.sub_add_cancel hN ] ) ) );
    ¬∑ norm_num [ intervalIntegral.integral_of_le ];
  -- Therefore, the sum of the terms is bounded by the integral of the absolute value of the derivative.
  have h_sum_bound : ‚àë k ‚àà Finset.Icc 1 (N - 1), ‚à´ x in (k : ‚Ñù).. (k + 1 : ‚Ñù), ‚Äñderiv f x‚Äñ = ‚à´ x in (1 : ‚Ñù)..N, ‚Äñderiv f x‚Äñ := by
    erw [ Finset.sum_Ico_eq_sum_range ];
    convert intervalIntegral.sum_integral_adjacent_intervals _ <;> norm_num [ add_comm, hN ];
    intro k hk; apply_rules [ ContinuousOn.intervalIntegrable ] ; norm_num [ add_comm, add_left_comm, add_assoc ];
    exact hf'.norm.mono ( Set.Icc_subset_Icc ( by norm_cast; linarith ) ( by norm_cast; linarith [ Nat.sub_add_cancel hN ] ) );
  exact h_identity.symm ‚ñ∏ norm_add_le_of_le ( by norm_num ) ( h_sum_bound ‚ñ∏ le_trans ( norm_sum_le _ _ ) ( Finset.sum_le_sum h_term_bound ) )

/-
The sequence c * sqrt(n) satisfies the Weyl Criterion for any non-zero c.
-/
open Filter Real Set Topology Complex

lemma weyl_criterion_sqrt (c : ‚Ñù) (hc : c ‚â† 0) :
    WeylCriterion (Œª n => c * Real.sqrt n) := by
  -- Let $g(x) = 2\pi h c \sqrt{x}$. We will show that $\frac{1}{N} \sum_{n=1}^{N} e^{i g(n)} \to 0$ as $N \to \infty$.
  intros h h_ne_zero
  have h_sum : Filter.Tendsto (fun N : ‚Ñï => (‚àë n ‚àà Finset.Icc 1 N, Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt n)) / (N : ‚ÑÇ)) Filter.atTop (nhds 0) := by
    -- The sum is over 0 to N-1. The bound is for 1 to N.
    have h_sum_bound : ‚àÄ N : ‚Ñï, N ‚â• 1 ‚Üí ‚Äñ(‚àë n ‚àà Finset.Icc 1 N, Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt n)) - ‚à´ x in (1 : ‚Ñù)..N, Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt x)‚Äñ ‚â§ 1 + ‚à´ x in (1 : ‚Ñù)..N, ‚Äñderiv (fun x => Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt x)) x‚Äñ := by
      intro N hN;
      have := @sum_sub_integral_norm_bound ( fun x => Complex.exp ( Complex.I * 2 * Real.pi * h * c * Real.sqrt x ) ) N hN;
      convert this _ _ using 2 <;> norm_num [ Complex.norm_exp ];
      ¬∑ exact DifferentiableOn.cexp ( DifferentiableOn.mul ( differentiableOn_const _ ) ( Complex.ofRealCLM.differentiable.comp_differentiableOn ( differentiableOn_id.sqrt fun x hx => ne_of_gt <| lt_of_lt_of_le zero_lt_one hx.1 ) ) );
      ¬∑ refine' ContinuousOn.congr _ _;
        use fun x => Complex.I * 2 * Real.pi * h * c * ( 1 / ( 2 * Real.sqrt x ) ) * Complex.exp ( Complex.I * 2 * Real.pi * h * c * Real.sqrt x );
        ¬∑ exact ContinuousOn.mul ( ContinuousOn.mul ( continuousOn_const ) ( continuousOn_const.div ( continuousOn_const.mul ( Complex.continuous_ofReal.comp_continuousOn ( Real.continuous_sqrt.continuousOn ) ) ) fun x hx => mul_ne_zero two_ne_zero <| Complex.ofReal_ne_zero.mpr <| ne_of_gt <| Real.sqrt_pos.mpr <| by linarith [ hx.1 ] ) ) <| Complex.continuous_exp.comp_continuousOn <| ContinuousOn.mul ( continuousOn_const ) <| Complex.continuous_ofReal.comp_continuousOn ( Real.continuous_sqrt.continuousOn );
        ¬∑ intro x hx; refine' HasDerivAt.deriv _ ; convert HasDerivAt.comp x ( Complex.hasDerivAt_exp _ ) ( HasDerivAt.const_mul _ <| HasDerivAt.ofReal_comp <| Real.hasDerivAt_sqrt <| by linarith [ hx.1 ] ) using 1 ; norm_num ; ring;
    -- The integral of the derivative's norm is bounded by $O(\sqrt{N})$.
    have h_integral_bound : ‚àÄ N : ‚Ñï, N ‚â• 1 ‚Üí ‚à´ x in (1 : ‚Ñù)..N, ‚Äñderiv (fun x => Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt x)) x‚Äñ ‚â§ 2 * |Real.pi * h * c| * Real.sqrt N := by
      -- The derivative of $e^{i g(x)}$ is $i g'(x) e^{i g(x)}$, and its norm is $|g'(x)|$.
      have h_deriv_norm : ‚àÄ x : ‚Ñù, x > 0 ‚Üí ‚Äñderiv (fun x => Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt x)) x‚Äñ = |Real.pi * h * c| / Real.sqrt x := by
        intro x hx; erw [ HasDerivAt.deriv ( by simpa using HasDerivAt.comp x ( Complex.hasDerivAt_exp _ ) <| HasDerivAt.const_mul ( Complex.I * 2 * Real.pi * h * c ) <| HasDerivAt.ofReal_comp <| Real.hasDerivAt_sqrt hx.ne' ) ] ; norm_num [ Complex.norm_exp, abs_mul, abs_div, abs_of_pos, hx ] ; ring;
      intro N hN; rw [ intervalIntegral.integral_congr fun x hx => h_deriv_norm x <| by linarith [ Set.mem_Icc.mp <| by simpa [ hN ] using hx ] ] ; norm_num [ division_def ] ; ring_nf ;
      rw [ intervalIntegral.integral_congr fun x hx => by rw [ Real.sqrt_eq_rpow, ‚Üê Real.rpow_neg ] ; linarith [ Set.mem_Icc.mp <| by simpa [ hN ] using hx ] ] ; norm_num [ Real.sqrt_eq_rpow, integral_rpow ] ; ring_nf ; norm_num;
      positivity;
    -- The integral of $e^{i g(x)}$ from 1 to N is bounded by $O(\sqrt{N})$.
    have h_integral_bound : Filter.Tendsto (fun N : ‚Ñï => (‚à´ x in (1 : ‚Ñù)..N, Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt x)) / (‚ÜëN : ‚ÑÇ)) Filter.atTop (nhds 0) := by
      have h_integral_bound : Filter.Tendsto (fun N : ‚Ñï => (‚à´ x in (0 : ‚Ñù)..N, Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt x)) / (‚ÜëN : ‚ÑÇ)) Filter.atTop (nhds 0) := by
        have := integral_exp_sqrt_bound ( 2 * Real.pi * h * c ) ( by norm_num [ Real.pi_ne_zero, h_ne_zero, hc ] );
        rw [ Asymptotics.isBigO_iff' ] at this;
        norm_num +zetaDelta at *;
        obtain ‚ü® C, hC‚ÇÄ, a, ha ‚ü© := this; refine' squeeze_zero_norm' _ _;
        use fun n => C * |Real.sqrt n| / n;
        ¬∑ simp_all +decide [ mul_assoc ];
          exact ‚ü® ‚åàa‚åâ‚Çä, fun n hn => by gcongr ; exact ha n <| Nat.le_of_ceil_le hn ‚ü©;
        ¬∑ norm_num [ abs_of_nonneg, Real.sqrt_nonneg ];
          simpa [ mul_div_assoc, Real.sqrt_div_self ] using tendsto_const_nhds.mul ( tendsto_inverse_atTop_nhds_zero_nat.sqrt );
      -- The integral from 0 to 1 is bounded, so we can split the integral into two parts.
      have h_split_integral : ‚àÄ N : ‚Ñï, N ‚â• 1 ‚Üí (‚à´ x in (0 : ‚Ñù)..N, Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt x)) = (‚à´ x in (0 : ‚Ñù)..1, Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt x)) + (‚à´ x in (1 : ‚Ñù)..N, Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt x)) := by
        intro N hN; rw [ intervalIntegral.integral_add_adjacent_intervals ] ; all_goals apply_rules [ Continuous.intervalIntegrable ] ; exact Complex.continuous_exp.comp <| by continuity;
      have h_split_integral : Filter.Tendsto (fun N : ‚Ñï => ((‚à´ x in (0 : ‚Ñù)..1, Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt x)) + (‚à´ x in (1 : ‚Ñù)..N, Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt x))) / (‚ÜëN : ‚ÑÇ)) Filter.atTop (nhds 0) := by
        exact h_integral_bound.congr' ( by filter_upwards [ Filter.eventually_ge_atTop 1 ] with N hN; rw [ h_split_integral N hN ] );
      convert h_split_integral.sub ( show Filter.Tendsto ( fun N : ‚Ñï => ( ‚à´ x in ( 0 : ‚Ñù )..1, Complex.exp ( Complex.I * 2 * Real.pi * h * c * Real.sqrt x ) ) / ( N : ‚ÑÇ ) ) Filter.atTop ( ùìù 0 ) from tendsto_zero_iff_norm_tendsto_zero.mpr <| by simpa using tendsto_const_nhds.mul tendsto_inverse_atTop_nhds_zero_nat ) using 2 <;> ring;
    -- Using the bounds, we can show that the difference between the sum and the integral divided by N tends to zero.
    have h_diff_zero : Filter.Tendsto (fun N : ‚Ñï => ((‚àë n ‚àà Finset.Icc 1 N, Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt n)) - ‚à´ x in (1 : ‚Ñù)..N, Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt x)) / (‚ÜëN : ‚ÑÇ)) Filter.atTop (nhds 0) := by
      have h_diff_zero : Filter.Tendsto (fun N : ‚Ñï => (1 + 2 * |Real.pi * h * c| * Real.sqrt N) / (‚ÜëN : ‚Ñù)) Filter.atTop (nhds 0) := by
        norm_num [ add_div ];
        norm_num [ mul_div_assoc, Real.sqrt_div_self ];
        simpa using Filter.Tendsto.add ( tendsto_inverse_atTop_nhds_zero_nat ) ( tendsto_const_nhds.mul ( tendsto_inverse_atTop_nhds_zero_nat.sqrt ) );
      refine' squeeze_zero_norm' _ h_diff_zero;
      simp +zetaDelta at *;
      exact ‚ü® 1, fun N hN => by rw [ div_le_div_iff_of_pos_right ( by positivity ) ] ; exact le_trans ( h_sum_bound N hN ) ( add_le_add_left ( h_integral_bound N hN ) _ ) ‚ü©;
    convert h_diff_zero.add h_integral_bound using 2 <;> ring;
  have h_sum_zero : Filter.Tendsto (fun N : ‚Ñï => (‚àë n ‚àà Finset.range N, Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt n)) / (N : ‚ÑÇ)) Filter.atTop (nhds 0) := by
    have : ‚àÄ N : ‚Ñï, (‚àë n ‚àà Finset.range N, Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt n)) = (‚àë n ‚àà Finset.Icc 1 N, Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt n)) - Complex.exp (I * 2 * Real.pi * h * c * Real.sqrt N) + 1 := by
      intro N; erw [ Finset.sum_Ico_eq_sub _ _ ] <;> norm_num [ Finset.sum_range_succ ] ;
      ring
    simp_all +decide [ sub_div, add_div ];
    simpa using Filter.Tendsto.add ( Filter.Tendsto.sub h_sum ( tendsto_zero_iff_norm_tendsto_zero.mpr <| by simpa [ Complex.norm_exp ] using tendsto_inverse_atTop_nhds_zero_nat ) ) ( tendsto_zero_iff_norm_tendsto_zero.mpr <| by simpa [ Complex.norm_exp ] using tendsto_inverse_atTop_nhds_zero_nat );
  convert h_sum_zero using 3 ; push_cast ; ring

#check UnitAddCircle

/-
If u satisfies Weyl Criterion, then for any trigonometric polynomial P, the average of P(u_n) converges to the integral of P.
-/
open Filter Real Set Topology Complex

lemma weyl_criterion_implies_tendsto_trig_poly (u : ‚Ñï ‚Üí ‚Ñù) (hu : WeylCriterion u)
    (P : ‚Ñù ‚Üí ‚ÑÇ) (hP : ‚àÉ (s : Finset ‚Ñ§) (c : ‚Ñ§ ‚Üí ‚ÑÇ), ‚àÄ x, P x = ‚àë k ‚àà s, c k * exp (2 * œÄ * I * k * x)) :
    Tendsto (Œª N => (‚àë n ‚àà Finset.range N, P (u n)) / N) atTop (ùìù (‚à´ x in (0)..1, P x)) := by
  obtain ‚ü® s, c, hP ‚ü© := hP;
  have h_trig_poly : ‚àÄ k : ‚Ñ§, k ‚â† 0 ‚Üí Filter.Tendsto (fun N => (‚àë n ‚àà Finset.range N, Complex.exp (2 * Real.pi * Complex.I * k * u n)) / N) Filter.atTop (ùìù 0) := by
    exact?;
  -- The integral of a trigonometric polynomial over [0, 1] is the sum of the integrals of its terms.
  have h_integral_trig_poly : ‚à´ x in (0)..1, P x = ‚àë k ‚àà s, c k * ‚à´ x in (0)..1, Complex.exp (2 * Real.pi * Complex.I * k * x) := by
    simp +decide only [hP, ‚Üê intervalIntegral.integral_const_mul];
    rw [ intervalIntegral.integral_finset_sum ] ; exact fun _ _ => Continuous.intervalIntegrable ( by continuity ) _ _;
  -- The integral of $e^{2\pi i k x}$ over $[0, 1]$ is $0$ for $k \neq 0$ and $1$ for $k = 0$.
  have h_integral_exp : ‚àÄ k : ‚Ñ§, k ‚â† 0 ‚Üí ‚à´ x in (0)..1, Complex.exp (2 * Real.pi * Complex.I * k * x) = 0 := by
    intro k hk_ne; have := @integral_exp_mul_complex 0 1; simp_all +decide [ Complex.exp_ne_zero, mul_assoc, mul_left_comm, mul_comm Complex.I ] ;
    convert this ( show ( Real.pi : ‚ÑÇ ) * ( k * ( 2 * Complex.I ) ) ‚â† 0 by norm_num [ Complex.ext_iff, Real.pi_ne_zero, hk_ne ] ) using 1 <;> norm_num [ mul_assoc, mul_comm, mul_left_comm ];
    exact Eq.symm ( div_eq_zero_iff.mpr <| Or.inl <| sub_eq_zero.mpr <| Complex.exp_eq_one_iff.mpr ‚ü® k, by ring ‚ü© );
  -- The average of $P(u_n)$ converges to the integral of $P$ because the average of each term converges to the integral of that term.
  have h_avg_trig_poly : Filter.Tendsto (fun N => (‚àë k ‚àà s, c k * (‚àë n ‚àà Finset.range N, Complex.exp (2 * Real.pi * Complex.I * k * u n)) / N)) Filter.atTop (ùìù (‚àë k ‚àà s, c k * ‚à´ x in (0)..1, Complex.exp (2 * Real.pi * Complex.I * k * x))) := by
    refine' tendsto_finset_sum _ fun k hk => _;
    by_cases hk0 : k = 0 <;> simp_all +decide [ mul_div_assoc ];
    ¬∑ exact tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_ne_atTop 0 ] with N hN; simp +decide [ hN ] );
    ¬∑ simpa using tendsto_const_nhds.mul ( h_trig_poly k hk0 );
  convert h_avg_trig_poly using 2 ; push_cast [ hP ] ; ring;
  rw [ Finset.sum_comm ] ; simp +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ]