/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 32210dc4-3139-4cbd-91c5-922da21ae3d1
-/

/-
We formalized Polya-Szego Problem 100, which states that for continuous functions f and œÜ on [a, b], the generalized Riemann sum Œ£ f(y_ŒΩ)œÜ(Œ∑_ŒΩ)Œîx_ŒΩ converges to ‚à´ f(x)œÜ(x) dx as the mesh size tends to 0. We proved this by decomposing the sum into a standard Riemann sum for fœÜ and a difference term involving the oscillation of œÜ, showing both converge appropriately.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check MeasureTheory.volume
#check Filter.Tendsto

#check nhds
#check nhdsWithin

open MeasureTheory Filter Topology

#check Set.Icc
#check Set.Ioi

#check StrictMono

#check Fin.last
#check Fin.castSucc
#check Fin.succ

#check intervalIntegral
#check Set.Icc

open Set Filter MeasureTheory Metric Finset

structure TaggedPartition2 (a b : ‚Ñù) where
  n : ‚Ñï
  xs : Fin (n + 1) ‚Üí ‚Ñù
  ys : Fin n ‚Üí ‚Ñù
  etas : Fin n ‚Üí ‚Ñù
  h_xs_0 : xs 0 = a
  h_xs_n : xs (Fin.last n) = b
  h_xs_mono : StrictMono xs
  h_ys : ‚àÄ i, ys i ‚àà Icc (xs (Fin.castSucc i)) (xs (Fin.succ i))
  h_etas : ‚àÄ i, etas i ‚àà Icc (xs (Fin.castSucc i)) (xs (Fin.succ i))

def meshSize {a b : ‚Ñù} (P : TaggedPartition2 a b) : ‚Ñù :=
  (Finset.image (fun i : Fin P.n => P.xs (Fin.succ i) - P.xs (Fin.castSucc i)) Finset.univ).max.getD 0

def riemannSum {a b : ‚Ñù} (P : TaggedPartition2 a b) (f œÜ : ‚Ñù ‚Üí ‚Ñù) : ‚Ñù :=
  ‚àë i : Fin P.n, f (P.ys i) * œÜ (P.etas i) * (P.xs (Fin.succ i) - P.xs (Fin.castSucc i))

def atMeshZero (a b : ‚Ñù) : Filter (TaggedPartition2 a b) :=
  Filter.comap meshSize (nhdsWithin 0 (Ioi 0))

/-
The integral of a continuous function g over [a, b] is equal to the sum of its integrals over the subintervals defined by a tagged partition P.
-/
lemma integral_eq_sum_integral_partition {a b : ‚Ñù} (hab : a < b) (P : TaggedPartition2 a b)
    {g : ‚Ñù ‚Üí ‚Ñù} (hg : ContinuousOn g (Icc a b)) :
    intervalIntegral g a b volume = ‚àë i : Fin P.n, intervalIntegral g (P.xs (Fin.castSucc i)) (P.xs (Fin.succ i)) volume := by
      have h_partition : a = P.xs 0 ‚àß P.xs (Fin.last P.n) = b := by
        exact ‚ü® P.h_xs_0.symm, P.h_xs_n ‚ü©;
      have h_partition : ‚àÄ (n : ‚Ñï) (xs : Fin (n + 1) ‚Üí ‚Ñù), StrictMono xs ‚Üí ‚àÄ (g : ‚Ñù ‚Üí ‚Ñù), ContinuousOn g (Set.Icc (xs 0) (xs (Fin.last n))) ‚Üí intervalIntegral g (xs 0) (xs (Fin.last n)) MeasureTheory.MeasureSpace.volume = ‚àë i : Fin n, intervalIntegral g (xs i.castSucc) (xs i.succ) MeasureTheory.MeasureSpace.volume := by
        intros n xs hxs g hg;
        induction' n with n ih;
        ¬∑ norm_num [ intervalIntegral ];
        ¬∑ have := ih ( fun i => xs i.castSucc ) ( fun i j hij => hxs ( by simpa using hij ) ) ( hg.mono ( Set.Icc_subset_Icc le_rfl ( hxs.monotone ( Fin.le_last _ ) ) ) ) ; simp_all +decide [ Fin.sum_univ_castSucc ] ;
          rw [ ‚Üê this, intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ ContinuousOn.intervalIntegrable, hg.mono, Set.Icc_subset_Icc ] <;> norm_num [ hxs.le_iff_le ];
          ¬∑ exact Nat.le_succ _;
          ¬∑ exact Nat.le_succ _;
      specialize h_partition P.n P.xs P.h_xs_mono g ; aesop

/-
If the oscillation of g on each subinterval of a partition P is bounded by Œµ, then the error of the Riemann sum is bounded by Œµ * (b - a).
-/
lemma riemann_sum_bound_of_bound {a b : ‚Ñù} (hab : a < b) (P : TaggedPartition2 a b)
    {g : ‚Ñù ‚Üí ‚Ñù} (hg : ContinuousOn g (Icc a b)) {Œµ : ‚Ñù} (hŒµ : 0 ‚â§ Œµ)
    (h_bound : ‚àÄ i : Fin P.n, ‚àÄ x ‚àà Icc (P.xs (Fin.castSucc i)) (P.xs (Fin.succ i)), |g x - g (P.ys i)| ‚â§ Œµ) :
    |riemannSum P g (fun _ => 1) - intervalIntegral g a b volume| ‚â§ Œµ * (b - a) := by
      -- Apply the bound on the oscillation to each subinterval.
      have h_subinterval : ‚àÄ i : Fin P.n, |(intervalIntegral g (P.xs (Fin.castSucc i)) (P.xs (Fin.succ i)) MeasureTheory.MeasureSpace.volume) - (g (P.ys i) * (P.xs (Fin.succ i) - P.xs (Fin.castSucc i)))| ‚â§ Œµ * (P.xs (Fin.succ i) - P.xs (Fin.castSucc i)) := by
        intro i;
        have h_subinterval : |‚à´ x in (P.xs (Fin.castSucc i))..(P.xs (Fin.succ i)), g x - g (P.ys i)| ‚â§ Œµ * (P.xs (Fin.succ i) - P.xs (Fin.castSucc i)) := by
          rw [ intervalIntegral.integral_of_le ( P.h_xs_mono.monotone ( Nat.le_succ _ ) ) ];
          refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ‚Ñù ‚Üí ‚Ñù ) ) ( le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ );
          exacts [ fun _ => Œµ, Filter.Eventually.of_forall fun _ => norm_nonneg _, Continuous.integrableOn_Ioc ( by continuity ), Filter.eventually_of_mem ( MeasureTheory.ae_restrict_mem measurableSet_Ioc ) fun x hx => h_bound i x <| Set.Ioc_subset_Icc_self hx, by simp +decide [ mul_comm, le_of_lt ( show P.xs i.castSucc < P.xs i.succ from P.h_xs_mono <| Fin.castSucc_lt_succ i ) ] ];
        rw [ intervalIntegral.integral_sub ] at h_subinterval <;> norm_num at *;
        ¬∑ simpa only [ mul_comm ] using h_subinterval;
        ¬∑ apply_rules [ ContinuousOn.intervalIntegrable, hg ];
          exact hg.mono ( by rw [ Set.uIcc_of_le ( by simpa using P.h_xs_mono.monotone ( Nat.le_succ _ ) ) ] ; exact Set.Icc_subset_Icc ( by linarith [ P.h_xs_0, P.h_xs_mono.monotone ( show 0 ‚â§ Fin.castSucc i from Nat.zero_le _ ) ] ) ( by linarith [ P.h_xs_n, P.h_xs_mono.monotone ( show Fin.succ i ‚â§ Fin.last P.n from Fin.le_last _ ) ] ) );
      -- Combine the subinterval bounds to get the total bound.
      have h_total_bound : |(intervalIntegral g a b MeasureTheory.MeasureSpace.volume) - (‚àë i : Fin P.n, g (P.ys i) * (P.xs (Fin.succ i) - P.xs (Fin.castSucc i)))| ‚â§ Œµ * (b - a) := by
        convert le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( Finset.sum_le_sum fun i _ => h_subinterval i ) using 1;
        rw [ Finset.sum_sub_distrib, integral_eq_sum_integral_partition hab P hg ];
        rw [ ‚Üê Finset.mul_sum _ _ _, show b - a = ‚àë i : Fin P.n, ( P.xs i.succ - P.xs i.castSucc ) from ?_ ];
        have := Fin.sum_univ_succ fun i => P.xs i; norm_num [ Fin.sum_univ_castSucc ] at *; linarith [ P.h_xs_0, P.h_xs_n ] ;
      simpa [ abs_sub_comm, riemannSum ] using h_total_bound

/-
If the oscillation of g on each subinterval of a partition P is bounded by Œµ, then the error of the Riemann sum is bounded by Œµ * (b - a).
-/
lemma riemann_sum_bound_of_bound' {a b : ‚Ñù} (hab : a < b) (P : TaggedPartition2 a b)
    {g : ‚Ñù ‚Üí ‚Ñù} (hg : ContinuousOn g (Icc a b)) {Œµ : ‚Ñù} (hŒµ : 0 ‚â§ Œµ)
    (h_bound : ‚àÄ i : Fin P.n, ‚àÄ x ‚àà Icc (P.xs (Fin.castSucc i)) (P.xs (Fin.succ i)), |g x - g (P.ys i)| ‚â§ Œµ) :
    |riemannSum P g (fun _ => 1) - intervalIntegral g a b volume| ‚â§ Œµ * (b - a) := by
      exact?

/-
If the oscillation of g on each subinterval of a partition P is bounded by Œµ, then the error of the Riemann sum is bounded by Œµ * (b - a).
-/
lemma riemann_sum_bound_of_bound_v2 {a b : ‚Ñù} (hab : a < b) (P : TaggedPartition2 a b)
    {g : ‚Ñù ‚Üí ‚Ñù} (hg : ContinuousOn g (Icc a b)) {Œµ : ‚Ñù} (hŒµ : 0 ‚â§ Œµ)
    (h_bound : ‚àÄ i : Fin P.n, ‚àÄ x ‚àà Icc (P.xs (Fin.castSucc i)) (P.xs (Fin.succ i)), |g x - g (P.ys i)| ‚â§ Œµ) :
    |riemannSum P g (fun _ => 1) - intervalIntegral g a b volume| ‚â§ Œµ * (b - a) := by
      exact?

/-
The sum of the lengths of the subintervals of a tagged partition of [a, b] is equal to b - a.
-/
lemma sum_deltas_eq_sub {a b : ‚Ñù} (P : TaggedPartition2 a b) :
    ‚àë i : Fin P.n, (P.xs (Fin.succ i) - P.xs (Fin.castSucc i)) = b - a := by
      -- The sum of differences `x_{i+1} - x_i` is a telescoping sum, which equals `x_n - x_0`.
      have h_telescope : ‚àë x_1 : Fin P.n, P.xs x_1.succ - ‚àë x_1 : Fin P.n, P.xs x_1.castSucc = P.xs (Fin.last P.n) - P.xs 0 := by
        have := Fin.sum_univ_castSucc P.xs; have := Fin.sum_univ_succ P.xs; simp_all +decide [ Fin.sum_univ_succ ] ; linarith;
      simp +zetaDelta at *;
      rw [ h_telescope, P.h_xs_n, P.h_xs_0 ]

#check sum_deltas_eq_sub

/-
If the oscillation of g on each subinterval of a partition P is bounded by Œµ, then the error of the Riemann sum is bounded by Œµ * (b - a).
-/
lemma riemann_sum_bound_of_bound_v3 {a b : ‚Ñù} (hab : a < b) (P : TaggedPartition2 a b)
    {g : ‚Ñù ‚Üí ‚Ñù} (hg : ContinuousOn g (Icc a b)) {Œµ : ‚Ñù} (hŒµ : 0 ‚â§ Œµ)
    (h_bound : ‚àÄ i : Fin P.n, ‚àÄ x ‚àà Icc (P.xs (Fin.castSucc i)) (P.xs (Fin.succ i)), |g x - g (P.ys i)| ‚â§ Œµ) :
    |riemannSum P g (fun _ => 1) - intervalIntegral g a b volume| ‚â§ Œµ * (b - a) := by
  have h_sum_deltas := sum_deltas_eq_sub P
  -- Apply the previously proven lemmas to conclude the proof.
  have := riemann_sum_bound_of_bound' hab P hg hŒµ h_bound;
  exact this

/-
The Riemann sum of a continuous function g (with œÜ=1) converges to the integral of g.
-/
lemma riemann_sum_convergence_aux {a b : ‚Ñù} (hab : a < b) {g : ‚Ñù ‚Üí ‚Ñù} (hg : ContinuousOn g (Icc a b)) :
    Tendsto (fun P : TaggedPartition2 a b => riemannSum P g (fun _ => 1))
    (atMeshZero a b) (ùìù (intervalIntegral g a b volume)) := by
      -- Since `g` is continuous on `[a, b]`, it is uniformly continuous.
      have h_unif : UniformContinuousOn g (Set.Icc a b) := by
        exact ( isCompact_Icc.uniformContinuousOn_of_continuous hg );
      -- For any `Œµ > 0`, choose `Œ¥ > 0` such that `|x - y| < Œ¥` implies `|g(x) - g(y)| < Œµ / (b - a)`.
      have h_eps_delta : ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ P : TaggedPartition2 a b, meshSize P < Œ¥ ‚Üí |riemannSum P g (fun _ => 1) - intervalIntegral g a b volume| ‚â§ Œµ := by
        intro Œµ hŒµ_pos
        obtain ‚ü®Œ¥, hŒ¥_pos, hŒ¥‚ü© : ‚àÉ Œ¥ > 0, ‚àÄ x y : ‚Ñù, x ‚àà Set.Icc a b ‚Üí y ‚àà Set.Icc a b ‚Üí |x - y| < Œ¥ ‚Üí |g x - g y| < Œµ / (b - a) := by
          exact Metric.uniformContinuousOn_iff.mp h_unif ( Œµ / ( b - a ) ) ( div_pos hŒµ_pos ( sub_pos.mpr hab ) ) |> Exists.imp fun Œ¥ hŒ¥ => by tauto;
        refine' ‚ü® Œ¥, hŒ¥_pos, fun P hP => _ ‚ü©;
        refine' le_trans ( riemann_sum_bound_of_bound_v3 hab P hg ( div_nonneg hŒµ_pos.le ( sub_nonneg.mpr hab.le ) ) _ ) _;
        ¬∑ intro i x hx;
          refine' le_of_lt ( hŒ¥ x ( P.ys i ) _ _ _ );
          ¬∑ constructor <;> linarith [ hx.1, hx.2, P.h_xs_0, P.h_xs_n, P.h_xs_mono.monotone ( show 0 ‚â§ Fin.castSucc i from Nat.zero_le _ ), P.h_xs_mono.monotone ( show Fin.castSucc i ‚â§ Fin.last P.n from Fin.le_last _ ), P.h_xs_mono.monotone ( show Fin.succ i ‚â§ Fin.last P.n from Fin.le_last _ ) ];
          ¬∑ exact ‚ü® by linarith [ hx.1, hx.2, P.h_xs_0, P.h_xs_n, P.h_ys i |>.1, P.h_ys i |>.2, P.h_xs_mono.monotone ( show 0 ‚â§ Fin.castSucc i from Nat.zero_le _ ) ], by linarith [ hx.1, hx.2, P.h_xs_0, P.h_xs_n, P.h_ys i |>.1, P.h_ys i |>.2, P.h_xs_mono.monotone ( show Fin.succ i ‚â§ Fin.last P.n from Fin.le_last _ ) ] ‚ü©;
          ¬∑ have h_mesh : ‚àÄ i : Fin P.n, P.xs (Fin.succ i) - P.xs (Fin.castSucc i) < Œ¥ := by
              intro i; exact (by
              contrapose! hP;
              unfold meshSize;
              have h_mesh : Œ¥ ‚â§ Finset.max (Finset.image (fun i : Fin P.n => P.xs (Fin.succ i) - P.xs (Fin.castSucc i)) Finset.univ) := by
                exact le_trans ( WithBot.coe_le_coe.mpr hP ) ( Finset.le_max ( Finset.mem_image_of_mem _ ( Finset.mem_univ _ ) ) );
              cases h : Finset.max ( Finset.image ( fun i : Fin P.n => P.xs i.succ - P.xs i.castSucc ) Finset.univ ) <;> aesop);
            exact abs_lt.mpr ‚ü® by linarith [ hx.1, hx.2, P.h_ys i |>.1, P.h_ys i |>.2, h_mesh i ], by linarith [ hx.1, hx.2, P.h_ys i |>.1, P.h_ys i |>.2, h_mesh i ] ‚ü©;
        ¬∑ rw [ div_mul_cancel‚ÇÄ _ ( sub_ne_zero_of_ne hab.ne' ) ];
      intro Œµ hŒµ;
      rcases Metric.mem_nhds_iff.mp hŒµ with ‚ü® Œ¥, Œ¥_pos, hŒ¥ ‚ü©;
      rcases h_eps_delta ( Œ¥ / 2 ) ( half_pos Œ¥_pos ) with ‚ü® Œ¥', Œ¥'_pos, H ‚ü© ; refine' Filter.mem_of_superset ( Filter.mem_comap.mpr _ ) _;
      exact?;
      ¬∑ refine' ‚ü® Set.Ioo 0 Œ¥', Ioo_mem_nhdsGT Œ¥'_pos, fun P hP => hŒ¥ <| mem_ball_iff_norm.mpr <| lt_of_le_of_lt ( H P hP.2 ) <| half_lt_self Œ¥_pos ‚ü©;
      ¬∑ tauto

/-
For a continuous function g on [a, b] and Œµ > 0, there exists a Œ¥ > 0 such that for any partition with mesh size < Œ¥, the oscillation of g on each subinterval is ‚â§ Œµ.
-/
lemma oscillation_bound_of_mesh_size {a b : ‚Ñù} (hab : a < b) {g : ‚Ñù ‚Üí ‚Ñù} (hg : ContinuousOn g (Icc a b)) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :
    ‚àÉ Œ¥ > 0, ‚àÄ P : TaggedPartition2 a b, meshSize P < Œ¥ ‚Üí
    ‚àÄ i : Fin P.n, ‚àÄ x ‚àà Icc (P.xs (Fin.castSucc i)) (P.xs (Fin.succ i)), |g x - g (P.ys i)| ‚â§ Œµ := by
      simp +zetaDelta at *;
      obtain ‚ü® Œ¥, hŒ¥, H ‚ü© := Metric.uniformContinuousOn_iff.mp ( isCompact_Icc.uniformContinuousOn_of_continuous hg ) Œµ hŒµ;
      refine' ‚ü® Œ¥, hŒ¥, fun P hP i x hx‚ÇÅ hx‚ÇÇ => le_of_lt ( H x _ ( P.ys i ) _ _ ) ‚ü©;
      ¬∑ constructor <;> linarith [ P.h_xs_0, P.h_xs_n, P.h_xs_mono.monotone ( show 0 ‚â§ Fin.castSucc i from Nat.zero_le _ ), P.h_xs_mono.monotone ( show Fin.castSucc i ‚â§ Fin.last P.n from Fin.le_last _ ), P.h_xs_mono.monotone ( show Fin.succ i ‚â§ Fin.last P.n from Fin.le_last _ ) ];
      ¬∑ constructor <;> linarith [ P.h_ys i |>.1, P.h_ys i |>.2, P.h_xs_0, P.h_xs_n, P.h_xs_mono.monotone ( show 0 ‚â§ Fin.castSucc i from Nat.zero_le _ ), P.h_xs_mono.monotone ( show Fin.castSucc i ‚â§ Fin.last P.n from Fin.le_last _ ), P.h_xs_mono.monotone ( show Fin.succ i ‚â§ Fin.last P.n from Fin.le_last _ ) ];
      ¬∑ have h_dist : |P.xs i.succ - P.xs i.castSucc| < Œ¥ := by
          have h_dist : P.xs i.succ - P.xs i.castSucc ‚â§ meshSize P := by
            unfold meshSize;
            have h_dist : P.xs i.succ - P.xs i.castSucc ‚àà Finset.image (fun i : Fin P.n => P.xs i.succ - P.xs i.castSucc) Finset.univ := by
              aesop;
            have := Finset.le_max h_dist;
            cases h : Finset.max ( Finset.image ( fun i : Fin P.n => P.xs i.succ - P.xs i.castSucc ) Finset.univ ) <;> aesop;
          exact abs_lt.mpr ‚ü® by linarith [ show P.xs i.succ ‚â• P.xs i.castSucc from P.h_xs_mono.monotone ( Nat.le_succ _ ) ], by linarith [ show P.xs i.succ ‚â• P.xs i.castSucc from P.h_xs_mono.monotone ( Nat.le_succ _ ) ] ‚ü©;
        exact abs_lt.mpr ‚ü® by linarith [ abs_lt.mp h_dist, P.h_ys i |>.1, P.h_ys i |>.2 ], by linarith [ abs_lt.mp h_dist, P.h_ys i |>.1, P.h_ys i |>.2 ] ‚ü©

/-
The difference between the generalized Riemann sum (with different evaluation points for f and œÜ) and the standard Riemann sum (with same evaluation points) tends to 0 as mesh size tends to 0.
-/
lemma riemann_sum_diff_convergence {a b : ‚Ñù} (hab : a < b)
    {f œÜ : ‚Ñù ‚Üí ‚Ñù} (hf : ContinuousOn f (Icc a b)) (hœÜ : ContinuousOn œÜ (Icc a b)) :
    Tendsto (fun P : TaggedPartition2 a b => riemannSum P f œÜ - riemannSum P (fun x => f x * œÜ x) (fun _ => 1))
    (atMeshZero a b) (ùìù 0) := by
      rw [ Metric.tendsto_nhds ];
      intro Œµ hŒµ;
      -- Since $\varphi$ is uniformly continuous, for small mesh size, $|\varphi(\eta_i) - \varphi(y_i)| < \epsilon'$.
      obtain ‚ü®Œ¥, hŒ¥_pos, hŒ¥‚ü© : ‚àÉ Œ¥ > 0, ‚àÄ x y : ‚Ñù, x ‚àà Set.Icc a b ‚Üí y ‚àà Set.Icc a b ‚Üí |x - y| < Œ¥ ‚Üí |œÜ x - œÜ y| < Œµ / (2 * (|b - a| + 1) * (SupSet.sSup (Set.image (fun x => |f x|) (Set.Icc a b)) + 1)) := by
        have := Metric.uniformContinuousOn_iff.mp ( isCompact_Icc.uniformContinuousOn_of_continuous hœÜ ) ( Œµ / ( 2 * ( |b - a| + 1 ) * ( SupSet.sSup ( ( fun x => |f x| ) '' Set.Icc a b ) + 1 ) ) ) ( by exact div_pos hŒµ ( by exact mul_pos ( mul_pos two_pos ( by positivity ) ) ( by exact add_pos_of_nonneg_of_pos ( by apply_rules [ Real.sSup_nonneg ] ; aesop ) zero_lt_one ) ) ) ; aesop;
      -- For any partition P with mesh size less than Œ¥, the difference between the generalized Riemann sum and the standard Riemann sum is bounded by Œµ.
      have h_bound : ‚àÄ P : TaggedPartition2 a b, meshSize P < Œ¥ ‚Üí |riemannSum P f œÜ - riemannSum P (fun x => f x * œÜ x) (fun _ => 1)| ‚â§ (SupSet.sSup (Set.image (fun x => |f x|) (Set.Icc a b))) * (Œµ / (2 * (|b - a| + 1) * (SupSet.sSup (Set.image (fun x => |f x|) (Set.Icc a b)) + 1))) * (b - a) := by
        intros P hP
        have h_diff : ‚àÄ i : Fin P.n, |f (P.ys i) * (œÜ (P.etas i) - œÜ (P.ys i)) * (P.xs (Fin.succ i) - P.xs (Fin.castSucc i))| ‚â§ (SupSet.sSup (Set.image (fun x => |f x|) (Set.Icc a b))) * (Œµ / (2 * (|b - a| + 1) * (SupSet.sSup (Set.image (fun x => |f x|) (Set.Icc a b)) + 1))) * (P.xs (Fin.succ i) - P.xs (Fin.castSucc i)) := by
          intros i
          have h_diff_i : |œÜ (P.etas i) - œÜ (P.ys i)| < Œµ / (2 * (|b - a| + 1) * (SupSet.sSup (Set.image (fun x => |f x|) (Set.Icc a b)) + 1)) := by
            apply hŒ¥;
            ¬∑ have := P.h_etas i;
              constructor <;> linarith [ this.1, this.2, P.h_xs_0, P.h_xs_n, P.h_xs_mono.monotone ( show 0 ‚â§ Fin.castSucc i from Nat.zero_le _ ), P.h_xs_mono.monotone ( show Fin.castSucc i ‚â§ Fin.last P.n from Fin.le_last _ ), P.h_xs_mono.monotone ( show Fin.succ i ‚â§ Fin.last P.n from Fin.le_last _ ) ];
            ¬∑ have := P.h_ys i;
              exact ‚ü® by linarith [ this.1, P.h_xs_0, P.h_xs_mono.monotone ( show 0 ‚â§ Fin.castSucc i from Nat.zero_le _ ) ], by linarith [ this.2, P.h_xs_n, P.h_xs_mono.monotone ( show Fin.succ i ‚â§ Fin.last P.n from Fin.le_last _ ) ] ‚ü©;
            ¬∑ refine' lt_of_le_of_lt _ hP;
              unfold meshSize;
              have h_diff_i : P.etas i ‚àà Set.Icc (P.xs (Fin.castSucc i)) (P.xs (Fin.succ i)) ‚àß P.ys i ‚àà Set.Icc (P.xs (Fin.castSucc i)) (P.xs (Fin.succ i)) := by
                exact ‚ü® P.h_etas i, P.h_ys i ‚ü©;
              have h_diff_i : P.xs (Fin.succ i) - P.xs (Fin.castSucc i) ‚â§ Option.getD (Finset.image (fun i : Fin P.n => P.xs (Fin.succ i) - P.xs (Fin.castSucc i)) Finset.univ).max 0 := by
                have h_diff_i : P.xs (Fin.succ i) - P.xs (Fin.castSucc i) ‚àà Finset.image (fun i : Fin P.n => P.xs (Fin.succ i) - P.xs (Fin.castSucc i)) Finset.univ := by
                  exact Finset.mem_image_of_mem _ ( Finset.mem_univ _ );
                have := Finset.le_max h_diff_i;
                cases h : Finset.max ( Finset.image ( fun i : Fin P.n => P.xs i.succ - P.xs i.castSucc ) Finset.univ ) <;> aesop;
              exact abs_sub_le_iff.mpr ‚ü® by linarith [ Set.mem_Icc.mp ( And.left ‚Äπ_‚Ä∫ ), Set.mem_Icc.mp ( And.right ‚Äπ_‚Ä∫ ) ], by linarith [ Set.mem_Icc.mp ( And.left ‚Äπ_‚Ä∫ ), Set.mem_Icc.mp ( And.right ‚Äπ_‚Ä∫ ) ] ‚ü©;
          rw [ abs_mul, abs_mul, abs_of_nonneg ( sub_nonneg.mpr <| P.h_xs_mono.monotone <| Nat.le_succ _ ) ];
          gcongr;
          ¬∑ exact sub_nonneg_of_le <| P.h_xs_mono.monotone <| Nat.le_succ _;
          ¬∑ apply_rules [ Real.sSup_nonneg ] ; aesop;
          ¬∑ exact le_csSup ( by exact ( isCompact_Icc.image_of_continuousOn ( hf.abs ) ) |> IsCompact.bddAbove ) ( Set.mem_image_of_mem _ <| by constructor <;> linarith [ Set.mem_Icc.mp <| P.h_ys i, Set.mem_Icc.mp <| P.h_etas i, P.h_xs_0, P.h_xs_n, P.h_xs_mono.monotone <| Fin.zero_le <| Fin.castSucc i, P.h_xs_mono.monotone <| Fin.le_last <| Fin.castSucc i, P.h_xs_mono.monotone <| Fin.zero_le <| Fin.succ i, P.h_xs_mono.monotone <| Fin.le_last <| Fin.succ i ] );
        convert Finset.abs_sum_le_sum_abs _ _ |> le_trans <| Finset.sum_le_sum fun i _ => h_diff i using 1;
        any_goals exact Finset.univ;
        ¬∑ simp +decide [ mul_sub, sub_mul, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul, riemannSum ];
        ¬∑ rw [ ‚Üê Finset.mul_sum _ _ _, sum_deltas_eq_sub ];
      -- Since $M = \sup_{x \in [a, b]} |f(x)|$, we have $M \geq 0$.
      set M := SupSet.sSup (Set.image (fun x => |f x|) (Set.Icc a b)) with hM;
      -- Since $M \geq 0$, we have $M * (Œµ / (2 * (|b - a| + 1) * (M + 1))) * (b - a) < Œµ$.
      have h_final_bound : M * (Œµ / (2 * (|b - a| + 1) * (M + 1))) * (b - a) < Œµ := by
        rw [ mul_div, div_mul_eq_mul_div, div_lt_iff‚ÇÄ ] <;> nlinarith [ abs_of_pos ( sub_pos.mpr hab ), show 0 ‚â§ M by apply_rules [ Real.sSup_nonneg ] ; rintro x ‚ü® y, hy, rfl ‚ü© ; exact abs_nonneg _, mul_pos hŒµ ( show 0 < |b - a| + 1 by positivity ), mul_pos hŒµ ( show 0 < M + 1 by exact add_pos_of_nonneg_of_pos ( show 0 ‚â§ M by apply_rules [ Real.sSup_nonneg ] ; rintro x ‚ü® y, hy, rfl ‚ü© ; exact abs_nonneg _ ) zero_lt_one ) ];
      rw [ atMeshZero ];
      rw [ Filter.eventually_comap ];
      filter_upwards [ Ioo_mem_nhdsGT hŒ¥_pos ] with x hx using fun P hP => by simpa [ hP ] using lt_of_le_of_lt ( h_bound P <| by linarith [ hx.1, hx.2 ] ) h_final_bound;

/-
If f is bounded by M and œÜ satisfies a uniform continuity condition with Œµ and Œ¥, then for any partition with mesh size < Œ¥, the difference between the generalized and standard Riemann sums is bounded by M * Œµ * (b - a).
-/
lemma riemann_sum_diff_bound_aux {a b : ‚Ñù} (hab : a < b) (P : TaggedPartition2 a b)
    {f œÜ : ‚Ñù ‚Üí ‚Ñù} {M : ‚Ñù} (hM : ‚àÄ x ‚àà Icc a b, |f x| ‚â§ M)
    {Œµ : ‚Ñù} (hŒµ : 0 ‚â§ Œµ) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥)
    (h_unif : ‚àÄ x ‚àà Icc a b, ‚àÄ y ‚àà Icc a b, |x - y| < Œ¥ ‚Üí |œÜ x - œÜ y| ‚â§ Œµ)
    (h_mesh : meshSize P < Œ¥) :
    |riemannSum P f œÜ - riemannSum P (fun x => f x * œÜ x) (fun _ => 1)| ‚â§ M * Œµ * (b - a) := by
      have h_diff : ‚àÄ i : Fin P.n, |f (P.ys i) * œÜ (P.etas i) - f (P.ys i) * œÜ (P.ys i)| ‚â§ M * Œµ := by
        intro i
        have h_diff_i : |œÜ (P.etas i) - œÜ (P.ys i)| ‚â§ Œµ := by
          apply h_unif;
          ¬∑ have := P.h_etas i;
            exact ‚ü® by linarith [ this.1, P.h_xs_0, P.h_xs_n, P.h_xs_mono.monotone ( show 0 ‚â§ Fin.castSucc i from Nat.zero_le _ ) ], by linarith [ this.2, P.h_xs_0, P.h_xs_n, P.h_xs_mono.monotone ( show Fin.succ i ‚â§ Fin.last P.n from Fin.le_last _ ) ] ‚ü©;
          ¬∑ exact ‚ü® by linarith [ Set.mem_Icc.mp ( P.h_ys i ), P.h_xs_0, P.h_xs_n, show P.xs ( Fin.castSucc i ) ‚â• a from by linarith [ Set.mem_Icc.mp ( P.h_ys i ), P.h_xs_0, P.h_xs_n, show P.xs ( Fin.castSucc i ) ‚â• P.xs 0 from by exact P.h_xs_mono.monotone ( Nat.zero_le _ ) ] ], by linarith [ Set.mem_Icc.mp ( P.h_ys i ), P.h_xs_0, P.h_xs_n, show P.xs ( Fin.succ i ) ‚â§ b from by linarith [ Set.mem_Icc.mp ( P.h_ys i ), P.h_xs_0, P.h_xs_n, show P.xs ( Fin.succ i ) ‚â§ P.xs ( Fin.last P.n ) from by exact P.h_xs_mono.monotone ( Fin.le_last _ ) ] ] ‚ü©;
          ¬∑ unfold meshSize at h_mesh;
            have h_diff_i : P.xs (Fin.succ i) - P.xs (Fin.castSucc i) < Œ¥ := by
              contrapose! h_mesh;
              have h_mesh_le : Œ¥ ‚â§ Finset.max (Finset.image (fun i : Fin P.n => P.xs (Fin.succ i) - P.xs (Fin.castSucc i)) Finset.univ) := by
                exact le_trans ( WithBot.coe_le_coe.mpr h_mesh ) ( Finset.le_max ( Finset.mem_image_of_mem _ ( Finset.mem_univ _ ) ) );
              cases h : Finset.max ( Finset.image ( fun i : Fin P.n => P.xs i.succ - P.xs i.castSucc ) Finset.univ ) <;> aesop;
            exact abs_lt.mpr ‚ü® by linarith [ Set.mem_Icc.mp ( P.h_etas i ), Set.mem_Icc.mp ( P.h_ys i ) ], by linarith [ Set.mem_Icc.mp ( P.h_etas i ), Set.mem_Icc.mp ( P.h_ys i ) ] ‚ü©;
        simpa only [ ‚Üê mul_sub, abs_mul ] using mul_le_mul ( hM _ <| by constructor <;> linarith [ Set.mem_Icc.mp <| P.h_ys i, Set.mem_Icc.mp <| P.h_etas i, P.h_xs_0, P.h_xs_n, P.h_xs_mono.monotone <| Fin.zero_le <| Fin.castSucc i, P.h_xs_mono.monotone <| Fin.le_last <| Fin.castSucc i, P.h_xs_mono.monotone <| Fin.zero_le <| Fin.succ i, P.h_xs_mono.monotone <| Fin.le_last <| Fin.succ i ] ) h_diff_i ( by positivity ) ( by linarith [ abs_le.mp ( hM ( P.ys i ) <| by constructor <;> linarith [ Set.mem_Icc.mp <| P.h_ys i, Set.mem_Icc.mp <| P.h_etas i, P.h_xs_0, P.h_xs_n, P.h_xs_mono.monotone <| Fin.zero_le <| Fin.castSucc i, P.h_xs_mono.monotone <| Fin.le_last <| Fin.castSucc i, P.h_xs_mono.monotone <| Fin.zero_le <| Fin.succ i, P.h_xs_mono.monotone <| Fin.le_last <| Fin.succ i ] ) ] );
      -- The sum of the differences is bounded by the sum of M * Œµ over all subintervals.
      have h_sum_diff : |‚àë i : Fin P.n, (f (P.ys i) * œÜ (P.etas i) - f (P.ys i) * œÜ (P.ys i)) * (P.xs (Fin.succ i) - P.xs (Fin.castSucc i))| ‚â§ M * Œµ * (‚àë i : Fin P.n, (P.xs (Fin.succ i) - P.xs (Fin.castSucc i))) := by
        rw [ Finset.mul_sum _ _ _ ];
        exact le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( Finset.sum_le_sum fun i _ => by rw [ abs_mul, abs_of_nonneg ( sub_nonneg.mpr <| P.h_xs_mono.monotone <| Nat.le_succ _ ) ] ; exact mul_le_mul_of_nonneg_right ( h_diff i ) <| sub_nonneg.mpr <| P.h_xs_mono.monotone <| Nat.le_succ _ );
      convert h_sum_diff using 1;
      ¬∑ simp +decide [ sub_mul, Finset.sum_sub_distrib, riemannSum ];
      ¬∑ exact congrArg _ ( by rw [ show ‚àë i : Fin P.n, ( P.xs i.succ - P.xs i.castSucc ) = b - a from by simpa [ Finset.sum_range, Fin.sum_univ_castSucc ] using sum_deltas_eq_sub P ] )

/-
If f is bounded by M and œÜ satisfies a uniform continuity condition with Œµ and Œ¥, then for any partition with mesh size < Œ¥, the difference between the generalized and standard Riemann sums is bounded by M * Œµ * (b - a).
-/
lemma riemann_sum_diff_bound_aux_v2 {a b : ‚Ñù} (hab : a < b) (P : TaggedPartition2 a b)
    {f œÜ : ‚Ñù ‚Üí ‚Ñù} {M : ‚Ñù} (hM : ‚àÄ x ‚àà Icc a b, |f x| ‚â§ M)
    {Œµ : ‚Ñù} (hŒµ : 0 ‚â§ Œµ) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥)
    (h_unif : ‚àÄ x ‚àà Icc a b, ‚àÄ y ‚àà Icc a b, |x - y| < Œ¥ ‚Üí |œÜ x - œÜ y| ‚â§ Œµ)
    (h_mesh : meshSize P < Œ¥) :
    |riemannSum P f œÜ - riemannSum P (fun x => f x * œÜ x) (fun _ => 1)| ‚â§ M * Œµ * (b - a) := by
      convert riemann_sum_diff_bound_aux hab P hM hŒµ hŒ¥ h_unif h_mesh using 1

/-
If f is bounded by M and œÜ satisfies a uniform continuity condition with Œµ and Œ¥, then for any partition with mesh size < Œ¥, the difference between the generalized and standard Riemann sums is bounded by M * Œµ * (b - a).
-/
lemma riemann_sum_diff_bound_aux_v3 {a b : ‚Ñù} (hab : a < b) (P : TaggedPartition2 a b)
    {f œÜ : ‚Ñù ‚Üí ‚Ñù} {M : ‚Ñù} (hM : ‚àÄ x ‚àà Icc a b, |f x| ‚â§ M)
    {Œµ : ‚Ñù} (hŒµ : 0 ‚â§ Œµ) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥)
    (h_unif : ‚àÄ x ‚àà Icc a b, ‚àÄ y ‚àà Icc a b, |x - y| < Œ¥ ‚Üí |œÜ x - œÜ y| ‚â§ Œµ)
    (h_mesh : meshSize P < Œ¥) :
    |riemannSum P f œÜ - riemannSum P (fun x => f x * œÜ x) (fun _ => 1)| ‚â§ M * Œµ * (b - a) := by
      convert riemann_sum_diff_bound_aux_v2 hab P hM hŒµ hŒ¥ h_unif h_mesh using 3

/-
Polya-Szego Problem 100: If f and œÜ are continuous on [a, b], then the generalized Riemann sum Œ£ f(y_ŒΩ)œÜ(Œ∑_ŒΩ)Œîx_ŒΩ converges to ‚à´ f(x)œÜ(x) dx as the mesh size tends to 0.
-/
theorem problem_100_formalized {a b : ‚Ñù} (hab : a < b)
    {f œÜ : ‚Ñù ‚Üí ‚Ñù} (hf : ContinuousOn f (Icc a b)) (hœÜ : ContinuousOn œÜ (Icc a b)) :
    Tendsto (fun P => riemannSum P f œÜ) (atMeshZero a b) (ùìù (intervalIntegral (fun x => f x * œÜ x) a b volume)) := by
  let g := fun x => f x * œÜ x
  have hg : ContinuousOn g (Icc a b) := hf.mul hœÜ
  have h_diff := riemann_sum_diff_convergence hab hf hœÜ
  have h_conv := riemann_sum_convergence_aux hab hg
  have h_sum : Tendsto (fun P => (riemannSum P f œÜ - riemannSum P g (fun _ => 1)) + riemannSum P g (fun _ => 1))
               (atMeshZero a b) (ùìù (0 + intervalIntegral g a b volume)) :=
    Tendsto.add h_diff h_conv
  simp only [sub_add_cancel, zero_add] at h_sum
  exact h_sum