/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: eab0d0a7-3bf8-4c5f-8f4d-14cc6d22c05f
-/

/-
We formalized the Polya-Szego Problem 132.2 regarding the rearrangement of the alternating harmonic series.
We defined the term of the rearranged series `S_pq_term` and its partial sums `S_pq_partial_sum`.
We proved the main theorem `problem_132_2` which states that the rearranged series converges to `(1/2) * log (p/q) + (1 - log 2)`.
Note that `1 - log 2` is the sum of the original alternating harmonic series (which we also formalized as `problem_series_sum_eq`).
The formalization correctly captures the mathematical statement and has been formally proven.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-- The nth term of the alternating harmonic series: (-1)^(n+1)/n -/
def alt_harmonic_term (n : ℕ) : ℝ :=
  if n = 0 then 0 else (-1 : ℝ)^(n+1) / n

/-- Partial sum of the alternating harmonic series up to N -/
def alt_harmonic_partial_sum (N : ℕ) : ℝ :=
  ∑ n ∈ Finset.range N, alt_harmonic_term n

/-- The k-th term in the S_{p,q} rearrangement -/
def S_pq_term (p q : ℕ) (k : ℕ) : ℝ :=
  let block_size := p + q
  let block_num := k / block_size
  let pos_in_block := k % block_size
  if pos_in_block < p then
    1 / (2 * (block_num * p + pos_in_block + 1))
  else
    -1 / (2 * (block_num * q + (pos_in_block - p)) + 3)

/-- Partial sum of S_{p,q} up to N terms -/
def S_pq_partial_sum (p q : ℕ) (N : ℕ) : ℝ :=
  ∑ k ∈ Finset.range N, S_pq_term p q k

#check Filter.Tendsto
#check Filter.atTop
#check nhds
#check HasSum

/-- The n-th term of the series 1/2 - 1/3 + 1/4 - 1/5 + ... -/
def problem_series_term (n : ℕ) : ℝ := (-1 : ℝ)^n / (n + 2)

/-- Partial sum of the problem series up to N -/
def problem_series_partial_sum (N : ℕ) : ℝ :=
  ∑ n ∈ Finset.range N, problem_series_term n

/-
The series 1/2 - 1/3 + 1/4 - ... converges to 1 - log 2.
-/
theorem problem_series_sum_eq : Filter.Tendsto problem_series_partial_sum Filter.atTop (nhds (1 - Real.log 2)) := by
  -- We'll use the fact that the sum of the series $\sum_{n=1}^{\infty} \frac{(-1)^n}{n}$ is $\ln 2$.
  have h_sum : Filter.Tendsto (fun N => ∑ n ∈ Finset.range N, (-1 : ℝ) ^ n / (n + 1)) Filter.atTop (nhds (Real.log 2)) := by
    -- We'll use the fact that the sum of the series can be expressed as an integral.
    have h_integral : ∀ N : ℕ, ∑ n ∈ Finset.range N, (-1 : ℝ) ^ n / (n + 1) = ∫ x in (0 : ℝ)..1, (∑ n ∈ Finset.range N, (-x) ^ n) := by
      intro N; rw [ intervalIntegral.integral_finset_sum ] <;> norm_num;
      · exact Finset.sum_congr rfl fun i hi => by rw [ intervalIntegral.integral_comp_neg fun x => x ^ i ] ; norm_num ; ring;
      · exact fun i hi => Continuous.intervalIntegrable ( by continuity ) _ _;
    -- We'll use the fact that the sum of the series can be expressed as an integral. Evaluate the integral.
    have h_integral_eval : ∀ N : ℕ, ∑ n ∈ Finset.range N, (-1 : ℝ) ^ n / (n + 1) = ∫ x in (0 : ℝ)..1, (1 - (-x) ^ N) / (1 + x) := by
      intro N; rw [ h_integral N ] ; refine' intervalIntegral.integral_congr fun x hx => _ ; rw [ ← neg_div_neg_eq, geom_sum_eq ] <;> ring ; norm_num at hx ⊢ ; linarith;
    -- We'll use the fact that the integral of $\frac{(-x)^N}{1+x}$ over $[0, 1]$ tends to $0$ as $N \to \infty$.
    have h_zero : Filter.Tendsto (fun N => ∫ x in (0 : ℝ)..1, (-x) ^ N / (1 + x)) Filter.atTop (nhds 0) := by
      -- We'll use the fact that the absolute value of the integrand is bounded by $x^N$.
      have h_abs : ∀ N : ℕ, ∫ x in (0 : ℝ)..1, |(-x) ^ N / (1 + x)| ≤ ∫ x in (0 : ℝ)..1, x ^ N := by
        refine' fun N => intervalIntegral.integral_mono_on _ _ _ _ <;> norm_num;
        · exact ContinuousOn.intervalIntegrable ( by exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.abs <| ContinuousAt.div ( ContinuousAt.pow ( continuousAt_id.neg ) _ ) ( continuousAt_const.add continuousAt_id ) <| by linarith [ Set.mem_Icc.mp <| by simpa using hx ] );
        · norm_num [ abs_div ];
          exact fun x hx₁ hx₂ => by rw [ abs_of_nonneg hx₁, abs_of_nonneg ( by linarith ) ] ; exact div_le_self ( by positivity ) ( by linarith ) ;
      refine' squeeze_zero_norm ( fun N => _ ) ( by simpa using tendsto_one_div_add_atTop_nhds_zero_nat );
      exact le_trans ( by apply_rules [ intervalIntegral.abs_integral_le_integral_abs ] ; norm_num ) ( le_trans ( h_abs N ) ( by norm_num ) );
    -- We can rewrite our integral expression using the factored form.
    have h_split_integral : ∀ N : ℕ, (∫ x in (0 : ℝ)..1, (1 - (-x) ^ N) / (1 + x)) = (∫ x in (0 : ℝ)..1, 1 / (1 + x)) - (∫ x in (0 : ℝ)..1, (-x) ^ N / (1 + x)) := by
      exact fun N => by simpa only [ sub_div, one_div ] using intervalIntegral.integral_sub ( by exact ContinuousOn.intervalIntegrable ( by exact continuousOn_of_forall_continuousAt fun x hx => by exact ContinuousAt.inv₀ ( continuousAt_const.add continuousAt_id ) ( by linarith [ Set.mem_Icc.mp ( by simpa using hx ) ] ) ) .. ) ( by exact ContinuousOn.intervalIntegrable ( by exact ContinuousOn.div ( Continuous.continuousOn ( by continuity ) ) ( Continuous.continuousOn ( by continuity ) ) fun x hx => by linarith [ Set.mem_Icc.mp ( by simpa using hx ) ] ) .. ) ;
    norm_num [ h_integral_eval, h_split_integral ] at *;
    convert h_zero.const_sub ( Real.log 2 ) using 2 <;> norm_num [ ← h_integral ];
    rw [ h_integral, intervalIntegral.integral_finset_sum ] <;> norm_num;
    · exact Finset.sum_congr rfl fun i hi => by rw [ intervalIntegral.integral_comp_neg fun x => x ^ i ] ; norm_num ; ring;
    · exact fun i hi => Continuous.intervalIntegrable ( by continuity ) _ _;
  rw [ show problem_series_partial_sum = fun N : ℕ => ∑ n ∈ Finset.range N, ( -1 : ℝ ) ^ n / ( n + 2 ) by funext; rfl ];
  have h_shift : Filter.Tendsto (fun N => (∑ n ∈ Finset.range (N + 1), (-1 : ℝ) ^ n / (n + 1)) - 1) Filter.atTop (nhds (Real.log 2 - 1)) := by
    exact Filter.Tendsto.sub ( h_sum.comp ( Filter.tendsto_add_atTop_nat 1 ) ) tendsto_const_nhds;
  convert h_shift.neg using 2 <;> norm_num [ Finset.sum_range_succ' ] ; ring;
  rw [ ← Finset.sum_neg_distrib ] ; congr ; ext ; ring

theorem problem_132_2 (p q : ℕ) (hp : p > 0) (hq : q > 0) :
    ∃ (S_pq : ℝ), Filter.Tendsto (S_pq_partial_sum p q) Filter.atTop (nhds S_pq) ∧
    S_pq - (1 - Real.log 2) = (1/2 : ℝ) * Real.log ((p : ℝ) / q) := by
  -- To prove the convergence of the rearranged series, we use the fact that the sum of the alternating harmonic series is $\ln(2)$.
  have h_sum : Filter.Tendsto (fun n => ∑ k ∈ Finset.range n, (1 / (2 * k + 2) - 1 / (2 * k + 3) : ℝ)) Filter.atTop (nhds (1 - Real.log 2)) := by
    -- We can express the sum as a telescoping series.
    have h_telescope : ∀ n : ℕ, ∑ k ∈ Finset.range n, (1 / (2 * k + 2 : ℝ) - 1 / (2 * k + 3 : ℝ)) = ∑ k ∈ Finset.range (2 * n), (-1 : ℝ)^k / (k + 2 : ℝ) := by
      intro n; induction n <;> simp_all +decide [ Nat.mul_succ, Finset.sum_range_succ ] ; ring;
      simp_all +decide [ add_comm, mul_comm, pow_mul' ];
      grind;
    have := @problem_series_sum_eq;
    convert this.comp ( Filter.tendsto_id.nsmul_atTop two_pos ) using 2 ; aesop;
  have h_rearrange : Filter.Tendsto (fun n => ∑ k ∈ Finset.range (p * n), (1 / (2 * k + 2) : ℝ) - ∑ k ∈ Finset.range (q * n), (1 / (2 * k + 3) : ℝ)) Filter.atTop (nhds (1 / 2 * Real.log ((p : ℝ) / (q : ℝ)) + 1 - Real.log 2)) := by
    -- We can express the partial sums as differences of harmonic numbers and use the fact that the harmonic numbers grow logarithmically.
    have h_harmonic : Filter.Tendsto (fun n => (∑ k ∈ Finset.range (p * n), (1 / (k + 1) : ℝ)) - (∑ k ∈ Finset.range (q * n), (1 / (k + 1) : ℝ))) Filter.atTop (nhds (Real.log p - Real.log q)) := by
      have h_harmonic : Filter.Tendsto (fun n => (∑ k ∈ Finset.range n, (1 / (k + 1) : ℝ)) - Real.log n) Filter.atTop (nhds (Real.eulerMascheroniConstant)) := by
        convert Real.tendsto_harmonic_sub_log using 1;
        norm_num [ harmonic ];
      have h_harmonic_diff : Filter.Tendsto (fun n => (∑ k ∈ Finset.range (p * n), (1 / (k + 1) : ℝ)) - Real.log (p * n)) Filter.atTop (nhds (Real.eulerMascheroniConstant)) ∧ Filter.Tendsto (fun n => (∑ k ∈ Finset.range (q * n), (1 / (k + 1) : ℝ)) - Real.log (q * n)) Filter.atTop (nhds (Real.eulerMascheroniConstant)) := by
        exact ⟨ by exact_mod_cast h_harmonic.comp ( Filter.tendsto_id.nsmul_atTop hp ), by exact_mod_cast h_harmonic.comp ( Filter.tendsto_id.nsmul_atTop hq ) ⟩;
      have := h_harmonic_diff.1.sub h_harmonic_diff.2;
      simpa using this.add_const ( Real.log p - Real.log q ) |> Filter.Tendsto.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn; rw [ Real.log_mul ( by positivity ) ( by positivity ), Real.log_mul ( by positivity ) ( by positivity ) ] ; ring );
    have h_harmonic : Filter.Tendsto (fun n => (∑ k ∈ Finset.range (p * n), (1 / (2 * k + 2) : ℝ)) - (∑ k ∈ Finset.range (q * n), (1 / (2 * k + 2) : ℝ))) Filter.atTop (nhds ((1 / 2) * (Real.log p - Real.log q))) := by
      convert h_harmonic.const_mul ( 1 / 2 ) using 2 ; norm_num [ Finset.mul_sum _ _ _, mul_comm ] ; ring;
      rw [ show ( fun x : ℕ => ( 2 + x * 2 : ℝ ) ⁻¹ ) = fun x : ℕ => ( 1 + x : ℝ ) ⁻¹ * ( 1 / 2 ) by ext x; rw [ inv_eq_iff_eq_inv ] ; norm_num ; ring ] ; norm_num [ Finset.sum_mul _ _ _ ] ; ring;
    convert h_harmonic.add ( h_sum.comp ( Filter.tendsto_id.nsmul_atTop hq ) ) using 2 <;> norm_num [ Real.log_div, hp.ne', hq.ne' ] ; ring;
  -- By definition of $S_{p,q}$, we know that
  have h_S_pq : ∀ n : ℕ, S_pq_partial_sum p q ((p + q) * n) = ∑ k ∈ Finset.range (p * n), (1 / (2 * k + 2) : ℝ) - ∑ k ∈ Finset.range (q * n), (1 / (2 * k + 3) : ℝ) := by
    intro n
    simp [S_pq_partial_sum, S_pq_term];
    induction' n with n ih <;> simp_all +decide [ Nat.succ_mul, Finset.sum_range_add ];
    rw [ Nat.mul_succ, Finset.sum_range_add ];
    simp_all +decide [ Nat.add_mod, Nat.add_div ];
    rw [ show p * ( n + 1 ) = p * n + p by ring, show q * ( n + 1 ) = q * n + q by ring, Finset.sum_range_add, Finset.sum_range_add ] ; norm_num [ Finset.sum_range, Nat.mod_eq_of_lt ] ; ring;
    norm_num [ Nat.div_eq_of_lt, Nat.mod_eq_of_lt, Finset.sum_range, Fin.sum_univ_add ] ; ring;
    congr! 2;
    · refine' Finset.sum_congr rfl fun x hx => _ ; rw [ Nat.mod_eq_of_lt ( by linarith [ Fin.is_lt x ] ) ] ; rw [ Nat.div_eq_of_lt ( by linarith [ Fin.is_lt x ] ) ] ; norm_num ; ring;
      rw [ if_neg ( by linarith [ Fin.is_lt x ] ) ] ; rw [ inv_mul_eq_div, inv_eq_one_div, div_eq_div_iff ] <;> ring <;> positivity;
    · exact Finset.sum_congr rfl fun x hx => by rw [ if_neg ( by linarith [ Fin.is_lt x ] ) ] ; ring;
  -- Since the partial sums of the rearranged series up to $(p+q)n$ terms converge to $(1/2) \ln(p/q) + 1 - \ln(2)$, and the terms of the series are bounded, the partial sums of the original series must also converge to the same limit.
  have h_bounded : ∃ C : ℝ, ∀ n : ℕ, ∀ k : ℕ, k < p + q → |S_pq_term p q ((p + q) * n + k)| ≤ C / (n + 1) := by
    use p + q + 1;
    unfold S_pq_term;
    intro n k hk; norm_num [ Nat.add_div, Nat.add_mod, Nat.mul_div_assoc, Nat.mul_mod, hp, hq ];
    split_ifs <;> norm_num [ Nat.div_eq_of_lt hk, Nat.mod_eq_of_lt hk ];
    · linarith [ Nat.mod_eq_of_lt hk ];
    · field_simp;
      rw [ abs_of_nonneg ] <;> nlinarith [ show ( p : ℝ ) ≥ 1 by norm_cast, show ( q : ℝ ) ≥ 1 by norm_cast, mul_nonneg ( Nat.cast_nonneg n : ( 0 : ℝ ) ≤ n ) ( Nat.cast_nonneg p : ( 0 : ℝ ) ≤ p ), mul_nonneg ( Nat.cast_nonneg n : ( 0 : ℝ ) ≤ n ) ( Nat.cast_nonneg q : ( 0 : ℝ ) ≤ q ) ];
    · linarith [ Nat.mod_lt k ( by linarith : 0 < p + q ) ];
    · rw [ abs_div ];
      rw [ div_le_div_iff₀ ] <;> norm_num <;> cases abs_cases ( 2 * ( n * q + ( k - p ) : ℝ ) + 3 ) <;> nlinarith [ show ( p : ℝ ) ≥ 1 by norm_cast, show ( q : ℝ ) ≥ 1 by norm_cast, show ( k : ℝ ) ≥ p by exact_mod_cast le_of_not_gt fun h => by linarith [ Nat.mod_eq_of_lt ( by linarith : k < p + q ) ] ];
  -- Since the partial sums of the rearranged series up to $(p+q)n$ terms converge to $(1/2) \ln(p/q) + 1 - \ln(2)$, and the terms of the series are bounded, the partial sums of the original series must also converge to the same limit. Hence, we can conclude that the rearranged series converges to $(1/2) \ln(p/q) + 1 - \ln(2)$.
  have h_converge : Filter.Tendsto (fun n => S_pq_partial_sum p q ((p + q) * n)) Filter.atTop (nhds ((1 / 2) * Real.log ((p : ℝ) / (q : ℝ)) + 1 - Real.log 2)) := by
    grind;
  -- Since the partial sums of the rearranged series up to $(p+q)n$ terms converge to $(1/2) \ln(p/q) + 1 - \ln(2)$, and the terms of the series are bounded, the partial sums of the original series must also converge to the same limit. Hence, we can conclude that the rearranged series converges to $(1/2) \ln(p/q) + 1 - \ln(2)$ by the squeeze theorem.
  have h_squeeze : ∀ ε > 0, ∃ N : ℕ, ∀ n ≥ N, ∀ k : ℕ, k < p + q → |S_pq_partial_sum p q ((p + q) * n + k) - S_pq_partial_sum p q ((p + q) * n)| < ε := by
    intros ε hε_pos
    obtain ⟨C, hC⟩ := h_bounded
    have h_bound : ∀ n : ℕ, ∀ k : ℕ, k < p + q → |S_pq_partial_sum p q ((p + q) * n + k) - S_pq_partial_sum p q ((p + q) * n)| ≤ C * (p + q) / (n + 1) := by
      intros n k hk_lt
      have h_bound : |S_pq_partial_sum p q ((p + q) * n + k) - S_pq_partial_sum p q ((p + q) * n)| ≤ ∑ i ∈ Finset.range k, |S_pq_term p q ((p + q) * n + i)| := by
        have h_sum_bound : S_pq_partial_sum p q ((p + q) * n + k) - S_pq_partial_sum p q ((p + q) * n) = ∑ i ∈ Finset.range k, S_pq_term p q ((p + q) * n + i) := by
          simp +decide [ S_pq_partial_sum, Finset.sum_range_add ];
        exact h_sum_bound ▸ Finset.abs_sum_le_sum_abs _ _;
      refine le_trans h_bound <| le_trans ( Finset.sum_le_sum fun i hi => hC n i <| by linarith [ Finset.mem_range.mp hi ] ) ?_;
      norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ];
      exact mul_le_mul_of_nonneg_left ( mul_le_mul_of_nonneg_right ( mod_cast hk_lt.le ) ( by positivity ) ) ( show 0 ≤ C by have := hC 0 0 ( by linarith ) ; norm_num [ S_pq_term ] at this ; linarith [ abs_le.mp this ] );
    exact ⟨ Nat.ceil ( ε⁻¹ * ( C * ( p + q ) ) ), fun n hn k hk => lt_of_le_of_lt ( h_bound n k hk ) ( by rw [ div_lt_iff₀ ] <;> nlinarith [ Nat.ceil_le.mp hn, inv_pos.mpr hε_pos, mul_inv_cancel₀ hε_pos.ne' ] ) ⟩;
  have h_squeeze : Filter.Tendsto (fun n => S_pq_partial_sum p q n) Filter.atTop (nhds ((1 / 2) * Real.log ((p : ℝ) / (q : ℝ)) + 1 - Real.log 2)) := by
    rw [ Metric.tendsto_nhds ] at *;
    intro ε hε; rcases h_squeeze ( ε / 2 ) ( half_pos hε ) with ⟨ N, hN ⟩ ; rcases Filter.eventually_atTop.mp ( h_converge ( ε / 2 ) ( half_pos hε ) ) with ⟨ M, hM ⟩ ; refine' Filter.eventually_atTop.mpr ⟨ ( p + q ) * N + ( p + q ) * M, fun n hn => _ ⟩ ; simp_all +decide [ Nat.div_add_mod ];
    -- Let $n = (p + q) * m + k$ for some $m \geq N$ and $k < p + q$.
    obtain ⟨m, k, hm, hk⟩ : ∃ m k : ℕ, n = (p + q) * m + k ∧ m ≥ N ∧ k < p + q := by
      exact ⟨ n / ( p + q ), n % ( p + q ), by rw [ Nat.div_add_mod ], Nat.le_div_iff_mul_le ( by positivity ) |>.2 ( by nlinarith ), Nat.mod_lt _ ( by positivity ) ⟩;
    simp_all +decide [ dist_eq_norm ];
    exact abs_lt.mpr ⟨ by linarith [ abs_lt.mp ( hN m hk.1 k hk.2 ), abs_lt.mp ( hM m ( by nlinarith ) ) ], by linarith [ abs_lt.mp ( hN m hk.1 k hk.2 ), abs_lt.mp ( hM m ( by nlinarith ) ) ] ⟩;
  exact ⟨ _, h_squeeze, by ring ⟩