/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 81cb8a03-389e-46cc-b778-c6272765ef4c
-/

/-
We formalized Dini's theorem for a monotone sequence of continuous functions on a compact interval.
The user's original statement had some type mismatches regarding the domain of the functions and the set over which uniform convergence is checked.
We corrected this by using `TendstoUniformly` on the subtype `Set.Icc a b`, which is a compact space.
We proved the theorem by splitting into monotone and antitone cases and applying the corresponding Dini's theorem variants from Mathlib (`Monotone.tendstoUniformly_of_forall_tendsto` and `Antitone.tendstoUniformly_of_forall_tendsto`).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Monotone.tendstoUniformlyOn_of_forall_tendsto

#check Antitone.tendstoUniformly_of_forall_tendsto

open Filter Topology
#synth CompactSpace (Set.Icc (0:â„) 1)

/-
Dini's theorem: If a monotone sequence of continuous functions converges pointwise to a continuous function on a compact interval, it converges uniformly.
-/
open Filter Topology

theorem dini_theorem {a b : â„} (hab : a â‰¤ b) {Î¹ : Type*} [Preorder Î¹] [hÎ¹ : Nonempty Î¹]
    [NoMaxOrder Î¹] (F : Î¹ â†’ C(Set.Icc a b, â„)) (f : C(Set.Icc a b, â„))
    (h_mono : Monotone F âˆ¨ Antitone F) (h_pointwise : âˆ€ x, Tendsto (fun n => F n x) atTop (ð“ (f x))) :
    TendstoUniformly (fun n => F n) f atTop := by
      rcases h_mono with h | h;
      Â· -- Apply Dini's theorem to conclude uniform convergence.
        have h_dini : TendstoUniformlyOn (fun n => (F n : (Set.Icc a b) â†’ â„)) (f : (Set.Icc a b) â†’ â„) Filter.atTop Set.univ := by
          apply_rules [ Monotone.tendstoUniformlyOn_of_forall_tendsto ];
          Â· exact isCompact_univ;
          Â· exact fun n => Continuous.continuousOn ( F n |> ContinuousMap.continuous );
          Â· exact fun x _ => fun n m hnm => h hnm x;
          Â· exact f.continuous.continuousOn;
          Â· aesop;
        exact?;
      Â· apply_rules [ Antitone.tendstoUniformly_of_forall_tendsto ];
        Â· exact fun n => ( F n ).continuous;
        Â· exact f.continuous