/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7da1c32a-80b0-41a4-b6cc-2e68c52924d4

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def SlowlyIncreasing (L : â„ â†’ â„) : Prop :=
  âˆ€ (c : â„) (hc : c > 0), Asymptotics.IsEquivalent (Filter.atTop : Filter â„) (fun r => L (c * r)) (fun r => L r)

def counting_function (seq : â„• â†’ â„) (h_nonneg : âˆ€ n, 0 â‰¤ seq n) (h_increasing : âˆ€ m n, m â‰¤ n â†’ seq m â‰¤ seq n) 
    (h_tends_to_infinity : Filter.Tendsto seq Filter.atTop Filter.atTop) : â„ â†’ â„• :=
  fun r => Nat.card {n : â„• | seq n â‰¤ r}

#check Asymptotics.IsEquivalent
#check Filter.atTop

#check Summable

/-
If $f$ is continuous and $f(x+y) - f(x) \to 0$ for all $y > 0$, then $f(x)/x \to 0$.
-/
open Filter Asymptotics Metric
open scoped Topology

lemma lemma_152_helper (f : â„ â†’ â„) (hf : Continuous f) (h_diff : âˆ€ y > 0, Tendsto (fun x â†¦ f (x + y) - f x) atTop (ğ“ 0)) :
    Tendsto (fun x â†¦ f x / x) atTop (ğ“ 0) := by
  -- Let's choose any $\epsilon > 0$.
  suffices h_eps : âˆ€ Ïµ > 0, âˆƒ M : â„, âˆ€ x â‰¥ M, |f x| â‰¤ Ïµ * x by
    rw [ Metric.tendsto_nhds ];
    exact fun Îµ hÎµ => by rcases h_eps ( Îµ / 2 ) ( half_pos hÎµ ) with âŸ¨ M, HM âŸ© ; filter_upwards [ Filter.eventually_ge_atTop M, Filter.eventually_gt_atTop 0 ] with x hxâ‚ hxâ‚‚ using abs_lt.mpr âŸ¨ by nlinarith [ abs_le.mp ( HM x hxâ‚ ), mul_div_cancelâ‚€ ( f x ) hxâ‚‚.ne' ], by nlinarith [ abs_le.mp ( HM x hxâ‚ ), mul_div_cancelâ‚€ ( f x ) hxâ‚‚.ne' ] âŸ© ;
  -- Fix an arbitrary $\epsilon > 0$.
  intro Ïµ hÏµ_pos
  -- By the properties of the function $f$, there exists $M$ such that for all $x \geq M$, we have $|f(x+1) - f(x)| \leq \frac{\epsilon}{2}$.
  obtain âŸ¨M, hMâŸ© : âˆƒ M : â„, âˆ€ x â‰¥ M, |f (x + 1) - f x| â‰¤ Ïµ / 2 := by
    simpa using h_diff 1 zero_lt_one |> fun h => h.eventually ( Metric.closedBall_mem_nhds _ <| half_pos hÏµ_pos );
  -- Let $K = \max_{x \in [M, M+1]} |f(x)|$.
  obtain âŸ¨K, hKâŸ© : âˆƒ K : â„, âˆ€ x âˆˆ Set.Icc M (M + 1), |f x| â‰¤ K := by
    exact IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) ( hf.continuousOn );
  -- By induction, we can show that for all $x \geq M$, $|f(x)| \leq K + \frac{\epsilon}{2} (x - M)$.
  have h_induction : âˆ€ x â‰¥ M, |f x| â‰¤ K + Ïµ / 2 * (x - M) := by
    intro x hx
    induction' n : âŒŠx - MâŒ‹â‚Š using Nat.strong_induction_on with n ih generalizing x;
    by_cases hx_case : x â‰¤ M + 1;
    Â· exact le_add_of_le_of_nonneg ( hK x âŸ¨ hx, hx_case âŸ© ) ( mul_nonneg ( by positivity ) ( by linarith ) );
    Â· contrapose! ih;
      refine' âŸ¨ âŒŠx - M - 1âŒ‹â‚Š, _, x - 1, _, _, _ âŸ© <;> norm_num at *;
      Â· rw [ â† n, tsub_lt_iff_left ] <;> norm_num [ Nat.floor_pos, hx_case.le ];
        linarith;
      Â· linarith;
      Â· rw [ Nat.floor_eq_iff ];
        Â· exact âŸ¨ by rw [ Nat.cast_sub ( Nat.floor_pos.mpr ( by linarith ) ) ] ; push_cast; linarith [ Nat.floor_le ( by linarith : 0 â‰¤ x - M ) ], by rw [ Nat.cast_sub ( Nat.floor_pos.mpr ( by linarith ) ) ] ; push_cast; linarith [ Nat.lt_floor_add_one ( x - M ) ] âŸ©;
        Â· linarith;
      Â· have := hM ( x - 1 ) ( by linarith ) ; cases abs_cases ( f ( x - 1 + 1 ) - f ( x - 1 ) ) <;> cases abs_cases ( f x ) <;> cases abs_cases ( f ( x - 1 ) ) <;> ring_nf at * <;> nlinarith;
  exact âŸ¨ Max.max M ( âŒˆ ( K - Ïµ * M / 2 ) / ( Ïµ / 2 ) âŒ‰â‚Š + 1 ), fun x hx => by nlinarith [ Nat.le_ceil ( ( K - Ïµ * M / 2 ) / ( Ïµ / 2 ) ), h_induction x ( le_trans ( le_max_left _ _ ) hx ), le_max_right M ( âŒˆ ( K - Ïµ * M / 2 ) / ( Ïµ / 2 ) âŒ‰â‚Š + 1 ), mul_div_cancelâ‚€ ( K - Ïµ * M / 2 ) ( by linarith : ( Ïµ / 2 ) â‰  0 ) ] âŸ©

open Filter Asymptotics Metric
open scoped Topology

theorem problem_152 (L : â„ â†’ â„) (hL_cont : Continuous L) (hL_pos : âˆ€ r > 0, L r > 0) (hL_slow : SlowlyIncreasing L) :
    Filter.Tendsto (fun r : â„ => Real.log (L r) / Real.log r) Filter.atTop (ğ“ 0) := by
      -- Applying the lemma that if $f(x+y) - f(x) \to 0$ for all $y > 0$, then $f(x)/x \to 0$, we get that $\frac{\log L(x)}{\log x} \to 0$ as $x \to \infty$.
      have h_log_div_log : Filter.Tendsto (fun x => Real.log (L (Real.exp x)) / x) Filter.atTop (ğ“ 0) := by
        -- Applying the lemma to the function $f(x) = \log L(e^x)$, we get that $\frac{f(x)}{x} \to 0$ as $x \to \infty$.
        have h_log_div : Filter.Tendsto (fun x => Real.log (L (Real.exp x)) / x) Filter.atTop (ğ“ 0) := by
          have h_diff : âˆ€ y > 0, Tendsto (fun x => Real.log (L (Real.exp (x + y))) - Real.log (L (Real.exp x))) Filter.atTop (ğ“ 0) := by
            -- By the hypothesis hL_slow, we know that L(c * r) / L(r) tends to 1 for any c > 0 as r approaches infinity.
            have h_ratio : âˆ€ c > 0, Filter.Tendsto (fun r => L (c * r) / L r) Filter.atTop (nhds 1) := by
              intro c hc_pos
              specialize hL_slow c hc_pos;
              rw [ Asymptotics.IsEquivalent ] at hL_slow;
              rw [ Asymptotics.isLittleO_iff_tendsto' ] at hL_slow;
              Â· simpa using hL_slow.add_const 1 |> Filter.Tendsto.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with x hx using by simp +decide [ sub_div, ne_of_gt ( hL_pos x hx ) ] );
              Â· filter_upwards [ Filter.eventually_gt_atTop 0 ] with x hx hx' using absurd hx' ( ne_of_gt ( hL_pos x hx ) );
            intro y hy; have := h_ratio ( Real.exp y ) ( Real.exp_pos y ) ; simp_all +decide [ Real.exp_add ] ;
            have := this.log; simp_all +decide [ mul_comm, Real.exp_add ] ;
            convert this.comp ( Real.tendsto_exp_atTop ) using 2 ; norm_num [ mul_comm, Real.exp_ne_zero ];
            rw [ Real.log_div ( ne_of_gt ( hL_pos _ ( by positivity ) ) ) ( ne_of_gt ( hL_pos _ ( by positivity ) ) ) ]
          have := lemma_152_helper (fun x => Real.log (L (Real.exp x))) (by
          exact Continuous.log ( hL_cont.comp ( Real.continuous_exp ) ) fun x => ne_of_gt ( hL_pos _ ( Real.exp_pos _ ) )) h_diff
          generalize_proofs at *;
          convert this using 1;
        convert h_log_div using 1;
      have := h_log_div_log.comp Real.tendsto_log_atTop;
      exact this.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with x hx using by rw [ Function.comp_apply, Real.exp_log hx ] )

open Filter Asymptotics Metric
open scoped Topology

lemma lemma_slowly_increasing_bounds (L : â„ â†’ â„) (hL_cont : Continuous L) (hL_pos : âˆ€ r > 0, L r > 0) (hL_slow : SlowlyIncreasing L) :
    âˆ€ Îµ : â„, Îµ > 0 â†’ âˆ€á¶  r in atTop, r ^ (-Îµ) â‰¤ L r âˆ§ L r â‰¤ r ^ Îµ := by
  intro Îµ hÎµ
  have h_lim := problem_152 L hL_cont hL_pos hL_slow
  rw [Metric.tendsto_nhds] at h_lim
  specialize h_lim Îµ hÎµ
  filter_upwards [h_lim, Filter.eventually_gt_atTop 1] with r hr hr1
  have hr_pos : 0 < r := zero_lt_one.trans hr1
  rw [dist_zero_right, Real.norm_eq_abs, abs_div, abs_of_nonneg (Real.log_nonneg hr1.le)] at hr
  rw [div_lt_iffâ‚€ (Real.log_pos hr1)] at hr
  rw [abs_lt] at hr
  constructor
  Â· have : -Îµ * Real.log r < Real.log (L r) := by linarith
    rw [â† Real.log_rpow hr_pos (-Îµ)] at this
    rw [Real.log_lt_log_iff (Real.rpow_pos_of_pos hr_pos _) (hL_pos r hr_pos)] at this
    exact le_of_lt this
  Â· have : Real.log (L r) < Îµ * Real.log r := by linarith
    rw [â† Real.log_rpow hr_pos Îµ] at this
    rw [Real.log_lt_log_iff (hL_pos r hr_pos) (Real.rpow_pos_of_pos hr_pos _)] at this
    exact le_of_lt this