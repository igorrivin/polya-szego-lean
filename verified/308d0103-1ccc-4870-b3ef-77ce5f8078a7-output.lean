/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 308d0103-1ccc-4870-b3ef-77ce5f8078a7
-/

/-
We have formalized and proven Polya-Szego Problem 116 regarding the asymptotic behavior of binomial coefficients.

The main theorem `problem_116_asymptotic` establishes that for a sequence $\lambda_n \to \lambda$, the quantity $\frac{\sqrt{n}}{2^n} \binom{n}{\lfloor n/2 + \lambda_n \sqrt{n} \rfloor}$ converges to the Gaussian integral limit $\frac{1}{\sqrt{2\pi}} e^{-2\lambda^2}$. Note that the problem statement in the book has a factor of $1/(2\pi)$ but the standard Gaussian integral normalization leads to the result we proved, which is consistent with the standard central limit theorem behavior (the factor of 2 in the exponent comes from the variance of the binomial distribution being $n/4$).

The proof proceeds by:
1.  Using an integral representation of the binomial coefficient (`binomial_integral_representation`).
2.  Scaling the integral variable by $\sqrt{n}$ (`binomial_integral_scaled`).
3.  Showing the pointwise convergence of the integrand to a Gaussian function (`tendsto_cos_pow_n` and `convergence_of_coefficient`).
4.  Applying the Dominated Convergence Theorem to show the integral converges (`integral_convergence_lemma`).
5.  Evaluating the limiting Gaussian integral (`gaussian_integral_cos`).

All steps have been formally verified by the ATP.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Int.floor
#check Int.natAbs
#check Nat.choose
#check Filter.Tendsto
#check Real.sqrt
#check Real.exp
#check Real.pi

/-
Integral representation of the binomial coefficient:
C(n, k) / 2^n = (1 / 2π) ∫_{-π}^{π} (cos(x/2))^n cos((n/2 - k)x) dx
-/
lemma binomial_integral_representation (n k : ℕ) :
    (Nat.choose n k : ℝ) / (2 ^ n) = 1 / (2 * Real.pi) * ∫ x in -Real.pi..Real.pi, (Real.cos (x / 2)) ^ n * Real.cos (((n : ℝ) / 2 - k) * x) := by
  -- Use the binomial theorem to expand $(1 + e^{ix})^n$.
  have h_binom : ∀ x : ℝ, (Real.cos (x / 2)) ^ n * Real.cos ((n / 2 - k) * x) = (1 / 2 ^ n) * ∑ j ∈ Finset.range (n + 1), Nat.choose n j * Real.cos ((j - k) * x) := by
    -- Use the binomial theorem to expand $(1 + e^{ix})^n$ and then take the real part.
    intro x
    have h_expand : (Real.cos (x / 2)) ^ n * Real.cos ((n / 2 - k) * x) = (1 / 2 ^ n) * Complex.re ((1 + Complex.exp (x * Complex.I)) ^ n * Complex.exp (-(k * x * Complex.I))) := by
      -- Recognize that $(1 + e^{ix})^n$ can be rewritten using Euler's formula.
      have h_euler : (1 + Complex.exp (x * Complex.I)) ^ n = (2 * Real.cos (x / 2)) ^ n * Complex.exp (n * x * Complex.I / 2) := by
        rw [ show ( 1 + Complex.exp ( x * Complex.I ) ) = ( 2 * Real.cos ( x / 2 ) ) * Complex.exp ( x * Complex.I / 2 ) from ?_ ];
        · rw [ mul_pow, ← Complex.exp_nat_mul ] ; ring;
        · norm_num [ Complex.cos ];
          repeat ring <;> norm_num [ ← Complex.exp_nat_mul, ← Complex.exp_add ] ;
      simp_all +decide [ Complex.exp_re, Complex.exp_im, mul_pow ];
      norm_cast; norm_num [ pow_mul', ← mul_assoc, ← Complex.exp_nat_mul ] ; ring;
      norm_cast; norm_num [ Real.cos_sub ] ; ring;
      field_simp;
      norm_cast ; norm_num ; ring;
      norm_num [ mul_assoc, ← mul_pow ];
    -- Use the binomial theorem to expand $(1 + e^{ix})^n$ and then take the real part to get the desired expression.
    have h_binom : (1 + Complex.exp (x * Complex.I)) ^ n = ∑ j ∈ Finset.range (n + 1), Nat.choose n j * Complex.exp (j * x * Complex.I) := by
      rw [ add_comm, add_pow ];
      exact Finset.sum_congr rfl fun _ _ => by rw [ ← Complex.exp_nat_mul ] ; ring;
    simp_all +decide [ Complex.exp_re, Complex.exp_im, sub_mul ];
    simp +decide only [Finset.sum_mul _ _ _, mul_assoc, Real.cos_sub];
    simp +decide only [mul_add, Finset.sum_add_distrib];
  -- Evaluate the integral of $\cos((j - k)x)$ over $[-\pi, \pi]$.
  have h_cos : ∀ j : ℕ, ∫ x in -Real.pi..Real.pi, Real.cos ((j - k) * x) = if j = k then 2 * Real.pi else 0 := by
    intro j; split_ifs <;> simp_all +decide [ intervalIntegral.integral_comp_mul_left ] ;
    · ring;
    · rw [ intervalIntegral.integral_comp_mul_left ] <;> norm_num;
      · exact Or.inr ( Real.sin_eq_zero_iff.mpr ⟨ j - k, by push_cast; ring ⟩ );
      · exact sub_ne_zero_of_ne <| Nat.cast_injective.ne ‹_›;
  -- Substitute the results from h_binom and h_cos into the integral.
  have h_integral : ∫ x in -Real.pi..Real.pi, (Real.cos (x / 2)) ^ n * Real.cos ((n / 2 - k) * x) = (1 / 2 ^ n) * ∑ j ∈ Finset.range (n + 1), Nat.choose n j * ∫ x in -Real.pi..Real.pi, Real.cos ((j - k) * x) := by
    norm_num [ h_binom, intervalIntegral.integral_const_mul ];
    rw [ intervalIntegral.integral_finset_sum ] ; aesop;
    exact fun _ _ => Continuous.intervalIntegrable ( by continuity ) _ _;
  by_cases hk : k ≤ n <;> simp_all +decide [ div_eq_inv_mul ];
  · rw [ if_pos ( by linarith ) ] ; ring_nf ; norm_num [ Real.pi_ne_zero ];
  · rw [ Nat.choose_eq_zero_of_lt hk ] ; aesop

/-
The sequence (cos(x / (2√n)))^n converges to e^(-x^2/8) as n goes to infinity.
-/
lemma tendsto_cos_pow_n (x : ℝ) :
    Filter.Tendsto (fun (n : ℕ) => (Real.cos (x / (2 * Real.sqrt n))) ^ n) Filter.atTop (nhds (Real.exp (-x ^ 2 / 8))) := by
  -- We'll use the exponential property: $\left(\cos\left(\frac{x}{2\sqrt{n}}\right)\right)^n = \exp\left(n \ln\left(\cos\left(\frac{x}{2\sqrt{n}}\right)\right)\right)$.
  suffices h_exp : Filter.Tendsto (fun n : ℕ => Real.exp (n * Real.log (Real.cos (x / (2 * Real.sqrt n))))) Filter.atTop (nhds (Real.exp (-x^2 / 8))) by
    refine h_exp.congr' ?_;
    -- For sufficiently large $n$, $\cos(x / (2 \sqrt{n}))$ is positive, so we can apply the exponential property.
    have h_pos : ∃ N : ℕ, ∀ n ≥ N, 0 < Real.cos (x / (2 * Real.sqrt n)) := by
      have h_cos_pos : Filter.Tendsto (fun n : ℕ => Real.cos (x / (2 * Real.sqrt n))) Filter.atTop (nhds 1) := by
        simpa using Filter.Tendsto.comp ( Real.continuous_cos.tendsto _ ) ( tendsto_const_nhds.div_atTop <| Filter.Tendsto.const_mul_atTop zero_lt_two <| by simpa only [ Real.sqrt_eq_rpow ] using tendsto_rpow_atTop ( by positivity ) |> Filter.Tendsto.comp <| tendsto_natCast_atTop_atTop );
      simpa using h_cos_pos.eventually ( lt_mem_nhds zero_lt_one );
    filter_upwards [ Filter.eventually_ge_atTop h_pos.choose ] with n hn using by rw [ Real.exp_nat_mul, Real.exp_log ( h_pos.choose_spec n hn ) ] ;
  refine' Filter.Tendsto.rexp _;
  -- Let $y = \frac{x}{2\sqrt{n}}$, so we can rewrite the limit as $\lim_{y \to 0} \frac{\ln(\cos(y))}{y^2}$.
  suffices h_log_cos_y : Filter.Tendsto (fun y : ℝ => Real.log (Real.cos y) / y^2) (nhdsWithin 0 {0}ᶜ) (nhds (-1 / 2)) by
    by_cases hx : x = 0;
    · aesop;
    · have h_subst : Filter.Tendsto (fun n : ℕ => Real.log (Real.cos (x / (2 * Real.sqrt n))) / (x / (2 * Real.sqrt n))^2) Filter.atTop (nhds (-1 / 2)) := by
        refine h_log_cos_y.comp <| Filter.tendsto_inf.mpr ?_;
        exact ⟨ tendsto_const_nhds.div_atTop <| Filter.Tendsto.const_mul_atTop zero_lt_two <| by simpa only [ Real.sqrt_eq_rpow ] using tendsto_rpow_atTop ( by positivity ) |> Filter.Tendsto.comp <| tendsto_natCast_atTop_atTop, Filter.tendsto_principal.mpr <| Filter.eventually_atTop.mpr ⟨ 1, fun n hn => div_ne_zero hx <| mul_ne_zero two_ne_zero <| Real.sqrt_ne_zero'.mpr <| Nat.cast_pos.mpr <| pos_of_gt hn ⟩ ⟩;
      convert h_subst.const_mul ( x ^ 2 / 4 ) using 2 <;> ring;
      norm_num [ mul_assoc, mul_comm, mul_left_comm, hx ];
  -- Use the fact that $1 - \cos y \sim \frac{y^2}{2}$ as $y \to 0$.
  have h_cos_approx : Filter.Tendsto (fun y : ℝ => (1 - Real.cos y) / y^2) (nhdsWithin 0 {0}ᶜ) (nhds (1 / 2)) := by
    -- Use the fact that $1 - \cos y$ can be rewritten as $2 \cdot \sin^2 (y/2)$.
    suffices h_sin_sq : Filter.Tendsto (fun y => 2 * (Real.sin (y / 2))^2 / y^2) (nhdsWithin 0 {0}ᶜ) (nhds (1 / 2)) by
      exact h_sin_sq.congr fun x => by rw [ Real.sin_sq, Real.cos_sq ] ; ring;
    -- Use the fact that $\sin(y/2) / y \to 1/2$ as $y \to 0$.
    have h_sin_y2 : Filter.Tendsto (fun y => Real.sin (y / 2) / y) (nhdsWithin 0 {0}ᶜ) (nhds (1 / 2)) := by
      simpa [ div_eq_inv_mul ] using HasDerivAt.tendsto_slope_zero ( HasDerivAt.sin ( hasDerivAt_id 0 |> HasDerivAt.div_const <| 2 ) );
    convert h_sin_y2.pow 2 |> Filter.Tendsto.const_mul 2 using 2 <;> ring;
  -- Use the fact that $\ln(1 - u) \sim -u$ as $u \to 0$.
  have h_log_approx : Filter.Tendsto (fun y : ℝ => Real.log (1 - (1 - Real.cos y)) / (1 - Real.cos y)) (nhdsWithin 0 {0}ᶜ) (nhds (-1)) := by
    have h_log_approx : Filter.Tendsto (fun u : ℝ => Real.log (1 - u) / u) (nhdsWithin 0 {0}ᶜ) (nhds (-1)) := by
      simpa [ div_eq_inv_mul ] using HasDerivAt.tendsto_slope_zero ( HasDerivAt.log ( hasDerivAt_id 0 |> HasDerivAt.const_sub 1 ) ( by norm_num ) );
    refine h_log_approx.comp ?_;
    refine' tendsto_nhdsWithin_iff.mpr _;
    exact ⟨ tendsto_nhdsWithin_of_tendsto_nhds ( Continuous.tendsto' ( by continuity ) _ _ <| by norm_num ), ( h_cos_approx.eventually_ne <| by positivity ) |> fun h => h.mono fun x hx => by aesop ⟩;
  have := h_log_approx.mul h_cos_approx;
  exact this.congr' ( by filter_upwards [ h_log_approx.eventually_ne ( show -1 ≠ 0 by norm_num ) ] with y hy using by rw [ div_mul_div_cancel₀ ( by aesop ) ] ; ring ) |> fun h => h.trans ( by norm_num )

/-
The sequence ((n/2) - floor(n/2 + λ_n√n)) / √n converges to -λ as n → ∞.
-/
lemma convergence_of_coefficient (lambda : ℝ) (lambda_seq : ℕ → ℝ) (h_conv : Filter.Tendsto lambda_seq Filter.atTop (nhds lambda)) :
    Filter.Tendsto (fun (n : ℕ) => ((n : ℝ) / 2 - Int.floor ((n : ℝ) / 2 + lambda_seq n * Real.sqrt n)) / Real.sqrt n) Filter.atTop (nhds (-lambda)) := by
  -- We'll use the fact that $⌊x⌋$ is the greatest integer less than or equal to $x$ to bound the expression.
  have h_floor : ∀ n : ℕ, n > 0 → abs (((n : ℝ) / 2 - ⌊(n : ℝ) / 2 + lambda_seq n * Real.sqrt n⌋) / Real.sqrt n + lambda_seq n) ≤ 1 / Real.sqrt n := by
    intro n hn_pos
    have h_floor : (n : ℝ) / 2 + lambda_seq n * Real.sqrt n - 1 < ⌊(n : ℝ) / 2 + lambda_seq n * Real.sqrt n⌋ ∧ ⌊(n : ℝ) / 2 + lambda_seq n * Real.sqrt n⌋ ≤ (n : ℝ) / 2 + lambda_seq n * Real.sqrt n := by
      exact ⟨ Int.sub_one_lt_floor _, Int.floor_le _ ⟩;
    rw [ abs_le ] ; constructor <;> nlinarith [ show ( 0 :ℝ ) < Real.sqrt n by positivity, div_mul_cancel₀ ( ( n :ℝ ) / 2 - ⌊ ( n :ℝ ) / 2 +lambda_seq n * Real.sqrt n⌋ ) ( ne_of_gt <| Real.sqrt_pos.mpr <| Nat.cast_pos.mpr hn_pos ), div_mul_cancel₀ ( 1 :ℝ ) ( ne_of_gt <| Real.sqrt_pos.mpr <| Nat.cast_pos.mpr hn_pos ) ] ;
  have h_squeeze : Filter.Tendsto (fun n : ℕ => ((n : ℝ) / 2 - ⌊(n : ℝ) / 2 + lambda_seq n * Real.sqrt n⌋) / Real.sqrt n + lambda_seq n) Filter.atTop (nhds 0) := by
    exact squeeze_zero_norm' ( Filter.eventually_atTop.mpr ⟨ 1, fun n hn => h_floor n hn ⟩ ) ( tendsto_const_nhds.div_atTop <| by simpa only [ Real.sqrt_eq_rpow ] using tendsto_rpow_atTop ( by positivity ) |> Filter.Tendsto.comp <| tendsto_natCast_atTop_atTop );
  simpa using h_squeeze.sub h_conv

/-
The integral of the sequence of functions converges to the Gaussian integral.
-/
lemma integral_convergence_lemma (c : ℝ) (c_seq : ℕ → ℝ) (h_c : Filter.Tendsto c_seq Filter.atTop (nhds c)) :
    Filter.Tendsto (fun (n : ℕ) => ∫ y in -Real.pi * Real.sqrt n..Real.pi * Real.sqrt n, (Real.cos (y / (2 * Real.sqrt n))) ^ n * Real.cos (c_seq n * y))
      Filter.atTop
      (nhds (∫ y in Set.univ, Real.exp (-y ^ 2 / 8) * Real.cos (c * y))) := by
  -- The integrand converges pointwise to $e^{-y^2/8} \cos(cy)$.
  have h_pointwise : ∀ y : ℝ, Filter.Tendsto (fun n : ℕ => (Real.cos (y / (2 * Real.sqrt n))) ^ n * Real.cos (c_seq n * y)) Filter.atTop (nhds (Real.exp (-y ^ 2 / 8) * Real.cos (c * y))) := by
    intro y
    have h_cos : Filter.Tendsto (fun n : ℕ => (Real.cos (y / (2 * Real.sqrt n))) ^ n) Filter.atTop (nhds (Real.exp (-y ^ 2 / 8))) := by
      exact?;
    exact h_cos.mul ( Real.continuous_cos.continuousAt.tendsto.comp ( h_c.mul_const y ) );
  have h_dominated : ∀ n : ℕ, ∀ y ∈ Set.Icc (-Real.pi * Real.sqrt n) (Real.pi * Real.sqrt n), abs ((Real.cos (y / (2 * Real.sqrt n))) ^ n * Real.cos (c_seq n * y)) ≤ Real.exp (-y ^ 2 / 8) := by
    intros n y hy
    have h_cos_bound : abs (Real.cos (y / (2 * Real.sqrt n))) ≤ Real.exp (-y ^ 2 / (8 * n)) := by
      -- Using the inequality $\cos(u) \leq e^{-u^2 / 2}$ for $|u| \leq \pi / 2$, we get $\cos(y / (2 \sqrt{n})) \leq e^{-y^2 / (8n)}$.
      have h_cos_ineq : ∀ u : ℝ, abs u ≤ Real.pi / 2 → Real.cos u ≤ Real.exp (-u ^ 2 / 2) := by
        -- Let's choose any $u$ such that $|u| \leq \pi / 2$.
        intro u hu
        have h_cos_ineq : Real.cos u ≤ Real.exp (-u ^ 2 / 2) := by
          have h_cos_deriv : ∀ u : ℝ, 0 ≤ u → u ≤ Real.pi / 2 → Real.cos u ≤ Real.exp (-u ^ 2 / 2) := by
            -- Let's choose any $u$ such that $0 \leq u \leq \pi / 2$.
            intro u hu_nonneg hu_pi_div_two
            have h_cos_deriv : ∀ u : ℝ, 0 ≤ u → u ≤ Real.pi / 2 → deriv (fun u => Real.exp (u ^ 2 / 2) * Real.cos u) u ≤ 0 := by
              intro u hu_nonneg hu_pi_div_two; norm_num [ Real.differentiableAt_exp, Real.differentiableAt_cos ] ; ring_nf; norm_num;
              have := Real.le_tan ( show 0 ≤ u by linarith );
              cases eq_or_lt_of_le hu_pi_div_two <;> simp_all +decide [ Real.tan_eq_sin_div_cos ];
              · positivity;
              · rw [ le_div_iff₀ ( Real.cos_pos_of_mem_Ioo ⟨ by linarith, by linarith ⟩ ) ] at this ; nlinarith [ Real.exp_pos ( u ^ 2 * 2⁻¹ ) ];
            -- Since the derivative of $f(u) = \exp(u^2 / 2) \cos(u)$ is non-positive on $[0, \pi/2]$, we can apply the Mean Value Theorem to $f$ on this interval.
            have h_mvt : ∀ u : ℝ, 0 < u → u ≤ Real.pi / 2 → ∃ c ∈ Set.Ioo 0 u, deriv (fun u => Real.exp (u ^ 2 / 2) * Real.cos u) c = (Real.exp (u ^ 2 / 2) * Real.cos u - Real.exp (0 ^ 2 / 2) * Real.cos 0) / (u - 0) := by
              intros u hu_pos hu_pi_div_two
              apply exists_deriv_eq_slope;
              · exact?;
              · fun_prop;
              · exact Differentiable.differentiableOn ( by norm_num [ Real.differentiable_exp, Real.differentiable_cos ] );
            by_cases hu_pos : 0 < u;
            · obtain ⟨ c, ⟨ hc_left, hc_right ⟩, hc ⟩ := h_mvt u hu_pos hu_pi_div_two ; have := h_cos_deriv c ( by linarith ) ( by linarith ) ; rw [ hc ] at this ; rw [ div_le_iff₀ ] at this <;> norm_num at * <;> try linarith;
              rw [ neg_div, Real.exp_neg ] ; nlinarith [ Real.exp_pos ( u ^ 2 / 2 ), Real.exp_pos ( -u ^ 2 / 2 ), mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos ( u ^ 2 / 2 ) ) ) ];
            · norm_num [ show u = 0 by linarith ]
          cases abs_cases u <;> simp +decide [ * ] at hu ⊢;
          · exact h_cos_deriv u ( by linarith ) hu;
          · simpa [ neg_div ] using h_cos_deriv ( -u ) ( by linarith ) ( by linarith );
        exact h_cos_ineq;
      by_cases hn : n = 0 <;> simp_all +decide [ abs_div, abs_mul, abs_of_nonneg ];
      have := h_cos_ineq ( y / ( 2 * Real.sqrt n ) ) ?_;
      · rw [ abs_of_nonneg ( Real.cos_nonneg_of_mem_Icc ⟨ by rw [ le_div_iff₀ <| by positivity ] ; nlinarith [ Real.pi_pos, Real.sqrt_nonneg n, Real.sq_sqrt <| Nat.cast_nonneg n ], by rw [ div_le_iff₀ <| by positivity ] ; nlinarith [ Real.pi_pos, Real.sqrt_nonneg n, Real.sq_sqrt <| Nat.cast_nonneg n ] ⟩ ) ] ; convert this using 1 ; ring_nf ; norm_num [ hn ];
      · exact abs_le.mpr ⟨ by rw [ le_div_iff₀ ( by positivity ) ] ; linarith, by rw [ div_le_iff₀ ( by positivity ) ] ; linarith ⟩;
    have h_cos_pow_bound : abs ((Real.cos (y / (2 * Real.sqrt n))) ^ n) ≤ Real.exp (-y ^ 2 / 8) := by
      convert pow_le_pow_left₀ ( abs_nonneg _ ) h_cos_bound n using 1 <;> norm_num [ ← Real.exp_nat_mul ] ; ring_nf ; by_cases hn : n = 0 <;> aesop;
    simpa only [ abs_mul ] using mul_le_of_le_one_right ( by positivity ) ( Real.abs_cos_le_one _ ) |> le_trans <| h_cos_pow_bound;
  have h_dominated_convergence : Filter.Tendsto (fun n : ℕ => ∫ y in Set.univ, (Real.cos (y / (2 * Real.sqrt n))) ^ n * Real.cos (c_seq n * y) * (if y ∈ Set.Icc (-Real.pi * Real.sqrt n) (Real.pi * Real.sqrt n) then 1 else 0)) Filter.atTop (nhds (∫ y in Set.univ, Real.exp (-y ^ 2 / 8) * Real.cos (c * y))) := by
    refine' MeasureTheory.tendsto_integral_of_dominated_convergence _ _ _ _ _;
    refine' fun y => Real.exp ( -y ^ 2 / 8 );
    · exact fun n => Measurable.aestronglyMeasurable ( by exact Measurable.mul ( by exact Measurable.mul ( Real.continuous_cos.measurable.comp ( measurable_id'.div_const _ ) |> Measurable.pow_const <| _ ) <| Real.continuous_cos.measurable.comp <| measurable_const.mul measurable_id' ) <| by exact Measurable.ite ( measurableSet_Icc ) measurable_const measurable_const );
    · simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by norm_num ) );
    · field_simp;
      intro n; filter_upwards [ ] with x; split_ifs <;> simp_all +decide [ mul_comm ];
      · simpa only [ neg_div ] using h_dominated n x ( by linarith ) ( by linarith );
      · positivity;
    · filter_upwards [ ] with y;
      refine' Filter.Tendsto.congr' _ ( h_pointwise y );
      filter_upwards [ Filter.eventually_gt_atTop ⌈y ^ 2⌉₊ ] with n hn;
      rw [ if_pos ⟨ by nlinarith [ Nat.le_ceil ( y ^ 2 ), Real.pi_gt_three, show ( n : ℝ ) ≥ ⌈y ^ 2⌉₊ + 1 by exact_mod_cast hn, Real.sqrt_nonneg n, Real.sq_sqrt <| Nat.cast_nonneg n, mul_le_mul_of_nonneg_right ( Real.pi_gt_three.le ) <| Real.sqrt_nonneg n ], by nlinarith [ Nat.le_ceil ( y ^ 2 ), Real.pi_gt_three, show ( n : ℝ ) ≥ ⌈y ^ 2⌉₊ + 1 by exact_mod_cast hn, Real.sqrt_nonneg n, Real.sq_sqrt <| Nat.cast_nonneg n, mul_le_mul_of_nonneg_right ( Real.pi_gt_three.le ) <| Real.sqrt_nonneg n ] ⟩ ] ; ring;
  convert h_dominated_convergence using 2;
  rw [ intervalIntegral.integral_of_le ( by nlinarith [ Real.pi_pos, Real.sqrt_nonneg ↑‹ℕ› ] ) ];
  rw [ ← MeasureTheory.integral_Icc_eq_integral_Ioc, ← MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ]

/-
The integral of e^{-y^2/8} * cos(λy) over the real line is √(8π) * e^{-2λ^2}.
-/
lemma gaussian_integral_cos (lambda : ℝ) :
    ∫ y in Set.univ, Real.exp (-y ^ 2 / 8) * Real.cos (lambda * y) = Real.sqrt (8 * Real.pi) * Real.exp (-2 * lambda ^ 2) := by
  -- Consider the integral $I(\lambda) = \int_{-\infty}^{\infty} e^{-y^2/8} \cos(\lambda y) dy$.
  set I := fun lambda : ℝ => ∫ y in Set.univ, (Real.exp (-y ^ 2 / 8)) * (Real.cos (lambda * y));
  -- To prove the equality, it suffices to show that $I(\lambda)$ satisfies the differential equation $I'(\lambda) = -4\lambda I(\lambda)$ with $I(0) = \sqrt{8\pi}$.
  suffices h_eq : ∀ lambda : ℝ, HasDerivAt I (-4 * lambda * I lambda) lambda ∧ I 0 = Real.sqrt (8 * Real.pi) by
    -- We'll use the fact that if the derivative of a function is given as a linear combination of the function and its argument, then the function is of the form $Ce^{kx}$.
    have h_integral_form : ∀ lambda : ℝ, I lambda = I 0 * Real.exp (-2 * lambda ^ 2) := by
      -- We'll use the fact that if the derivative of a function is given as a linear combination of the function and its argument, then the function is of the form $Ce^{kx}$. We'll apply this to $I(\lambda)$.
      have h_integral_form : ∀ lambda : ℝ, HasDerivAt (fun lambda => I lambda * Real.exp (2 * lambda ^ 2)) 0 lambda := by
        intro lambda; convert HasDerivAt.mul ( h_eq lambda |>.1 ) ( HasDerivAt.exp ( HasDerivAt.const_mul 2 ( hasDerivAt_pow 2 lambda ) ) ) using 1 ; ring;
      -- By fundamental theorem of calculus, if the derivative of a function is zero, then the function is constant.
      have h_const : ∀ a b : ℝ, ∫ x in a..b, deriv (fun lambda => I lambda * Real.exp (2 * lambda ^ 2)) x = I b * Real.exp (2 * b ^ 2) - I a * Real.exp (2 * a ^ 2) := by
        intros a b; rw [ intervalIntegral.integral_deriv_eq_sub ];
        · exact fun x hx => HasDerivAt.differentiableAt ( h_integral_form x );
        · exact ( by rw [ show deriv _ = _ from funext fun x => HasDerivAt.deriv ( h_integral_form x ) ] ; norm_num );
      intro x; specialize h_const 0 x; rw [ funext fun _ => HasDerivAt.deriv ( h_integral_form _ ) ] at h_const; norm_num at h_const;
      simpa [ Real.exp_neg ] using eq_div_of_mul_eq ( ne_of_gt ( Real.exp_pos _ ) ) ( by linarith );
    exact h_eq 0 |>.2 ▸ h_integral_form _;
  -- To prove the differential equation, we use the fact that the derivative of the integral of a product is the integral of the product of the derivatives.
  have h_deriv : ∀ lambda : ℝ, HasDerivAt (fun lambda => ∫ y in Set.univ, (Real.exp (-y ^ 2 / 8)) * (Real.cos (lambda * y))) (∫ y in Set.univ, (Real.exp (-y ^ 2 / 8)) * (-y * Real.sin (lambda * y))) lambda := by
    intro lambda;
    rw [ hasDerivAt_iff_tendsto_slope_zero ];
    -- Apply the dominated convergence theorem to interchange the limit and the integral.
    have h_dominated : Filter.Tendsto (fun t => ∫ y in Set.univ, (Real.exp (-y ^ 2 / 8)) * ((Real.cos ((lambda + t) * y) - Real.cos (lambda * y)) / t)) (nhdsWithin 0 {0}ᶜ) (nhds (∫ y in Set.univ, (Real.exp (-y ^ 2 / 8)) * (-y * Real.sin (lambda * y)))) := by
      refine' MeasureTheory.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _;
      use fun y => Real.exp ( -y ^ 2 / 8 ) * |y|;
      · exact Filter.Eventually.of_forall fun n => Continuous.aestronglyMeasurable ( by continuity );
      · refine' Filter.eventually_of_mem self_mem_nhdsWithin fun n hn => Filter.Eventually.of_forall fun x => _;
        -- Use the trigonometric identity for the difference of cosines: $\cos(a) - \cos(b) = -2 \sin\left(\frac{a + b}{2}\right) \sin\left(\frac{a - b}{2}\right)$.
        have h_cos_diff : Real.cos ((lambda + n) * x) - Real.cos (lambda * x) = -2 * Real.sin ((lambda + n / 2) * x) * Real.sin (n * x / 2) := by
          rw [ Real.cos_sub_cos ] ; ring;
        -- Use the fact that $|\sin(y)| \leq |y|$ for all $y$.
        have h_sin_bound : |Real.sin (n * x / 2)| ≤ |n * x / 2| := by
          exact?;
        simp_all +decide [ abs_div, abs_mul, div_le_iff₀ ];
        exact mul_le_mul_of_nonneg_left ( by rw [ div_le_iff₀ ( abs_pos.mpr hn ) ] ; nlinarith [ abs_nonneg ( Real.sin ( ( lambda + n / 2 ) * x ) ), abs_nonneg ( Real.sin ( n * x / 2 ) ), Real.abs_sin_le_one ( ( lambda + n / 2 ) * x ), Real.abs_sin_le_one ( n * x / 2 ) ] ) ( by positivity );
      · have := @integrable_rpow_mul_exp_neg_mul_sq;
        specialize @this ( 1 / 8 ) ( by norm_num ) ( 1 : ℝ ) ( by norm_num );
        simpa [ div_eq_inv_mul, mul_comm ] using this.norm;
      · refine' Filter.Eventually.of_forall fun x => _;
        refine' Filter.Tendsto.mul tendsto_const_nhds _;
        simpa [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm ] using HasDerivAt.tendsto_slope_zero ( HasDerivAt.cos ( HasDerivAt.mul ( hasDerivAt_id 0 |> HasDerivAt.const_add lambda ) ( hasDerivAt_const _ x ) ) );
    convert h_dominated using 2;
    rw [ ← MeasureTheory.integral_sub ];
    · rw [ ← MeasureTheory.integral_smul ] ; congr ; ext ; ring;
      norm_num ; ring;
    · refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun y => Real.exp ( -y ^ 2 / 8 );
      · simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by norm_num ) );
      · exact Continuous.aestronglyMeasurable ( by continuity );
      · filter_upwards [ ] using fun x => by simpa using mul_le_mul_of_nonneg_left ( Real.abs_cos_le_one _ ) ( by positivity ) ;
    · refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun y => Real.exp ( -y ^ 2 / 8 );
      · simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by norm_num ) );
      · exact Continuous.aestronglyMeasurable ( by continuity );
      · filter_upwards [ ] using fun x => by simpa using mul_le_mul_of_nonneg_left ( Real.abs_cos_le_one _ ) ( by positivity ) ;
  -- Now consider the integral $\int_{-\infty}^{\infty} e^{-y^2/8} y \sin(\lambda y) dy$.
  have h_integral : ∀ lambda : ℝ, ∫ y in Set.univ, (Real.exp (-y ^ 2 / 8)) * (y * Real.sin (lambda * y)) = 4 * lambda * ∫ y in Set.univ, (Real.exp (-y ^ 2 / 8)) * (Real.cos (lambda * y)) := by
    intro lambda
    have h_integral : ∀ a b : ℝ, ∫ y in a..b, (Real.exp (-y ^ 2 / 8)) * (y * Real.sin (lambda * y)) = -4 * (Real.exp (-b ^ 2 / 8)) * Real.sin (lambda * b) + 4 * (Real.exp (-a ^ 2 / 8)) * Real.sin (lambda * a) + 4 * lambda * ∫ y in a..b, (Real.exp (-y ^ 2 / 8)) * Real.cos (lambda * y) := by
      intro a b;
      rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
      rotate_right;
      use fun x => -4 * Real.exp (-x ^ 2 / 8) * Real.sin (lambda * x) + 4 * lambda * ∫ y in a..x, Real.exp (-y ^ 2 / 8) * Real.cos (lambda * y);
      · norm_num ; ring;
      · intro x hx;
        -- The derivative of the integral term can be computed using the Fundamental Theorem of Calculus.
        have h_ftc : HasDerivAt (fun x => ∫ y in a..x, Real.exp (-y ^ 2 / 8) * Real.cos (lambda * y)) (Real.exp (-x ^ 2 / 8) * Real.cos (lambda * x)) x := by
          apply_rules [ intervalIntegral.integral_hasDerivAt_right ];
          · exact Continuous.intervalIntegrable ( by continuity ) _ _;
          · exact Continuous.stronglyMeasurable ( by continuity ) |> fun h => h.stronglyMeasurableAtFilter;
          · fun_prop;
        convert HasDerivAt.add ( HasDerivAt.mul ( HasDerivAt.mul ( hasDerivAt_const _ _ ) ( HasDerivAt.exp ( HasDerivAt.div_const ( HasDerivAt.neg ( hasDerivAt_pow 2 x ) ) _ ) ) ) ( HasDerivAt.sin ( HasDerivAt.const_mul _ ( hasDerivAt_id x ) ) ) ) ( HasDerivAt.mul ( hasDerivAt_const _ _ ) h_ftc ) using 1 ; ring;
        norm_num ; ring;
      · exact Continuous.intervalIntegrable ( by continuity ) _ _;
    -- Let's take the limit of the integral as $a \to -\infty$ and $b \to \infty$.
    have h_limit : Filter.Tendsto (fun b => ∫ y in (-b)..b, (Real.exp (-y ^ 2 / 8)) * (y * Real.sin (lambda * y))) Filter.atTop (nhds (∫ y in Set.univ, (Real.exp (-y ^ 2 / 8)) * (y * Real.sin (lambda * y)))) ∧ Filter.Tendsto (fun b => ∫ y in (-b)..b, (Real.exp (-y ^ 2 / 8)) * Real.cos (lambda * y)) Filter.atTop (nhds (∫ y in Set.univ, (Real.exp (-y ^ 2 / 8)) * Real.cos (lambda * y))) := by
      constructor <;> norm_num;
      · apply_rules [ MeasureTheory.intervalIntegral_tendsto_integral ];
        · have h_integrable : MeasureTheory.Integrable (fun x => Real.exp (-x ^ 2 / 8) * x) MeasureTheory.MeasureSpace.volume := by
            have := @integrable_rpow_mul_exp_neg_mul_sq;
            convert @this ( 1 / 8 ) ( by norm_num ) 1 ( by norm_num ) using 1 ; norm_num ; ring;
          refine' h_integrable.norm.mono' _ _;
          · exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( by continuity ) ) ( MeasureTheory.AEStronglyMeasurable.mul ( continuous_id.aestronglyMeasurable ) ( Real.continuous_sin.comp_aestronglyMeasurable ( by exact Continuous.aestronglyMeasurable ( by continuity ) ) ) );
          · filter_upwards [ ] with x using by simpa [ abs_mul ] using mul_le_mul_of_nonneg_left ( mul_le_of_le_one_right ( abs_nonneg _ ) ( Real.abs_sin_le_one _ ) ) ( by positivity ) ;
        · exact Filter.tendsto_neg_atTop_atBot;
        · exact Filter.tendsto_id;
      · apply_rules [ MeasureTheory.intervalIntegral_tendsto_integral ];
        · refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun x => Real.exp ( -x ^ 2 / 8 );
          · simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by norm_num ) );
          · exact Continuous.aestronglyMeasurable ( by continuity );
          · filter_upwards [ ] using fun x => by simpa using mul_le_mul_of_nonneg_left ( Real.abs_cos_le_one _ ) ( by positivity ) ;
        · exact Filter.tendsto_neg_atTop_atBot;
        · exact Filter.tendsto_id;
    -- Apply the fact that the limit of a sum is the sum of the limits.
    have h_sum : Filter.Tendsto (fun b => -4 * Real.exp (-b ^ 2 / 8) * Real.sin (lambda * b) + 4 * Real.exp (-(-b) ^ 2 / 8) * Real.sin (lambda * (-b)) + 4 * lambda * ∫ y in (-b)..b, (Real.exp (-y ^ 2 / 8)) * Real.cos (lambda * y)) Filter.atTop (nhds (4 * lambda * ∫ y in Set.univ, (Real.exp (-y ^ 2 / 8)) * Real.cos (lambda * y))) := by
      have h_sum : Filter.Tendsto (fun b => -4 * Real.exp (-b ^ 2 / 8) * Real.sin (lambda * b) + 4 * Real.exp (-b ^ 2 / 8) * Real.sin (lambda * (-b))) Filter.atTop (nhds 0) := by
        norm_num [ Real.sin_neg ];
        ring_nf;
        exact squeeze_zero_norm ( fun x => by simpa using mul_le_mul_of_nonneg_right ( mul_le_of_le_one_right ( by positivity ) ( Real.abs_sin_le_one _ ) ) ( by positivity ) ) ( by simpa using Filter.Tendsto.mul ( Real.tendsto_exp_atBot.comp <| by exact Filter.tendsto_atTop_atBot.mpr fun x => ⟨ |x| * 8 + 1, fun y hy => by cases abs_cases x <;> nlinarith ⟩ ) tendsto_const_nhds );
      simpa using h_sum.add ( h_limit.2.const_mul ( 4 * lambda ) );
    exact tendsto_nhds_unique h_limit.1 ( h_sum.congr fun b => by rw [ h_integral ] );
  simp +zetaDelta at *;
  exact fun x => ⟨ by simpa [ MeasureTheory.integral_neg, h_integral ] using h_deriv x, by simpa [ div_eq_inv_mul ] using integral_gaussian ( 1 / 8 ) ⟩

/-
Scaled integral representation of the binomial coefficient after change of variables.
-/
lemma binomial_integral_scaled (n k : ℕ) (hn : n > 0) :
    Real.sqrt n / (2 ^ n) * (Nat.choose n k : ℝ) =
    1 / (2 * Real.pi) * ∫ y in -Real.pi * Real.sqrt n..Real.pi * Real.sqrt n,
      (Real.cos (y / (2 * Real.sqrt n))) ^ n * Real.cos (((n : ℝ) / 2 - k) / Real.sqrt n * y) := by
  have := @binomial_integral_representation n k;
  convert congr_arg ( fun x : ℝ => Real.sqrt n * x ) this using 1;
  · ring;
  · field_simp;
    convert intervalIntegral.integral_comp_div _ _ using 3 <;> ring <;> norm_num [ hn.ne' ]

/-
Asymptotic relationship between binomial coefficients and Gaussian integrals.
For v = n/2 + λₙ√n with λₙ → λ, we have:
√n / 2^n * C(n, v) → (1/√(2π)) ∫_{-∞}^{∞} e^{-x²/8} cos(λx) dx = √(8π) e^{-2λ²} / (2π)
-/
theorem problem_116_asymptotic (lambda : ℝ) (lambda_seq : ℕ → ℝ) (h_conv : Filter.Tendsto lambda_seq Filter.atTop (nhds lambda)) :
    Filter.Tendsto (fun (n : ℕ) =>
      Real.sqrt (n : ℝ) / ((2 : ℝ) ^ n) * (Nat.choose n (⌊(n : ℝ)/2 + lambda_seq n * Real.sqrt n⌋.natAbs)))
      Filter.atTop
      (nhds ((Real.sqrt (8 * Real.pi)) * Real.exp (-2 * lambda ^ 2) / (2 * Real.pi))) := by
  by_cases h : Filter.Tendsto ( fun n : ℕ => Int.floor ( ( n : ℝ ) / 2 + lambda_seq n * Real.sqrt n ) ) Filter.atTop Filter.atTop <;> simp_all +decide;
  · -- Using the integral representation of the binomial coefficient and the convergence of the integral.
    have h_integral : Filter.Tendsto (fun n : ℕ => (1 / (2 * Real.pi)) * ∫ y in (-Real.pi * Real.sqrt n)..Real.pi * Real.sqrt n, (Real.cos (y / (2 * Real.sqrt n))) ^ n * Real.cos (((n : ℝ) / 2 - Int.floor ((n : ℝ) / 2 + (lambda_seq n) * Real.sqrt n)) / Real.sqrt n * y)) Filter.atTop (nhds (Real.sqrt (8 * Real.pi) * Real.exp (-2 * lambda ^ 2) / (2 * Real.pi))) := by
      have h_integral_converge : Filter.Tendsto (fun n : ℕ => ∫ y in (-Real.pi * Real.sqrt n)..Real.pi * Real.sqrt n, (Real.cos (y / (2 * Real.sqrt n))) ^ n * Real.cos (((n : ℝ) / 2 - Int.floor ((n : ℝ) / 2 + (lambda_seq n) * Real.sqrt n)) / Real.sqrt n * y)) Filter.atTop (nhds (∫ y in Set.univ, Real.exp (-y ^ 2 / 8) * Real.cos (-lambda * y))) := by
        convert integral_convergence_lemma ( -lambda ) ( fun n => ( ( n : ℝ ) / 2 - Int.floor ( ( n : ℝ ) / 2 + lambda_seq n * Real.sqrt n ) ) / Real.sqrt n ) _ using 2;
        refine' convergence_of_coefficient _ _ h_conv;
      convert h_integral_converge.const_mul ( 1 / ( 2 * Real.pi ) ) using 2;
      rw [ show ( ∫ y in Set.univ, Real.exp ( -y ^ 2 / 8 ) * Real.cos ( -lambda * y ) ) = Real.sqrt ( 8 * Real.pi ) * Real.exp ( -2 *lambda ^ 2 ) by simpa [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm ] using @gaussian_integral_cos ( -lambda ) ] ; ring;
    refine' h_integral.congr' _ |> fun h => h.trans _;
    · filter_upwards [ h.eventually_gt_atTop 0, Filter.eventually_gt_atTop 0 ] with n hn hn';
      convert Eq.symm ( binomial_integral_scaled n ( Int.natAbs ⌊ ( n : ℝ ) / 2 + lambda_seq n * Real.sqrt n⌋ ) hn' ) using 1 ; norm_num [ abs_of_pos, hn, hn' ];
    · norm_num;
  · contrapose! h;
    refine' tendsto_floor_atTop.comp _;
    -- We'll use the fact that if the denominator grows faster than the numerator, the limit will tend to infinity.
    have h_lim : Filter.Tendsto (fun n : ℕ => (n : ℝ) / 2 + lambda_seq n * Real.sqrt n) Filter.atTop Filter.atTop := by
      have h_aux : Filter.Tendsto (fun n : ℕ => (n : ℝ) / 2 - |lambda_seq n| * Real.sqrt n) Filter.atTop Filter.atTop := by
        -- We can factor out $\sqrt{n}$ and use the fact that $|\lambda_n|$ is bounded.
        have h_factor : Filter.Tendsto (fun n : ℕ => Real.sqrt n * (Real.sqrt n / 2 - |lambda_seq n|)) Filter.atTop Filter.atTop := by
          -- Since $|\lambda_n|$ is bounded, we have $\sqrt{n} / 2 - |\lambda_n| \to \infty$ as $n \to \infty$.
          have h_bound : Filter.Tendsto (fun n : ℕ => Real.sqrt n / 2 - |lambda_seq n|) Filter.atTop Filter.atTop := by
            exact Filter.Tendsto.atTop_add ( Filter.Tendsto.atTop_div_const ( by norm_num ) ( by simpa only [ Real.sqrt_eq_rpow ] using tendsto_rpow_atTop ( by norm_num ) |> Filter.Tendsto.comp <| tendsto_natCast_atTop_atTop ) ) ( Filter.Tendsto.neg <| Filter.Tendsto.abs h_conv );
          exact Filter.Tendsto.atTop_mul_atTop₀ ( by simpa only [ Real.sqrt_eq_rpow ] using tendsto_rpow_atTop ( by norm_num ) |> Filter.Tendsto.comp <| tendsto_natCast_atTop_atTop ) h_bound;
        exact h_factor.congr fun n => by rw [ mul_sub, mul_div, mul_comm ] ; rw [ Real.mul_self_sqrt ( Nat.cast_nonneg _ ) ] ; ring;
      rw [ Filter.tendsto_atTop_atTop ] at *;
      exact fun b => by obtain ⟨ i, hi ⟩ := h_aux b; exact ⟨ i, fun n hin => by cases abs_cases ( lambda_seq n ) <;> nlinarith [ hi n hin, Real.sqrt_nonneg n ] ⟩ ;
    convert h_lim using 1