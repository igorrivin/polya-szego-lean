/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 47b95805-456f-4bc4-8fdd-b946e654bd7a
-/

/-
We prove Polya-Szego Problem 133 regarding the uniform convergence of a sequence of convolution integrals to the function f(x).
We define the normalization constant C_n correctly as (1/2) * \prod_{k=0}^{n-1} (2k+3)/(2k+2) to match the problem statement and avoid division by zero.
We show that the kernel K_n(u) = C_n (1-u^2)^n is an approximation of identity, specifically that it integrates to 1 and its mass concentrates near 0.
We then split the integral into a term involving f(x-u) - f(x) and a term involving f(x), showing that the first tends to 0 and the second tends to f(x) uniformly.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Set
open Real
open Interval
open scoped Real
open ComplexConjugate
open BigOperators

/-
The product of the normalization constant $C_n$ and the integral $J_n = \int_{-1}^1 (1-t^2)^n dt$ is exactly 1.
-/
open Filter

def C_n (n : ℕ) : ℝ := (1/2 : ℝ) * ∏ k ∈ Finset.range n, ((2:ℝ) * (k+1) + 1) / ((2:ℝ) * (k+1))

def J_n (n : ℕ) : ℝ := ∫ t in (-1:ℝ)..1, (1 - t^2)^n

lemma C_n_mul_J_n_eq_one (n : ℕ) : C_n n * J_n n = 1 := by
  -- We'll use the fact that $J_n = \int_{-1}^1 (1-t^2)^n dt = 2 \int_0^1 (1-t^2)^n dt$.
  suffices h1 : J_n n = 2 * ∫ (t : ℝ) in Set.Icc 0 1, (1 - t ^ 2) ^ n by
    -- Using the substitution $t = \sin \theta$, we get $J_n = 2 \int_0^{\pi/2} \cos^{2n+1} \theta d\theta$.
    have h2 : J_n n = 2 * ∫ (θ : ℝ) in (0 : ℝ)..Real.pi / 2, Real.cos θ ^ (2 * n + 1) := by
      rw [ h1, MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ];
      · have h_subst : ∀ a b : ℝ, 0 ≤ a → a ≤ b → b ≤ Real.pi / 2 → ∫ x in a..b, Real.cos x ^ (2 * n + 1) = ∫ x in Real.sin a..Real.sin b, (1 - x ^ 2) ^ n := by
          intros a b _ _ _; rw [ ← intervalIntegral.integral_comp_mul_deriv ] ; norm_num;
          exacts [ intervalIntegral.integral_congr fun x _ => by rw [ ← Real.cos_sq' ] ; ring, fun x _ => Real.hasDerivAt_sin x, Continuous.continuousOn <| by continuity, by continuity ];
        rw [ h_subst 0 ( Real.pi / 2 ) le_rfl ( by linarith [ Real.pi_pos ] ) le_rfl ] ; norm_num;
      · norm_num;
    -- Using the Wallis formula for $\int_0^{\pi/2} \cos^{2n+1} \theta d\theta = \frac{(2n)!!}{(2n+1)!!}$, we have $J_n = 2 \frac{(2n)!!}{(2n+1)!!}$.
    have h3 : J_n n = 2 * ((Nat.doubleFactorial (2 * n)) / (Nat.doubleFactorial (2 * n + 1)) : ℝ) := by
      rw [ h2 ];
      induction' n with n ih;
      · norm_num;
      · induction' n + 1 with n ih <;> norm_num [ Nat.mul_succ, integral_cos_pow ] at *;
        rw [ ih, div_mul_div_comm ] ; ring;
    -- On the other hand, $C_n = \frac{1}{2} \prod_{k=1}^n \frac{2k+1}{2k} = \frac{1}{2} \frac{(2n+1)!!}{(2n)!!}$.
    have h4 : C_n n = (1 / 2) * ((Nat.doubleFactorial (2 * n + 1)) / (Nat.doubleFactorial (2 * n)) : ℝ) := by
      unfold C_n; norm_num [ Finset.prod_mul_distrib ];
      congr 1;
      · exact Nat.recOn n ( by norm_num ) fun n ih => by norm_num [ Nat.mul_succ, Finset.prod_range_succ, Nat.factorial ] at * ; nlinarith;
      · exact Nat.recOn n ( by norm_num ) fun n ih => by norm_num [ Nat.mul_succ, Finset.prod_range_succ, pow_succ' ] at * ; nlinarith;
    rw [ h3, h4 ] ; ring_nf ;
    field_simp [mul_comm, mul_assoc, mul_left_comm];
  rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ] <;> norm_num [ J_n ];
  rw [ two_mul, ← intervalIntegral.integral_add_adjacent_intervals ];
  rw [ ← intervalIntegral.integral_comp_neg, neg_zero ];
  · norm_num;
  · exact Continuous.intervalIntegrable ( by continuity ) _ _;
  · exact Continuous.intervalIntegrable ( by continuity ) _ _

/-
The mass of the kernel $K_n(t)$ outside any neighborhood $(-\delta, \delta)$ of 0 tends to 0 as $n \to \infty$.
-/
open Filter

def K_n (n : ℕ) (u : ℝ) : ℝ := C_n n * (1 - u^2)^n

lemma kernel_mass_concentration (δ : ℝ) (hδ : 0 < δ) (hδ1 : δ < 1) :
    Tendsto (fun n => ∫ t in Set.Icc (-1) 1 \ Set.Ioo (-δ) δ, K_n n t) atTop (nhds 0) := by
  -- We know that $K_n(t) \leq K_n(\delta) = C_n (1-\delta^2)^n$ for $t \in [\delta, 1]$.
  have h_bound : ∀ n : ℕ, ∫ t in Set.Icc (-1) 1 \ Set.Ioo (-δ) δ, K_n n t ≤ 2 * (1 - δ) * C_n n * (1 - δ^2)^n := by
    intro n
    have h_int_bound : ∫ t in Set.Icc (-1) 1 \ Set.Ioo (-δ) δ, K_n n t ≤ ∫ t in Set.Icc (-1) 1 \ Set.Ioo (-δ) δ, C_n n * (1 - δ^2)^n := by
      refine' MeasureTheory.setIntegral_mono_on _ _ _ _ <;> norm_num [ K_n ];
      · exact Continuous.integrableOn_Icc ( show Continuous ( K_n n ) from by unfold K_n; continuity ) |> fun h => h.mono_set <| Set.diff_subset;
      · exact Continuous.integrableOn_Icc ( by continuity ) |> fun h => h.mono_set ( Set.diff_subset );
      · exact fun x hx₁ hx₂ hx₃ => mul_le_mul_of_nonneg_left ( pow_le_pow_left₀ ( by nlinarith ) ( by contrapose! hx₃; constructor <;> nlinarith ) _ ) ( show 0 ≤ C_n n by exact mul_nonneg ( by norm_num ) <| Finset.prod_nonneg fun _ _ => by positivity );
    -- Let's simplify the integral $\int_{-1}^1 \setminus (-δ, δ)$.
    have h_simplify : ∫ t in Set.Icc (-1) 1 \ Set.Ioo (-δ) δ, (1 : ℝ) = 2 * (1 - δ) := by
      rw [ MeasureTheory.integral_diff ] <;> norm_num [ hδ.le, hδ1.le ] ; ring;
      exact Set.Ioo_subset_Icc_self.trans ( Set.Icc_subset_Icc ( by linarith ) ( by linarith ) );
    simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
  -- We know that $C_n \sim \sqrt{n}$. Specifically $C_n \le O(\sqrt{n})$.
  have h_C_n_bound : ∃ C : ℝ, ∀ n : ℕ, C_n n ≤ C * Real.sqrt (n + 1) := by
    use 2;
    intro n
    have h_prod_bound : ∏ k ∈ Finset.range n, ((2 * (k + 1) + 1) : ℝ) / (2 * (k + 1)) ≤ Real.sqrt (2 * n + 1) := by
      refine Real.le_sqrt_of_sq_le ?_;
      induction n <;> norm_num [ Finset.prod_range_succ ] at *;
      rw [ mul_div_mul_comm ];
      rw [ mul_pow, div_pow ] at *;
      exact le_trans ( mul_le_mul_of_nonneg_right ‹_› ( sq_nonneg _ ) ) ( by rw [ div_pow, mul_div, div_le_iff₀ ] <;> ring <;> nlinarith );
    exact le_trans ( mul_le_mul_of_nonneg_left h_prod_bound <| by positivity ) <| by nlinarith [ Real.sqrt_nonneg ( 2 * n + 1 ), Real.sqrt_nonneg ( n + 1 ), Real.mul_self_sqrt ( show ( 0:ℝ ) ≤ 2 * n + 1 by positivity ), Real.mul_self_sqrt ( show ( 0:ℝ ) ≤ n + 1 by positivity ) ] ;
  -- Using the bound $C_n \leq C \sqrt{n}$, we get $2 * (1 - δ) * C_n n * (1 - δ^2)^n \leq 2 * (1 - δ) * C * \sqrt{n} * (1 - δ^2)^n$.
  obtain ⟨C, hC⟩ : ∃ C : ℝ, ∀ n : ℕ, C_n n ≤ C * Real.sqrt (n + 1) := h_C_n_bound;
  have h_final_bound : ∀ n : ℕ, ∫ t in Set.Icc (-1) 1 \ Set.Ioo (-δ) δ, K_n n t ≤ 2 * (1 - δ) * C * Real.sqrt (n + 1) * (1 - δ^2)^n := by
    exact fun n => le_trans ( h_bound n ) ( by nlinarith [ hC n, show 0 ≤ 2 * ( 1 - δ ) * ( 1 - δ ^ 2 ) ^ n by exact mul_nonneg ( mul_nonneg zero_le_two ( by linarith ) ) ( pow_nonneg ( by nlinarith ) _ ) ] );
  -- We know that $\sqrt{n} (1 - \delta^2)^n$ tends to $0$ as $n \to \infty$.
  have h_sqrt_exp : Filter.Tendsto (fun n : ℕ => Real.sqrt (n + 1) * (1 - δ^2)^n) Filter.atTop (nhds 0) := by
    -- We can factor out $(1 - \delta^2)^n$ and use the fact that $\sqrt{n} (1 - \delta^2)^n$ tends to $0$ as $n \to \infty$.
    have h_sqrt_exp : Filter.Tendsto (fun n : ℕ => (n : ℝ) * (1 - δ^2)^n) Filter.atTop (nhds 0) := by
      -- We can use the fact that $n r^n \to 0$ as $n \to \infty$ for $|r| < 1$.
      have h_lim : ∀ r : ℝ, |r| < 1 → Filter.Tendsto (fun n : ℕ => (n : ℝ) * r^n) Filter.atTop (nhds 0) := by
        exact?;
      exact h_lim _ ( abs_lt.mpr ⟨ by nlinarith, by nlinarith ⟩ );
    refine' squeeze_zero_norm' _ h_sqrt_exp;
    filter_upwards [ Filter.eventually_gt_atTop 1 ] with n hn using by rw [ Real.norm_of_nonneg ( mul_nonneg ( Real.sqrt_nonneg _ ) ( pow_nonneg ( by nlinarith ) _ ) ) ] ; exact mul_le_mul_of_nonneg_right ( Real.sqrt_le_iff.mpr ⟨ by positivity, by norm_cast; nlinarith ⟩ ) ( pow_nonneg ( by nlinarith ) _ ) ;
  exact squeeze_zero ( fun n => MeasureTheory.setIntegral_nonneg ( by norm_num ) fun x hx => by exact mul_nonneg ( show ( 0 : ℝ ) ≤ C_n n by exact mul_nonneg ( by norm_num ) <| Finset.prod_nonneg fun _ _ => div_nonneg ( by positivity ) <| by positivity ) <| pow_nonneg ( by nlinarith [ hx.1.1, hx.1.2 ] ) _ ) h_final_bound <| by simpa [ mul_assoc ] using h_sqrt_exp.const_mul ( 2 * ( 1 - δ ) * C ) ;

/-
The integral of the kernel $K_n(u)$ over $[x-1, x]$ converges uniformly to 1 for $x \in [\epsilon, 1-\epsilon]$.
-/
open Filter

lemma integral_Kn_tendsto_one_uniform (ε : ℝ) (hε : 0 < ε) (hε_half : ε < 1/2) :
    TendstoUniformlyOn
      (fun n x => ∫ u in (x - 1)..x, K_n n u)
      (fun _ => 1)
      atTop
      (Set.uIcc ε (1 - ε)) := by
  rw [ Metric.tendstoUniformlyOn_iff ];
  intro ε' hε'
  have h_bound : ∀ n : ℕ, ∀ x ∈ Set.Icc ε (1 - ε), |1 - ∫ u in (x - 1)..x, K_n n u| ≤ ∫ u in Set.Icc (-1) 1 \ Set.Ioo (-ε) ε, |K_n n u| := by
    intros n x hx
    have h_integral_bound : 1 - ∫ u in (x - 1)..x, K_n n u = ∫ u in Set.Icc (-1) 1 \ Set.Ioo (x - 1) x, K_n n u := by
      have h_integral_bound : 1 = ∫ u in Set.Icc (-1 : ℝ) 1, K_n n u := by
        rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ] <;> norm_num [ K_n ];
        exact Eq.symm ( C_n_mul_J_n_eq_one n );
      rw [ h_integral_bound, MeasureTheory.integral_diff ] <;> norm_num [ hx.1, hx.2 ];
      · rw [ ← MeasureTheory.integral_Ioc_eq_integral_Ioo, ← intervalIntegral.integral_of_le ] <;> norm_num [ ← h_integral_bound ];
      · exact Continuous.integrableOn_Icc ( by exact Continuous.mul ( continuous_const ) ( by exact Continuous.pow ( by exact continuous_const.sub ( continuous_pow 2 ) ) _ ) );
      · exact fun u hu => ⟨ by linarith [ hu.1, hu.2, hx.1, hx.2 ], by linarith [ hu.1, hu.2, hx.1, hx.2 ] ⟩;
    refine' h_integral_bound ▸ le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) ) ( MeasureTheory.setIntegral_mono_set _ _ _ );
    · exact Continuous.integrableOn_Icc ( by exact Continuous.abs <| by exact Continuous.mul ( continuous_const ) <| by exact Continuous.pow ( by continuity ) _ ) |> fun h => h.mono_set <| Set.diff_subset;
    · exact Filter.Eventually.of_forall fun _ => norm_nonneg _;
    · exact MeasureTheory.ae_of_all _ fun u hu => ⟨ hu.1, fun hu' => hu.2 <| ⟨ by linarith [ hu'.1, hu'.2, hx.1, hx.2 ], by linarith [ hu'.1, hu'.2, hx.1, hx.2 ] ⟩ ⟩;
  -- Since $|K_n(u)| = K_n(u)$ for $u \in [-1, 1]$, we can simplify the bound to $\int_{-1}^1 K_n(u) du - \int_{x-1}^x K_n(u) du$.
  have h_simplified_bound : ∀ n : ℕ, ∀ x ∈ Set.Icc ε (1 - ε), |1 - ∫ u in (x - 1)..x, K_n n u| ≤ ∫ u in Set.Icc (-1) 1 \ Set.Ioo (-ε) ε, K_n n u := by
    intro n x hx; convert h_bound n x hx using 1; refine' MeasureTheory.setIntegral_congr_fun _ _ ; aesop;
    exact fun u hu => by rw [ abs_of_nonneg ( show 0 ≤ K_n n u from mul_nonneg ( show 0 ≤ C_n n from mul_nonneg ( by norm_num ) ( Finset.prod_nonneg fun _ _ => div_nonneg ( by positivity ) ( by positivity ) ) ) ( pow_nonneg ( by nlinarith [ hu.1.1, hu.1.2 ] ) _ ) ) ] ;
  have := kernel_mass_concentration ε hε ( by linarith );
  filter_upwards [ this.eventually ( gt_mem_nhds hε' ) ] with n hn using fun x hx => lt_of_le_of_lt ( h_simplified_bound n x <| by constructor <;> cases Set.mem_uIcc.mp hx <;> linarith ) hn

/-
The integral $\int_{x-1}^x (f(x-u) - f(x)) K_n(u) du$ converges uniformly to 0 for $x \in [\epsilon, 1-\epsilon]$.
-/
open Filter

lemma integral_diff_tendsto_zero_uniform (f : ℝ → ℝ) (hf : ContinuousOn f (Set.uIcc (0 : ℝ) 1))
    (ε : ℝ) (hε : 0 < ε) (hε_half : ε < 1/2) :
    TendstoUniformlyOn
      (fun n x => ∫ u in (x - 1)..x, (f (x - u) - f x) * K_n n u)
      (fun _ => 0)
      atTop
      (Set.uIcc ε (1 - ε)) := by
  -- Given a continuous function $f$ on $[0, 1]$, for every $\eta > 0$, there exists an $\epsilon > 0$ such that $|f(y) - f(x)| < \eta$ whenever $|y - x| < \epsilon$.
  have h_unif_cont : ∀ η > 0, ∃ δ > 0, ∀ x ∈ Set.Icc ε (1 - ε), ∀ u ∈ Set.Icc (-1) 1, abs u < δ → abs (f (x - u) - f x) < η := by
    -- Since $f$ is uniformly continuous on $[0, 1]$, for every $\eta > 0$, there exists a $\delta > 0$ such that $|f(y) - f(x)| < \eta$ whenever $|y - x| < \delta$.
    have h_unif_cont : ∀ η > 0, ∃ δ > 0, ∀ x y : ℝ, 0 ≤ x → x ≤ 1 → 0 ≤ y → y ≤ 1 → abs (x - y) < δ → abs (f x - f y) < η := by
      intro η hη; have := Metric.uniformContinuousOn_iff.mp ( isCompact_Icc.uniformContinuousOn_of_continuous hf ) η hη; aesop;
    intro η η_pos; rcases h_unif_cont η η_pos with ⟨ δ, δ_pos, H ⟩ ; exact ⟨ Min.min δ ( ε / 2 ), by positivity, fun x hx u hu hu' => H _ _ ( by linarith [ hx.1, hx.2, hu.1, hu.2, abs_lt.mp hu', min_le_left δ ( ε / 2 ), min_le_right δ ( ε / 2 ) ] ) ( by linarith [ hx.1, hx.2, hu.1, hu.2, abs_lt.mp hu', min_le_left δ ( ε / 2 ), min_le_right δ ( ε / 2 ) ] ) ( by linarith [ hx.1, hx.2, hu.1, hu.2, abs_lt.mp hu', min_le_left δ ( ε / 2 ), min_le_right δ ( ε / 2 ) ] ) ( by linarith [ hx.1, hx.2, hu.1, hu.2, abs_lt.mp hu', min_le_left δ ( ε / 2 ), min_le_right δ ( ε / 2 ) ] ) <| by simpa using lt_of_lt_of_le hu' <| min_le_left _ _ ⟩ ;
  -- Split the integral into two parts: $|u| < \delta$ and $|u| \ge \delta$.
  have h_split_integral : ∀ η > 0, ∃ δ > 0, ∀ x ∈ Set.Icc ε (1 - ε), ∀ n : ℕ, abs (∫ u in (x - 1)..x, (f (x - u) - f x) * K_n n u) ≤ η / 2 + 2 * (SupSet.sSup (Set.image (fun y => abs (f y)) (Set.Icc 0 1))) * ∫ u in (Set.Icc (-1) 1) \ (Set.Ioo (-δ) δ), abs (K_n n u) := by
    intro η hη_pos
    obtain ⟨δ, hδ_pos, hδ⟩ := h_unif_cont (η / 2) (half_pos hη_pos)
    use δ, hδ_pos
    intro x hx n
    have h_split : abs (∫ u in (x - 1)..x, (f (x - u) - f x) * K_n n u) ≤ (∫ u in Set.Icc (x - 1) x ∩ Set.Ioo (-δ) δ, abs ((f (x - u) - f x) * K_n n u)) + (∫ u in Set.Icc (x - 1) x \ Set.Ioo (-δ) δ, abs ((f (x - u) - f x) * K_n n u)) := by
      rw [ intervalIntegral.integral_of_le ( by linarith [ hx.1, hx.2 ] ), ← MeasureTheory.setIntegral_union ];
      · rw [ show ( Set.Icc ( x - 1 ) x ∩ Set.Ioo ( -δ ) δ ∪ Set.Icc ( x - 1 ) x \ Set.Ioo ( -δ ) δ ) = Set.Icc ( x - 1 ) x by ext y; by_cases hy : y ∈ Set.Ioo ( -δ ) δ <;> aesop ] ; rw [ MeasureTheory.integral_Icc_eq_integral_Ioc ] ; exact MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) ;
      · exact Set.disjoint_left.mpr fun y hy₁ hy₂ => hy₂.2 hy₁.2;
      · exact measurableSet_Icc.diff measurableSet_Ioo;
      · refine' ContinuousOn.integrableOn_Icc _ |> fun h => h.mono_set ( Set.inter_subset_left );
        refine' ContinuousOn.abs ( ContinuousOn.mul _ _ );
        · exact ContinuousOn.sub ( hf.comp ( continuousOn_const.sub continuousOn_id ) fun u hu => by constructor <;> norm_num <;> linarith [ hu.1, hu.2, hx.1, hx.2 ] ) continuousOn_const;
        · exact Continuous.continuousOn ( by unfold K_n; continuity );
      · -- The function $|(f (x - u) - f x) * K_n n u|$ is continuous on the compact interval $[x-1, x]$, hence it is integrable.
        have h_cont : ContinuousOn (fun u => abs ((f (x - u) - f x) * K_n n u)) (Set.Icc (x - 1) x) := by
          refine' ContinuousOn.abs ( ContinuousOn.mul _ _ );
          · exact ContinuousOn.sub ( hf.comp ( continuousOn_const.sub continuousOn_id ) fun u hu => by constructor <;> norm_num <;> linarith [ hu.1, hu.2, hx.1, hx.2 ] ) continuousOn_const;
          · exact Continuous.continuousOn ( by exact Continuous.mul ( continuous_const ) ( by exact Continuous.pow ( by continuity ) _ ) );
        exact h_cont.integrableOn_Icc.mono_set <| Set.diff_subset;
    -- Bound the first integral using the uniform continuity of $f$.
    have h_first_integral : ∫ u in Set.Icc (x - 1) x ∩ Set.Ioo (-δ) δ, abs ((f (x - u) - f x) * K_n n u) ≤ (η / 2) * ∫ u in Set.Icc (x - 1) x ∩ Set.Ioo (-δ) δ, abs (K_n n u) := by
      rw [ ← MeasureTheory.integral_const_mul ];
      refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
      · exact Filter.Eventually.of_forall fun u => abs_nonneg _;
      · exact ContinuousOn.integrableOn_Icc ( by exact ContinuousOn.mul continuousOn_const <| ContinuousOn.abs <| by exact ContinuousOn.mul continuousOn_const <| by exact ContinuousOn.pow ( continuousOn_const.sub <| continuousOn_pow 2 ) _ ) |> fun h => h.mono_set <| Set.inter_subset_left;
      · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_Icc.inter measurableSet_Ioo ] with u hu using by rw [ abs_mul ] ; exact mul_le_mul_of_nonneg_right ( le_of_lt <| hδ x hx u ⟨ by linarith [ hu.1.1, hu.1.2, hx.1, hx.2 ], by linarith [ hu.1.1, hu.1.2, hx.1, hx.2 ] ⟩ <| abs_lt.mpr ⟨ by linarith [ hu.2.1, hu.2.2 ], by linarith [ hu.2.1, hu.2.2 ] ⟩ ) <| abs_nonneg _;
    -- Bound the second integral using the fact that $|f(x-u) - f(x)| \leq 2 \sup_{y \in [0, 1]} |f(y)|$.
    have h_second_integral : ∫ u in Set.Icc (x - 1) x \ Set.Ioo (-δ) δ, abs ((f (x - u) - f x) * K_n n u) ≤ 2 * (SupSet.sSup (Set.image (fun y => abs (f y)) (Set.Icc 0 1))) * ∫ u in Set.Icc (x - 1) x \ Set.Ioo (-δ) δ, abs (K_n n u) := by
      rw [ ← MeasureTheory.integral_const_mul ];
      refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
      · exact Filter.Eventually.of_forall fun u => abs_nonneg _;
      · refine' ContinuousOn.integrableOn_Icc _ |> fun h => h.mono_set <| Set.diff_subset;
        refine' ContinuousOn.mul continuousOn_const _;
        exact ContinuousOn.abs ( ContinuousOn.mul continuousOn_const <| ContinuousOn.pow ( continuousOn_const.sub <| continuousOn_pow 2 ) _ );
      · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_Icc.diff measurableSet_Ioo ] with u hu;
        rw [ abs_mul ];
        gcongr;
        norm_num +zetaDelta at *;
        exact le_trans ( abs_sub _ _ ) ( by linarith [ show |f ( x - u )| ≤ SupSet.sSup ( ( fun y => |f y| ) '' Set.Icc 0 1 ) from le_csSup ( by exact ( isCompact_Icc.image_of_continuousOn ( hf.abs ) ) |> IsCompact.bddAbove ) ( Set.mem_image_of_mem _ <| by constructor <;> linarith ), show |f x| ≤ SupSet.sSup ( ( fun y => |f y| ) '' Set.Icc 0 1 ) from le_csSup ( by exact ( isCompact_Icc.image_of_continuousOn ( hf.abs ) ) |> IsCompact.bddAbove ) ( Set.mem_image_of_mem _ <| by constructor <;> linarith ) ] );
    -- Since $|K_n(u)|$ is non-negative and the integral of $|K_n(u)|$ over $[-1, 1]$ is 1, we have:
    have h_integral_bound : ∫ u in Set.Icc (x - 1) x ∩ Set.Ioo (-δ) δ, abs (K_n n u) ≤ 1 ∧ ∫ u in Set.Icc (x - 1) x \ Set.Ioo (-δ) δ, abs (K_n n u) ≤ ∫ u in Set.Icc (-1) 1 \ Set.Ioo (-δ) δ, abs (K_n n u) := by
      have h_integral_bound : ∫ u in Set.Icc (-1) 1, abs (K_n n u) = 1 := by
        have h_integral_bound : ∫ u in Set.Icc (-1) 1, K_n n u = 1 := by
          convert C_n_mul_J_n_eq_one n using 1;
          rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ] <;> norm_num [ K_n, J_n ];
        rw [ MeasureTheory.setIntegral_congr_fun measurableSet_Icc fun u hu => abs_of_nonneg <| show 0 ≤ K_n n u from mul_nonneg ( show 0 ≤ C_n n from mul_nonneg ( by norm_num ) <| Finset.prod_nonneg fun _ _ => div_nonneg ( by positivity ) <| by positivity ) <| pow_nonneg ( by nlinarith [ hu.1, hu.2 ] ) _, h_integral_bound ];
      constructor;
      · refine' h_integral_bound ▸ MeasureTheory.setIntegral_mono_set _ _ _;
        · exact MeasureTheory.integrable_of_integral_eq_one h_integral_bound;
        · exact Filter.Eventually.of_forall fun u => abs_nonneg _;
        · exact MeasureTheory.ae_of_all _ fun u hu => ⟨ by linarith [ hu.1.1, hu.1.2, hu.2.1, hu.2.2, hx.1, hx.2 ], by linarith [ hu.1.1, hu.1.2, hu.2.1, hu.2.2, hx.1, hx.2 ] ⟩;
      · refine' MeasureTheory.setIntegral_mono_set _ _ _;
        · exact MeasureTheory.IntegrableOn.mono_set ( by exact MeasureTheory.integrable_of_integral_eq_one h_integral_bound ) ( Set.diff_subset );
        · exact Filter.Eventually.of_forall fun u => abs_nonneg _;
        · exact MeasureTheory.ae_of_all _ fun u hu => ⟨ ⟨ by linarith [ hu.1.1, hu.1.2, hx.1, hx.2 ], by linarith [ hu.1.1, hu.1.2, hx.1, hx.2 ] ⟩, hu.2 ⟩;
    nlinarith [ show 0 ≤ SupSet.sSup ( ( fun y => |f y| ) '' Set.Icc 0 1 ) by apply_rules [ Real.sSup_nonneg ] ; rintro _ ⟨ y, hy, rfl ⟩ ; exact abs_nonneg _, show 0 ≤ ∫ u in Set.Icc ( -1 ) 1 \ Set.Ioo ( -δ ) δ, |K_n n u| by exact MeasureTheory.integral_nonneg fun _ => abs_nonneg _ ];
  -- By `kernel_mass_concentration`, the integral of $K_n$ outside $(-\delta, \delta)$ tends to 0.
  have h_kernel_mass_concentration : ∀ δ > 0, Filter.Tendsto (fun n => ∫ u in (Set.Icc (-1) 1) \ (Set.Ioo (-δ) δ), abs (K_n n u)) Filter.atTop (nhds 0) := by
    intro δ hδ_pos
    have h_kernel_mass_concentration : Filter.Tendsto (fun n => ∫ u in (Set.Icc (-1) 1) \ (Set.Ioo (-δ) δ), K_n n u) Filter.atTop (nhds 0) := by
      by_cases hδ_le_one : δ ≤ 1;
      · by_cases hδ_eq_one : δ = 1;
        · norm_num [ hδ_eq_one ];
          norm_num [ MeasureTheory.Measure.restrict_apply, Set.insert_def ];
          erw [ MeasureTheory.Measure.restrict_eq_zero.mpr ] <;> norm_num;
          rw [ Set.setOf_or, MeasureTheory.measure_union ] <;> norm_num;
        · convert kernel_mass_concentration δ hδ_pos ( lt_of_le_of_ne hδ_le_one hδ_eq_one ) using 1;
      · norm_num [ Set.diff_eq_empty.mpr ( Set.Icc_subset_Ioo ( by linarith : -δ < -1 ) ( by linarith : 1 < δ ) ) ];
    convert h_kernel_mass_concentration.abs using 2 <;> norm_num [ abs_mul, abs_of_nonneg, C_n, K_n ];
    rw [ abs_of_nonneg ( MeasureTheory.setIntegral_nonneg ( by exact measurableSet_Icc.diff measurableSet_Ioo ) fun u hu => mul_nonneg ( mul_nonneg ( by norm_num ) ( by exact div_nonneg ( Finset.prod_nonneg fun _ _ => by positivity ) ( Finset.prod_nonneg fun _ _ => by positivity ) ) ) ( pow_nonneg ( by nlinarith [ hu.1.1, hu.1.2 ] ) _ ) ) ] ; norm_num [ abs_mul, abs_div, abs_of_nonneg, Finset.prod_nonneg, add_nonneg ] ;
    exact MeasureTheory.setIntegral_congr_fun ( by exact measurableSet_Icc.diff measurableSet_Ioo ) fun x hx => by rw [ abs_of_nonneg ( by nlinarith [ hx.1.1, hx.1.2 ] ) ] ;
  rw [ Metric.tendstoUniformlyOn_iff ];
  intro ε hε; rcases h_split_integral ( ε / 2 ) ( half_pos hε ) with ⟨ δ, hδ, H ⟩ ; rcases Metric.tendsto_atTop.mp ( h_kernel_mass_concentration δ hδ ) ( ε / 4 / ( 2 * SupSet.sSup ( ( fun y => |f y| ) '' Set.Icc 0 1 ) + 1 ) ) ( by exact div_pos ( by linarith ) ( by linarith [ show 0 ≤ SupSet.sSup ( ( fun y => |f y| ) '' Set.Icc 0 1 ) by apply_rules [ Real.sSup_nonneg ] ; rintro x ⟨ y, hy, rfl ⟩ ; exact abs_nonneg _ ] ) ) with ⟨ N, hN ⟩ ; norm_num at *;
  refine' ⟨ N, fun n hn x hx => lt_of_le_of_lt ( H x ( by cases Set.mem_uIcc.mp hx <;> linarith ) ( by cases Set.mem_uIcc.mp hx <;> linarith ) n ) _ ⟩;
  have := hN n hn;
  rw [ abs_lt ] at this;
  rw [ lt_div_iff₀ ] at this <;> nlinarith [ show 0 ≤ SupSet.sSup ( ( fun y => |f y| ) '' Set.Icc 0 1 ) by apply_rules [ Real.sSup_nonneg ] ; rintro x ⟨ y, hy, rfl ⟩ ; exact abs_nonneg _ ]

/-
Let $f(x)$ be a continuous function on $[0,1]$. The sequence of functions
$$ C_n \int_{0}^{1} f(t) [1-(x-t)^{2}]^{n} dt $$
converges uniformly to $f(x)$ on $[\varepsilon, 1-\varepsilon]$ for fixed $0 < \varepsilon < 1/2$.
-/
open Filter

theorem problem_133 (f : ℝ → ℝ) (hf : ContinuousOn f (Set.uIcc (0 : ℝ) 1))
    (ε : ℝ) (hε : 0 < ε) (hε_half : ε < 1/2) :
    TendstoUniformlyOn
      (fun (n : ℕ) (x : ℝ) =>
        let I_n x := ∫ t in (0:ℝ)..1, f t * ((1 : ℝ) - (x - t)^2)^n
        let C_n_val := C_n n
        C_n_val * I_n x)
      (fun x : ℝ => f x)
      atTop
      (Set.uIcc ε (1 - ε)) := by
        -- We rewrite the integral using the substitution $u = x-t$ to get $\int_{x-1}^x f(x-u) K_n(u) du$.
        suffices h_rewrite : TendstoUniformlyOn (fun n x => ∫ u in (x - 1)..x, f (x - u) * K_n n u) (fun x => f x) Filter.atTop (Set.uIcc ε (1 - ε)) by
          convert h_rewrite using 3;
          norm_num [ K_n ];
          rw [ ← intervalIntegral.integral_const_mul ] ; convert intervalIntegral.integral_comp_sub_left _ _ using 3 <;> ring;
        -- We split this into $\int_{x-1}^x (f(x-u) - f(x)) K_n(u) du + f(x) \int_{x-1}^x K_n(u) du$.
        suffices h_split : TendstoUniformlyOn (fun n x => (∫ u in (x - 1)..x, (f (x - u) - f x) * K_n n u) + f x * (∫ u in (x - 1)..x, K_n n u)) (fun x => f x) Filter.atTop (Set.uIcc ε (1 - ε)) by
          refine' h_split.congr _;
          refine' Filter.Eventually.of_forall fun n x hx => _;
          simp +decide [ sub_mul ];
          rw [ intervalIntegral.integral_sub ] <;> norm_num;
          · apply_rules [ ContinuousOn.intervalIntegrable ];
            refine' ContinuousOn.mul _ _;
            · refine' hf.comp ( continuousOn_const.sub continuousOn_id ) fun u hu => _;
              cases hx ; cases hu ; constructor <;> norm_num at * <;> linarith;
            · exact Continuous.continuousOn ( by exact Continuous.mul ( continuous_const ) ( by continuity ) );
          · exact Continuous.intervalIntegrable ( by exact Continuous.mul continuous_const <| by exact Continuous.mul continuous_const <| by exact Continuous.pow ( by continuity ) _ ) _ _;
        -- The first term converges uniformly to 0 by `integral_diff_tendsto_zero_uniform`.
        have h_first_term : TendstoUniformlyOn (fun n x => ∫ u in (x - 1)..x, (f (x - u) - f x) * K_n n u) (fun _ => 0) Filter.atTop (Set.uIcc ε (1 - ε)) := by
          convert integral_diff_tendsto_zero_uniform f hf ε hε hε_half using 1;
        -- The second term converges uniformly to $f(x)$ because $\int_{x-1}^x K_n(u) du$ converges uniformly to 1 (by `integral_Kn_tendsto_one_uniform`) and $f$ is bounded on the compact set $[\epsilon, 1-\epsilon]$.
        have h_second_term : TendstoUniformlyOn (fun n x => f x * (∫ u in (x - 1)..x, K_n n u)) (fun x => f x) Filter.atTop (Set.uIcc ε (1 - ε)) := by
          have h_second_term : TendstoUniformlyOn (fun n x => ∫ u in (x - 1)..x, K_n n u) (fun _ => 1) Filter.atTop (Set.uIcc ε (1 - ε)) := by
            exact?;
          rw [ Metric.tendstoUniformlyOn_iff ] at *;
          -- Since $f$ is continuous on a compact interval, it is bounded.
          obtain ⟨M, hM⟩ : ∃ M > 0, ∀ x ∈ Set.uIcc ε (1 - ε), abs (f x) ≤ M := by
            have h_bounded : ∃ M > 0, ∀ x ∈ Set.Icc 0 1, abs (f x) ≤ M := by
              obtain ⟨ M, hM ⟩ := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) hf; use Max.max M 1; aesop;
            exact ⟨ h_bounded.choose, h_bounded.choose_spec.1, fun x hx => h_bounded.choose_spec.2 x <| by constructor <;> cases Set.mem_uIcc.mp hx <;> linarith ⟩;
          intro ε_1 hε_1; filter_upwards [ h_second_term ( ε_1 / ( M + 1 ) ) ( div_pos hε_1 ( add_pos hM.1 zero_lt_one ) ) ] with n hn; intro x hx; rw [ dist_eq_norm ] ; rw [ Real.norm_eq_abs ] ; rw [ abs_lt ] ; constructor <;> nlinarith [ abs_le.mp ( hM.2 x hx ), abs_lt.mp ( hn x hx ), mul_div_cancel₀ ε_1 ( by linarith : ( M + 1 ) ≠ 0 ) ] ;
        rw [ Metric.tendstoUniformlyOn_iff ] at *;
        intro ε_1 hε_1; filter_upwards [ h_first_term ( ε_1 / 2 ) ( half_pos hε_1 ), h_second_term ( ε_1 / 2 ) ( half_pos hε_1 ) ] with n hn hn' using fun x hx => abs_lt.mpr ⟨ by linarith [ abs_lt.mp ( hn x hx ), abs_lt.mp ( hn' x hx ) ], by linarith [ abs_lt.mp ( hn x hx ), abs_lt.mp ( hn' x hx ) ] ⟩ ;

/-
An algebraic identity relating the convolution integral to the split form used in the proof.
-/
open Filter

lemma problem_133_eq (f : ℝ → ℝ) (hf : ContinuousOn f (Set.uIcc (0 : ℝ) 1))
    (ε : ℝ) (hε : 0 < ε) (hε_half : ε < 1/2) (n : ℕ) (x : ℝ) (hx : x ∈ Set.uIcc ε (1 - ε)) :
    C_n n * (∫ t in (0:ℝ)..1, f t * ((1 : ℝ) - (x - t)^2)^n) =
    (∫ u in (x - 1)..x, (f (x - u) - f x) * K_n n u) + f x * (∫ u in (x - 1)..x, K_n n u) := by
  -- Using the substitution $u = x - t$, we can rewrite the integral.
  have h_subst : ∫ t in (0:ℝ)..1, f t * (1 - (x - t)^2)^n = ∫ u in (x - 1)..x, f (x - u) * (1 - u^2)^n := by
    convert intervalIntegral.integral_comp_sub_left _ x using 3 <;> ring;
  norm_num [ sub_mul, mul_assoc, ← intervalIntegral.integral_const_mul ];
  rw [ intervalIntegral.integral_sub ] <;> norm_num [ h_subst ];
  · norm_num [ mul_assoc, mul_comm, mul_left_comm, ← intervalIntegral.integral_const_mul, K_n ];
  · apply_rules [ ContinuousOn.intervalIntegrable ];
    refine' ContinuousOn.mul _ _;
    · refine' hf.comp ( continuousOn_const.sub continuousOn_id ) fun u hu => _;
      norm_num [ Set.uIcc ] at * ; constructor <;> linarith;
    · exact Continuous.continuousOn ( by unfold K_n; continuity );
  · exact Continuous.intervalIntegrable ( by exact Continuous.mul continuous_const <| by exact Continuous.mul continuous_const <| by exact Continuous.pow ( by continuity ) _ ) _ _

/-
Let $f(x)$ be a continuous function on $[0,1]$. The sequence of functions
$$ C_n \int_{0}^{1} f(t) [1-(x-t)^{2}]^{n} dt $$
converges uniformly to $f(x)$ on $[\varepsilon, 1-\varepsilon]$ for fixed $0 < \varepsilon < 1/2$.
-/
open Filter

theorem problem_133_solution (f : ℝ → ℝ) (hf : ContinuousOn f (Set.uIcc (0 : ℝ) 1))
    (ε : ℝ) (hε : 0 < ε) (hε_half : ε < 1/2) :
    TendstoUniformlyOn
      (fun (n : ℕ) (x : ℝ) =>
        let I_n x := ∫ t in (0:ℝ)..1, f t * ((1 : ℝ) - (x - t)^2)^n
        let C_n_val := C_n n
        C_n_val * I_n x)
      (fun x : ℝ => f x)
      atTop
      (Set.uIcc ε (1 - ε)) := by
        convert problem_133 f hf ε hε hε_half using 1

/-
Let $f(x)$ be a continuous function on $[0,1]$. The sequence of functions
$$ C_n \int_{0}^{1} f(t) [1-(x-t)^{2}]^{n} dt $$
converges uniformly to $f(x)$ on $[\varepsilon, 1-\varepsilon]$ for fixed $0 < \varepsilon < 1/2$.
-/
open Filter

theorem problem_133_final (f : ℝ → ℝ) (hf : ContinuousOn f (Set.uIcc (0 : ℝ) 1))
    (ε : ℝ) (hε : 0 < ε) (hε_half : ε < 1/2) :
    TendstoUniformlyOn
      (fun (n : ℕ) (x : ℝ) =>
        let I_n x := ∫ t in (0:ℝ)..1, f t * ((1 : ℝ) - (x - t)^2)^n
        let C_n_val := C_n n
        C_n_val * I_n x)
      (fun x : ℝ => f x)
      atTop
      (Set.uIcc ε (1 - ε)) := by
        convert problem_133_solution f hf ε hε hε_half using 1

/-
Let $f(x)$ be a continuous function on $[0,1]$. The sequence of functions
$$ C_n \int_{0}^{1} f(t) [1-(x-t)^{2}]^{n} dt $$
converges uniformly to $f(x)$ on $[\varepsilon, 1-\varepsilon]$ for fixed $0 < \varepsilon < 1/2$.
-/
open Filter

theorem problem_133_corrected (f : ℝ → ℝ) (hf : ContinuousOn f (Set.uIcc (0 : ℝ) 1))
    (ε : ℝ) (hε : 0 < ε) (hε_half : ε < 1/2) :
    TendstoUniformlyOn
      (fun (n : ℕ) (x : ℝ) =>
        let I_n x := ∫ t in (0:ℝ)..1, f t * ((1 : ℝ) - (x - t)^2)^n
        C_n n * I_n x)
      (fun x : ℝ => f x)
      atTop
      (Set.uIcc ε (1 - ε)) := by
        exact?

/-
Let $f(x)$ be a continuous function on $[0,1]$. The sequence of functions
$$ C_n \int_{0}^{1} f(t) [1-(x-t)^{2}]^{n} dt $$
converges uniformly to $f(x)$ on $[\varepsilon, 1-\varepsilon]$ for fixed $0 < \varepsilon < 1/2$.
-/
open Filter

theorem problem_133_done (f : ℝ → ℝ) (hf : ContinuousOn f (Set.uIcc (0 : ℝ) 1))
    (ε : ℝ) (hε : 0 < ε) (hε_half : ε < 1/2) :
    TendstoUniformlyOn
      (fun (n : ℕ) (x : ℝ) =>
        let I_n x := ∫ t in (0:ℝ)..1, f t * ((1 : ℝ) - (x - t)^2)^n
        C_n n * I_n x)
      (fun x : ℝ => f x)
      atTop
      (Set.uIcc ε (1 - ε)) := by
        exact?