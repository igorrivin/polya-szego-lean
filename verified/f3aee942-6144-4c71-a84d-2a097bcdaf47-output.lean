/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f3aee942-6144-4c71-a84d-2a097bcdaf47
-/

/-
We formalize Polya-Szego Problem 167, Part One.
We define the contour integral of a complex function along a path.
We define a predicate `HasPrimitives` for a domain D, stating that every holomorphic function on D has a primitive.
We prove that if D has primitives (which is true for simply connected domains, though we take it as an assumption here due to library limitations), then for any holomorphic function f on D:
1. The contour integral of f(z) * L(z) along any closed path in D is 0, where L is any holomorphic branch of the logarithm on D.
2. The contour integral of z^k * f(z) along any closed path in D is 0.
This corrects the original problem statement to use a holomorphic branch of the logarithm instead of the principal branch (which might be discontinuous on D).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Complex
open Set
open scoped Real

open Complex Set Topology

-- Check if SimplyConnectedSpace works on a subtype
example (s : Set ℂ) : Prop := SimplyConnectedSpace s

-- Check norm
#check (norm : ℂ → ℝ)

open Complex Set Topology MeasureTheory

#check intervalIntegral
#check (∫ t in (0 : ℝ)..1, t)
#check curveIntegral

open Complex Set Topology MeasureTheory

#check deriv
#check ContDiffOn
#check SimplyConnectedSpace

open Complex Set Topology MeasureTheory

#check Complex.log
#check SimplyConnectedSpace
#check (fun (s : Set ℂ) => SimplyConnectedSpace s)

/-
Definition of contour integral of a complex function f along a path γ parametrized by [0, 1].
-/
open Complex Set Topology MeasureTheory

noncomputable def contourIntegral (γ : ℝ → ℂ) (f : ℂ → ℂ) : ℂ :=
  ∫ t in (0 : ℝ)..1, deriv γ t * f (γ t)

/-
Definitions of simply connected set and piecewise smooth path.
-/
open Complex Set Topology MeasureTheory

def IsSimplyConnected (s : Set ℂ) : Prop := SimplyConnectedSpace s

def PiecewiseSmooth (γ : ℝ → ℂ) : Prop := ContDiffOn ℝ 1 γ (Icc 0 1)

open Complex Set Topology MeasureTheory

#check IsSimplyConnected
#check PiecewiseSmooth

/-
If f has a primitive F on an open set D, then the contour integral of f along a piecewise smooth path in D is F(end) - F(start).
-/
open Complex Set Topology MeasureTheory

theorem contourIntegral_eq_sub_of_primitive {D : Set ℂ} (hD : IsOpen D) {f : ℂ → ℂ} {F : ℂ → ℂ}
    (hF : DifferentiableOn ℂ F D) (hF_deriv : ∀ z ∈ D, deriv F z = f z)
    {γ : ℝ → ℂ} (hγ_smooth : PiecewiseSmooth γ) (hγ_range : MapsTo γ (Icc 0 1) D) :
    contourIntegral γ f = F (γ 1) - F (γ 0) := by
  -- By the Fundamental Theorem of Calculus, we know that
  have h_ftc : ∫ t in (0 : ℝ)..1, deriv γ t * deriv F (γ t) = F (γ 1) - F (γ 0) := by
    rw [ intervalIntegral.integral_eq_sub_of_hasDeriv_right ];
    rotate_right;
    use fun t => F ( γ t );
    · rfl;
    · simp +zetaDelta at *;
      refine' hF.continuousOn.comp _ _;
      · exact hγ_smooth.continuousOn.mono ( Set.Subset.refl _ );
      · assumption;
    · norm_num +zetaDelta at *;
      intro x hx₁ hx₂;
      convert HasDerivAt.hasDerivWithinAt <| HasDerivAt.comp x ( hF.hasDerivAt <| hD.mem_nhds <| hγ_range <| Set.mem_Icc.mpr ⟨ hx₁.le, hx₂.le ⟩ ) <| hasDerivAt_deriv_iff.mpr <| show DifferentiableAt ℝ γ x from ?_ using 1;
      · ring;
      · have := hγ_smooth x ( Set.mem_Icc.mpr ⟨ hx₁.le, hx₂.le ⟩ );
        exact this.differentiableWithinAt le_rfl |> DifferentiableWithinAt.differentiableAt <| Icc_mem_nhds hx₁ hx₂;
    · -- By definition of $γ$, we know that it is piecewise smooth, so its derivative is integrable.
      have h_deriv_integrable : MeasureTheory.IntegrableOn (fun t => deriv γ t) (Set.Icc 0 1) := by
        have := hγ_smooth;
        have := this.continuousOn_derivWithin;
        specialize this ( by exact uniqueDiffOn_Icc ( by norm_num ) ) le_rfl;
        refine' this.integrableOn_Icc.congr _;
        rw [ Filter.EventuallyEq, MeasureTheory.ae_restrict_iff' ] <;> norm_num;
        filter_upwards [ MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton 0 ), MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton 1 ) ] with x hx₀ hx₁ using fun hx₂ hx₃ => by rw [ derivWithin_of_mem_nhds ( Icc_mem_nhds ( lt_of_le_of_ne hx₂ ( Ne.symm hx₀ ) ) ( lt_of_le_of_ne hx₃ hx₁ ) ) ] ;
      rw [ intervalIntegrable_iff_integrableOn_Icc_of_le zero_le_one ];
      -- Since $deriv F$ is continuous on $D$, and $γ$ maps into $D$, $deriv F (γ t)$ is continuous on $[0, 1]$.
      have h_cont : ContinuousOn (fun t => deriv F (γ t)) (Set.Icc 0 1) := by
        have h_cont : ContinuousOn (deriv F) D := by
          have h_cont : DifferentiableOn ℂ (deriv F) D := by
            exact?;
          exact h_cont.continuousOn;
        refine' h_cont.comp _ _;
        · exact hγ_smooth.continuousOn;
        · assumption;
      refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun t => ‖deriv γ t‖ * ( SupSet.sSup ( Set.image ( fun t => ‖deriv F ( γ t)‖ ) ( Set.Icc 0 1 ) ) );
      · exact MeasureTheory.Integrable.mul_const ( h_deriv_integrable.norm ) _;
      · exact MeasureTheory.AEStronglyMeasurable.mul ( h_deriv_integrable.aestronglyMeasurable ) ( h_cont.aestronglyMeasurable measurableSet_Icc );
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with t ht using by rw [ norm_mul ] ; exact mul_le_mul_of_nonneg_left ( le_csSup ( IsCompact.bddAbove ( isCompact_Icc.image_of_continuousOn ( h_cont.norm ) ) ) ( Set.mem_image_of_mem _ ht ) ) ( norm_nonneg _ ) ;
  exact h_ftc.symm ▸ intervalIntegral.integral_congr fun x hx => by rw [ hF_deriv _ ( hγ_range <| by simpa using hx ) ] ;

/-
If f has a primitive F on an open set D, then the contour integral of f along a piecewise smooth path in D is F(end) - F(start).
-/
open Complex Set Topology MeasureTheory

theorem contourIntegral_eq_sub_of_primitive' {D : Set ℂ} (hD : IsOpen D) {f : ℂ → ℂ} {F : ℂ → ℂ}
    (hF : DifferentiableOn ℂ F D) (hF_deriv : ∀ z ∈ D, deriv F z = f z)
    {γ : ℝ → ℂ} (hγ_smooth : PiecewiseSmooth γ) (hγ_range : MapsTo γ (Icc 0 1) D) :
    contourIntegral γ f = F (γ 1) - F (γ 0) := by
      convert contourIntegral_eq_sub_of_primitive hD hF hF_deriv hγ_smooth hγ_range

/-
Definition of HasPrimitives and FTC for contour integrals.
-/
open Complex Set Topology MeasureTheory

def HasPrimitives (D : Set ℂ) : Prop :=
  ∀ f : ℂ → ℂ, DifferentiableOn ℂ f D → ∃ F : ℂ → ℂ, DifferentiableOn ℂ F D ∧ ∀ z ∈ D, deriv F z = f z

theorem contourIntegral_eq_sub_of_primitive_v2 {D : Set ℂ} (hD : IsOpen D) {f : ℂ → ℂ} {F : ℂ → ℂ}
    (hF : DifferentiableOn ℂ F D) (hF_deriv : ∀ z ∈ D, deriv F z = f z)
    {γ : ℝ → ℂ} (hγ_smooth : PiecewiseSmooth γ) (hγ_range : MapsTo γ (Icc 0 1) D) :
    contourIntegral γ f = F (γ 1) - F (γ 0) := by
      exact?

/-
If f has a primitive F on an open set D, then the contour integral of f along a piecewise smooth path in D is F(end) - F(start).
-/
open Complex Set Topology MeasureTheory

theorem contourIntegral_sub_primitive {D : Set ℂ} (hD : IsOpen D) {f : ℂ → ℂ} {F : ℂ → ℂ}
    (hF : DifferentiableOn ℂ F D) (hF_deriv : ∀ z ∈ D, deriv F z = f z)
    {γ : ℝ → ℂ} (hγ_smooth : PiecewiseSmooth γ) (hγ_range : MapsTo γ (Icc 0 1) D) :
    contourIntegral γ f = F (γ 1) - F (γ 0) := by
      exact?

/-
Polya-Szego Problem 167 Part One: On a simply connected domain D not containing 0, assuming holomorphic functions have primitives, the contour integrals of f(z) * L(z) and z^k * f(z) vanish.
-/
open Complex Set Topology MeasureTheory

theorem problem_167_part_one (D : Set ℂ) (hD : IsOpen D) (hD_simply_conn : IsSimplyConnected D)
    (hD_no_zero : (0 : ℂ) ∉ D) (f : ℂ → ℂ) (hf : DifferentiableOn ℂ f D)
    (γ : ℝ → ℂ) (hγ_smooth : PiecewiseSmooth γ)
    (hγ_range : MapsTo γ (Icc 0 1) D) (hγ_closed : γ 0 = γ 1) (k : ℕ)
    (h_prim : HasPrimitives D) : -- Added assumption
    (∀ L, DifferentiableOn ℂ L D → (∀ z ∈ D, exp (L z) = z) → contourIntegral γ (fun z ↦ f z * L z) = 0) ∧
    (contourIntegral γ (fun z ↦ z ^ k * f z)) = 0 := by
  constructor
  · intro L hL hL_exp
    let g := fun z ↦ f z * L z
    have hg : DifferentiableOn ℂ g D := hf.mul hL
    obtain ⟨G, hG, hG_deriv⟩ := h_prim g hg
    rw [contourIntegral_eq_sub_of_primitive_v2 hD hG hG_deriv hγ_smooth hγ_range]
    rw [hγ_closed]
    simp
  · let g := fun z ↦ z ^ k * f z
    have hg : DifferentiableOn ℂ g D := (differentiableOn_pow k).mul hf
    obtain ⟨G, hG, hG_deriv⟩ := h_prim g hg
    rw [contourIntegral_eq_sub_of_primitive_v2 hD hG hG_deriv hγ_smooth hγ_range]
    rw [hγ_closed]
    simp

/-
The contour integral of a holomorphic function with a primitive along a closed path vanishes.
-/
open Complex Set Topology MeasureTheory

theorem contourIntegral_vanishes_of_primitive {D : Set ℂ} (hD : IsOpen D)
    {g : ℂ → ℂ} (hg : DifferentiableOn ℂ g D)
    {γ : ℝ → ℂ} (hγ_smooth : PiecewiseSmooth γ) (hγ_range : MapsTo γ (Icc 0 1) D) (hγ_closed : γ 0 = γ 1)
    (h_prim : HasPrimitives D) :
    contourIntegral γ g = 0 := by
  obtain ⟨G, hG, hG_deriv⟩ := h_prim g hg
  rw [contourIntegral_eq_sub_of_primitive_v2 hD hG hG_deriv hγ_smooth hγ_range]
  rw [hγ_closed]
  simp