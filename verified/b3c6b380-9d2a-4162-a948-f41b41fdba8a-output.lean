/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b3c6b380-9d2a-4162-a948-f41b41fdba8a
-/

/-
We analyzed the user's proposed formalization of Polya-Szego Problem 109.
The user's statement claimed that if $Re(f'(z)) > 0$ on $[a,b]$, then the argument of $f$ is strictly increasing.
We disproved this claim with a counterexample: $f(z) = z+1$ on $[0,1]$. Here $Re(f'(z)) = 1 > 0$, but the argument is $0$ (constant), not strictly increasing. Another counterexample $f(z) = z+i$ shows the argument can be decreasing.

We provided a corrected version of the theorem:
If $f$ is holomorphic on $[a,b]$ and $Re(f'(z)) > 0$ on $[a,b]$, then the *real part* of $f$ is strictly increasing on $[a,b]$.
We formally proved this corrected statement in `problem_109_corrected`.
We also formally disproved the original statement in `problem_109_false`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Checking if segment is available.
-/
#check segment

/-
Checking types of Complex.arg and Real.Angle.toReal
-/
#check Complex.arg
#check Real.Angle.toReal

/-
Corrected Polya-Szego Problem 109: If f is holomorphic on [a,b] and Re(f'(z)) > 0 for all z in [a,b], then the real part of f is strictly increasing on [a,b].
-/
theorem problem_109_corrected {a b : ℝ} (hab : a < b) {f : ℂ → ℂ}
    (hf : ∀ z ∈ segment ℝ (a : ℂ) (b : ℂ), DifferentiableAt ℂ f z)
    (hpos : ∀ z ∈ segment ℝ (a : ℂ) (b : ℂ), 0 < (deriv f z).re) :
    ∀ (x y : ℝ) (hx : a ≤ x) (hy : y ≤ b) (hlt : x < y),
    (f y).re > (f x).re := by
      -- Let's choose any two points $x$ and $y$ in $[a, b]$ with $a \leq x < y \leq b$.
      intros x y hx hy hxy
      have hg : ∀ t ∈ Set.Icc (x : ℝ) y, DifferentiableAt ℝ (fun t : ℝ => Complex.re (f t)) t := by
        intro t ht;
        have := hf t ?_;
        · exact Complex.reCLM.differentiableAt.comp _ ( this.restrictScalars ℝ |> DifferentiableAt.comp _ <| Complex.ofRealCLM.differentiableAt );
        · rw [ segment_eq_image ];
          norm_num [ Complex.ext_iff ];
          exact ⟨ ( t - a ) / ( b - a ), ⟨ by nlinarith [ ht.1, ht.2, mul_div_cancel₀ ( t - a ) ( sub_ne_zero_of_ne hab.ne' ) ], by nlinarith [ ht.1, ht.2, mul_div_cancel₀ ( t - a ) ( sub_ne_zero_of_ne hab.ne' ) ] ⟩, by linarith [ mul_div_cancel₀ ( t - a ) ( sub_ne_zero_of_ne hab.ne' ) ] ⟩;
      -- By the Mean Value Theorem, there exists some $c \in (x, y)$ such that $g'(c) = \frac{g(y) - g(x)}{y - x}$.
      obtain ⟨c, hc⟩ : ∃ c ∈ Set.Ioo x y, deriv (fun t : ℝ => Complex.re (f t)) c = (Complex.re (f y) - Complex.re (f x)) / (y - x) := by
        apply_rules [ exists_deriv_eq_slope ];
        · exact fun t ht => DifferentiableAt.continuousAt ( hg t ht ) |> ContinuousAt.continuousWithinAt;
        · exact fun t ht => DifferentiableAt.differentiableWithinAt ( hg t <| Set.Ioo_subset_Icc_self ht );
      -- Since $f$ is differentiable at $c$, we have $deriv (fun t : ℝ => Complex.re (f t)) c = Complex.re (deriv f c)$.
      have h_deriv : deriv (fun t : ℝ => Complex.re (f t)) c = Complex.re (deriv f c) := by
        have h_deriv : HasDerivAt (fun t : ℝ => f t) (deriv f c) c := by
          have := hf c ?_;
          · convert this.hasDerivAt.comp_ofReal using 1;
          · rw [ segment_eq_image ];
            norm_num [ Complex.ext_iff ];
            exact ⟨ ( c - a ) / ( b - a ), ⟨ by nlinarith [ hc.1.1, hc.1.2, mul_div_cancel₀ ( c - a ) ( sub_ne_zero_of_ne hab.ne' ) ], by nlinarith [ hc.1.1, hc.1.2, mul_div_cancel₀ ( c - a ) ( sub_ne_zero_of_ne hab.ne' ) ] ⟩, by linarith [ mul_div_cancel₀ ( c - a ) ( sub_ne_zero_of_ne hab.ne' ) ] ⟩;
        have h_deriv_real : HasDerivAt (fun t : ℝ => Complex.re (f t)) (Complex.re (deriv f c)) c := by
          rw [ hasDerivAt_iff_tendsto ] at *;
          exact squeeze_zero ( fun _ => by positivity ) ( fun _ => mul_le_mul_of_nonneg_left ( by simpa using Complex.abs_re_le_norm ( f ( ↑‹ℝ› : ℂ ) - f ( ↑c : ℂ ) - ( ↑‹ℝ› - c ) • deriv f ( ↑c : ℂ ) ) ) ( by positivity ) ) h_deriv;
        exact h_deriv_real.deriv;
      have := hpos c ?_;
      · rw [ eq_div_iff ] at hc <;> nlinarith;
      · rw [ segment_eq_image ];
        norm_num [ Complex.ext_iff ];
        exact ⟨ ( c - a ) / ( b - a ), ⟨ by nlinarith [ hc.1.1, hc.1.2, mul_div_cancel₀ ( c - a ) ( sub_ne_zero_of_ne hab.ne' ) ], by nlinarith [ hc.1.1, hc.1.2, mul_div_cancel₀ ( c - a ) ( sub_ne_zero_of_ne hab.ne' ) ] ⟩, by linarith [ mul_div_cancel₀ ( c - a ) ( sub_ne_zero_of_ne hab.ne' ) ] ⟩

/-
Disproof of the original Polya-Szego Problem 109 formulation.
-/
theorem problem_109_false :
    ¬ (∀ {a b : ℝ} (hab : a < b) {f : ℂ → ℂ}
    (hf : DifferentiableOn ℂ f (segment ℝ (a : ℂ) (b : ℂ)))
    (hpos : ∀ z, z ∈ segment ℝ (a : ℂ) (b : ℂ) → 0 < (deriv f z).re),
    ∀ (x y : ℝ) (hx : a ≤ x) (hy : y ≤ b) (hlt : x < y),
    Complex.arg (f y) > Complex.arg (f x)) := by
      push_neg;
      use 0, 1;
      refine' ⟨ by norm_num, fun z => z + 1, _, _, 0, 1, by norm_num, by norm_num, by norm_num, _ ⟩ <;> norm_num;
      exact differentiableOn_id