/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a698f816-e85a-499b-8c3c-d75b87a558c0
-/

/-
We formalized Polya-Szego Problem 138 as `problem_138`.
The problem states that for a holomorphic non-vanishing function $f$ on a domain $D$, if $|f|$ attains a minimum in $D$, then $f$ is constant.
We formalized this using `IsLocalMinOn` for the minimum condition and `DifferentiableOn` for regularity.
The proof proceeds by applying the Maximum Modulus Principle to $g(z) = 1/f(z)$. Since $f$ is non-vanishing, $g$ is holomorphic. A local minimum of $|f|$ corresponds to a local maximum of $|g|$. Since $D$ is connected and open, the Maximum Modulus Principle implies $g$ is constant, and thus $f$ is constant.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Let f be a holomorphic function on a connected open domain D. If f is non-vanishing and |f| attains a local minimum at some point in D, then f is constant.
-/
theorem problem_138 {D : Set ℂ} (hD : IsOpen D) (hD_conn : IsConnected D)
    {f : ℂ → ℂ} (hf : DifferentiableOn ℂ f D) (h_nonzero : ∀ z ∈ D, f z ≠ 0) :
    (∃ z₀ ∈ D, IsLocalMinOn (fun z => ‖f z‖) D z₀) →
    ∃ c : ℂ, c ≠ 0 ∧ Set.EqOn f (fun _ => c) D := by
  intro ⟨ z₀, hz₀₁, hz₀₂ ⟩;
  have h_max_principle : ∀ {g : ℂ → ℂ}, DifferentiableOn ℂ g D → IsOpen D → IsConnected D → (∀ z ∈ D, g z ≠ 0) → IsLocalMaxOn (fun z => ‖g z‖) D z₀ → ∃ c : ℂ, c ≠ 0 ∧ Set.EqOn g (fun x => c) D := by
    intros g hg_diff hg_open hg_conn hg_nonzero hg_max
    have h_const : ∀ z ∈ D, g z = g z₀ := by
      have h_const : ∀ z ∈ D, g z = g z₀ := by
        have h_max_modulus : ∀ᶠ z in nhds z₀, ‖g z‖ ≤ ‖g z₀‖ := by
          rw [ IsLocalMaxOn, IsMaxFilter ] at hg_max;
          rw [ eventually_nhdsWithin_iff ] at hg_max;
          filter_upwards [ hg_max, hg_open.mem_nhds hz₀₁ ] with x hx₁ hx₂ using hx₁ hx₂
        have h_const : AnalyticOnNhd ℂ g D := by
          exact hg_diff.analyticOnNhd hg_open;
        apply_rules [ h_const.eqOn_of_preconnected_of_eventuallyEq ];
        · exact analyticOnNhd_const;
        · exact hg_conn.isPreconnected;
        · apply_rules [ Complex.eventually_eq_of_isLocalMax_norm ];
          exact Filter.eventually_of_mem ( hg_open.mem_nhds hz₀₁ ) fun z hz => h_const.differentiableOn.differentiableAt ( hg_open.mem_nhds hz );
      assumption;
    exact ⟨ g z₀, hg_nonzero z₀ hz₀₁, h_const ⟩;
  contrapose! h_max_principle;
  refine' ⟨ fun z => 1 / f z, _, _ ⟩ <;> simp_all +decide [ IsLocalMaxOn, IsLocalMinOn ];
  · exact DifferentiableOn.inv hf fun z hz => h_nonzero z hz;
  · exact ⟨ hz₀₂.mono fun x hx => inv_anti₀ ( norm_pos_iff.mpr ( h_nonzero _ hz₀₁ ) ) hx, fun x hx₁ hx₂ => h_max_principle x⁻¹ ( inv_ne_zero hx₁ ) fun y hy => by have := hx₂ hy; aesop ⟩