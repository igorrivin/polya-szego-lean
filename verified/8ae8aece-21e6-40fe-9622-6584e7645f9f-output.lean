/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8ae8aece-21e6-40fe-9622-6584e7645f9f
-/

/-
Formalization of Polya-Szego Problem 14 from Part Three, Chapter 1.
We prove that for a positive continuous function f and an integrable function φ on [a, b],
|∫ f(t) e^{iφ(t)} dt| ≤ ∫ f(t) dt.
Equality holds if and only if φ(t) is constant modulo 2π almost everywhere.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Complex.exp

#check Complex.I

#check IntervalIntegrable

#check Complex.re

#check (Norm.norm : ℂ → ℝ)

#check Complex.normSq

#check Complex.arg

#check MeasureTheory.volume
#check ContinuousOn
#check Set.Icc

#check Real.pi

/-
Polya-Szego Problem 14: If f is positive continuous and φ is integrable, then |∫ f(t) e^{iφ(t)} dt| ≤ ∫ f(t) dt.
-/
theorem problem_14 {a b : ℝ} (hab : a ≤ b) {f φ : ℝ → ℝ}
    (hf_cont : ContinuousOn f (Set.Icc a b))
    (hf_pos : ∀ t, t ∈ Set.Icc a b → 0 < f t)
    (hφ_int : IntervalIntegrable φ MeasureTheory.volume a b) :
    ‖∫ t in a..b, (f t : ℂ) * Complex.exp (Complex.I * (φ t : ℂ))‖ ≤
    ∫ t in a..b, f t := by
  convert intervalIntegral.norm_integral_le_integral_norm _ using 1;
  · norm_num [ Complex.norm_exp ];
    exact intervalIntegral.integral_congr fun x hx => by rw [ abs_of_pos ( hf_pos x <| by simpa [ hab ] using hx ) ] ;
  · exact?

/-
Polya-Szego Problem 14 with equality condition: Equality holds iff φ is constant mod 2π almost everywhere.
-/
theorem problem_14_with_equality {a b : ℝ} (hab : a ≤ b) {f φ : ℝ → ℝ}
    (hf_cont : ContinuousOn f (Set.Icc a b))
    (hf_pos : ∀ t, t ∈ Set.Icc a b → 0 < f t)
    (hφ_int : IntervalIntegrable φ MeasureTheory.volume a b) :
    let I := ∫ t in a..b, (f t : ℂ) * Complex.exp (Complex.I * (φ t : ℂ))
    ‖I‖ ≤ ∫ t in a..b, f t ∧
    (‖I‖ = ∫ t in a..b, f t ↔
      ∃ (c : ℝ), ∀ᵐ t ∂MeasureTheory.volume.restrict (Set.Icc a b),
        φ t - c ∈ Set.range (fun (k : ℤ) => (k : ℝ) * (2 * Real.pi))) := by
  simp +zetaDelta at *;
  refine' ⟨ _, ⟨ fun h => _, fun h => _ ⟩ ⟩;
  · convert ( intervalIntegral.norm_integral_le_integral_norm _ ) using 1;
    · exact intervalIntegral.integral_congr fun x hx => by simp +decide [ abs_of_pos ( hf_pos x ( by simpa [ hab ] using hx.1 ) ( by simpa [ hab ] using hx.2 ) ), Complex.norm_exp ] ;
    · linarith;
  · -- Since $|I| = \int_a^b f(t) dt$, we have $\int_a^b f(t) \cos(\varphi(t) - \theta) dt = \int_a^b f(t) dt$ for some $\theta$.
    obtain ⟨θ, hθ⟩ : ∃ θ : ℝ, ∫ t in a..b, f t * Real.cos (φ t - θ) = ∫ t in a..b, f t := by
      have h_eq : ∃ θ : ℝ, Complex.re (∫ t in a..b, (f t : ℂ) * Complex.exp (Complex.I * (φ t : ℂ)) * Complex.exp (-Complex.I * θ)) = ∫ t in a..b, f t := by
        have h_eq : ∀ z : ℂ, ∃ θ : ℝ, Complex.re (z * Complex.exp (-Complex.I * θ)) = ‖z‖ := by
          intro z; use Complex.arg z; simp +decide [ Complex.exp_re, Complex.exp_im, Complex.normSq_eq_norm_sq, Complex.norm_exp ] ;
          rw [ ← Complex.norm_mul_cos_arg, ← Complex.norm_mul_sin_arg ] ; ring;
          rw [ ← mul_add, Real.cos_sq_add_sin_sq, mul_one ];
        obtain ⟨ θ, hθ ⟩ := h_eq ( ∫ t in a..b, ( f t : ℂ ) * Complex.exp ( Complex.I * ( φ t : ℂ ) ) ) ; use θ; simp_all +decide [ mul_assoc, mul_comm, mul_left_comm, ← intervalIntegral.integral_const_mul ] ;
      obtain ⟨ θ, hθ ⟩ := h_eq; use θ; simp_all +decide [ mul_assoc, ← Complex.exp_add ] ;
      convert hθ using 1;
      rw [ intervalIntegral.integral_of_le hab, intervalIntegral.integral_of_le hab ];
      convert ( integral_re _ ) using 1;
      congr! 1;
      any_goals exact fun t => ( f t : ℂ ) * Complex.exp ( Complex.I * ( φ t : ℂ ) + - ( Complex.I * θ ) );
      all_goals try infer_instance;
      · norm_num [ Complex.exp_re, Complex.exp_im, mul_sub ];
        rfl;
      · norm_num [ Complex.exp_re, Complex.exp_im ];
      · refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun t => |f t|;
        · exact ContinuousOn.integrableOn_Icc ( hf_cont.abs ) |> fun h => h.mono_set ( Set.Ioc_subset_Icc_self );
        · refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
          · exact ContinuousOn.aestronglyMeasurable ( by exact Complex.continuous_ofReal.comp_continuousOn hf_cont |> ContinuousOn.mono <| Set.Ioc_subset_Icc_self ) measurableSet_Ioc;
          · refine' Complex.continuous_exp.comp_aestronglyMeasurable _;
            exact MeasureTheory.AEStronglyMeasurable.add ( MeasureTheory.AEStronglyMeasurable.mul ( MeasureTheory.aestronglyMeasurable_const ) ( Complex.continuous_ofReal.comp_aestronglyMeasurable ( hφ_int.1.aestronglyMeasurable ) ) ) ( MeasureTheory.aestronglyMeasurable_const );
        · norm_num [ Complex.norm_exp ];
    -- Since $\cos(\varphi(t) - \theta) = 1$ almost everywhere, we have $\varphi(t) - \theta = 2k\pi$ almost everywhere for some integer $k$.
    have h_cos_eq_one : ∀ᵐ t ∂MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Icc a b), Real.cos (φ t - θ) = 1 := by
      have h_cos_eq_one : ∫ t in Set.Icc a b, f t * (1 - Real.cos (φ t - θ)) = 0 := by
        simp_all +decide [ mul_sub, MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le hab ];
        rw [ intervalIntegral.integral_sub ] <;> norm_num [ hθ ];
        · exact hf_cont.intervalIntegrable_of_Icc hab;
        · rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le hab ] at *;
          refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun t => |f t|;
          · exact ContinuousOn.integrableOn_Icc ( hf_cont.abs ) |> fun h => h.mono_set ( Set.Ioc_subset_Icc_self );
          · refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
            · exact hf_cont.aestronglyMeasurable ( measurableSet_Icc ) |> fun h => h.mono_set ( Set.Ioc_subset_Icc_self );
            · exact Real.continuous_cos.comp_aestronglyMeasurable ( hφ_int.aestronglyMeasurable.sub ( MeasureTheory.aestronglyMeasurable_const ) );
          · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using by simpa [ abs_mul ] using mul_le_mul_of_nonneg_left ( Real.abs_cos_le_one _ ) ( abs_nonneg _ ) ;
      rw [ MeasureTheory.integral_eq_zero_iff_of_nonneg_ae ] at h_cos_eq_one;
      · filter_upwards [ h_cos_eq_one, MeasureTheory.ae_restrict_mem measurableSet_Icc ] with t ht ht' using by norm_num [ ne_of_gt ( hf_pos t ht'.1 ht'.2 ) ] at ht; linarith;
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with t ht using mul_nonneg ( le_of_lt ( hf_pos t ht.1 ht.2 ) ) ( sub_nonneg.2 ( Real.cos_le_one _ ) );
      · refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun t => 2 * |f t|;
        · exact ContinuousOn.integrableOn_Icc ( by exact ContinuousOn.mul continuousOn_const ( hf_cont.abs ) );
        · refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
          · exact hf_cont.aestronglyMeasurable measurableSet_Icc;
          · refine' MeasureTheory.AEStronglyMeasurable.sub _ _;
            · exact MeasureTheory.aestronglyMeasurable_const;
            · have h_cos_eq_one : MeasureTheory.AEStronglyMeasurable (fun t => φ t) (MeasureTheory.MeasureSpace.volume.restrict (Set.Icc a b)) := by
                have := hφ_int.aestronglyMeasurable;
                simpa only [ MeasureTheory.Measure.restrict_congr_set MeasureTheory.Ioc_ae_eq_Icc ] using this;
              exact Real.continuous_cos.comp_aestronglyMeasurable ( h_cos_eq_one.sub MeasureTheory.aestronglyMeasurable_const );
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with t ht using abs_le.mpr ⟨ by cases abs_cases ( f t ) <;> nlinarith [ Real.neg_one_le_cos ( φ t - θ ), Real.cos_le_one ( φ t - θ ) ], by cases abs_cases ( f t ) <;> nlinarith [ Real.neg_one_le_cos ( φ t - θ ), Real.cos_le_one ( φ t - θ ) ] ⟩;
    have h_cos_eq_one : ∀ᵐ t ∂MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Icc a b), ∃ k : ℤ, φ t - θ = 2 * k * Real.pi := by
      filter_upwards [ h_cos_eq_one ] with t ht using by rw [ Real.cos_eq_one_iff ] at ht; obtain ⟨ k, hk ⟩ := ht; exact ⟨ k, by linarith ⟩ ;
    exact ⟨ θ, by simpa [ mul_assoc, mul_comm, mul_left_comm ] using h_cos_eq_one.mono fun t ht => by obtain ⟨ k, hk ⟩ := ht; exact ⟨ k, by linarith ⟩ ⟩;
  · -- If $\varphi(t) - c$ is an integer multiple of $2\pi$ almost everywhere, then $e^{i\varphi(t)} = e^{ic}$ almost everywhere.
    obtain ⟨c, hc⟩ := h;
    have h_exp : ∀ᵐ t ∂MeasureTheory.MeasureSpace.volume.restrict (Set.Icc a b), Complex.exp (Complex.I * (φ t)) = Complex.exp (Complex.I * c) := by
      simp_all +decide [ Filter.eventually_inf_principal ];
      filter_upwards [ hc ] with x hx hx' hx'' ; obtain ⟨ y, hy ⟩ := hx hx' hx'' ; rw [ Complex.exp_eq_exp_iff_exists_int ] ; use y ; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ] ; nlinarith [ Real.pi_pos ];
    -- Substitute $e^{i\varphi(t)} = e^{ic}$ into the integral.
    have h_integral : ∫ t in a..b, (f t : ℂ) * Complex.exp (Complex.I * (φ t)) = (∫ t in a..b, (f t : ℂ)) * Complex.exp (Complex.I * c) := by
      rw [ intervalIntegral.integral_of_le hab, intervalIntegral.integral_of_le hab ];
      rw [ ← MeasureTheory.integral_mul_const ];
      simpa only [ MeasureTheory.Measure.restrict_congr_set MeasureTheory.Ioc_ae_eq_Icc ] using MeasureTheory.integral_congr_ae ( by filter_upwards [ h_exp ] with t ht; aesop );
    rw [ h_integral, norm_mul, Complex.norm_exp ] ; norm_num;
    rw [ intervalIntegral.integral_ofReal ];
    exact_mod_cast abs_of_nonneg ( intervalIntegral.integral_nonneg hab fun x hx => le_of_lt ( hf_pos x hx.1 hx.2 ) )