/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d9731e9f-2008-4589-93a0-292f18ba2826

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Lemma for Polya-Szego Problem 15: For a real function u on [0,1] with |u| ≤ 1, 2(∫u)² ≤ 1 + 2∫xu².
-/
theorem problem_15_real_lemma (u : ℝ → ℝ)
    (hu_int : MeasureTheory.IntegrableOn u (Set.Icc 0 1) MeasureTheory.volume)
    (hu_bound : ∀ x ∈ Set.Icc 0 1, |u x| ≤ 1) :
    2 * (∫ x in Set.Icc 0 1, u x) ^ 2 ≤ 1 + 2 * ∫ x in Set.Icc 0 1, x * u x ^ 2 := by
  -- By Cauchy-Schwarz inequality, we have $(∫u)^2 ≤ ∫u^2$.
  have hcauchy_schwarz : (∫ x in Set.Icc 0 1, u x) ^ 2 ≤ ∫ x in Set.Icc 0 1, u x ^ 2 := by
    have h_cauchy_schwarz : (∫ x in (Set.Icc 0 1), (u x - (∫ x in (Set.Icc 0 1), u x)) ^ 2) ≥ 0 := by
      exact MeasureTheory.integral_nonneg fun x => sq_nonneg _;
    by_cases H : MeasureTheory.IntegrableOn ( fun x => u x ^ 2 ) ( Set.Icc 0 1 ) MeasureTheory.MeasureSpace.volume <;> simp_all +decide [ sub_sq ];
    · rw [ MeasureTheory.integral_add, MeasureTheory.integral_sub ] at h_cauchy_schwarz <;> norm_num at *;
      · norm_num [ MeasureTheory.integral_const_mul, MeasureTheory.integral_mul_const ] at * ; nlinarith;
      · exact H;
      · exact MeasureTheory.Integrable.mul_const ( MeasureTheory.Integrable.const_mul hu_int _ ) _;
      · exact MeasureTheory.Integrable.sub H ( MeasureTheory.Integrable.mul_const ( MeasureTheory.Integrable.const_mul hu_int _ ) _ );
    · contrapose! H;
      refine' MeasureTheory.Integrable.mono' _ _ _;
      exacts [ fun x => 1, by norm_num, by simpa only [ sq ] using hu_int.aestronglyMeasurable.mul hu_int.aestronglyMeasurable, Filter.eventually_of_mem ( MeasureTheory.ae_restrict_mem measurableSet_Icc ) fun x hx => by simpa using pow_le_pow_left₀ ( abs_nonneg _ ) ( hu_bound x hx.1 hx.2 ) 2 ];
  -- Now consider the integral $\int_{0}^{1} (1 - x) u^{2}(x) \, dx$.
  have h_integral : ∫ x in Set.Icc 0 1, (1 - x) * u x ^ 2 ≤ 1 / 2 := by
    refine' le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _;
    refine' fun x => ( 1 - x );
    · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using mul_nonneg ( sub_nonneg.2 hx.2 ) ( sq_nonneg _ );
    · exact Continuous.integrableOn_Icc ( by continuity );
    · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using mul_le_of_le_one_right ( sub_nonneg.2 hx.2 ) ( by nlinarith only [ abs_le.mp ( hu_bound x hx ) ] );
    · rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le, intervalIntegral.integral_sub ] <;> norm_num;
  norm_num [ sub_mul ] at *;
  rw [ MeasureTheory.integral_sub ] at h_integral;
  · linarith;
  · refine' MeasureTheory.Integrable.mono' _ _ _;
    refine' fun x => 1;
    · norm_num;
    · simpa only [ sq ] using hu_int.aestronglyMeasurable.mul hu_int.aestronglyMeasurable;
    · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using by simpa using pow_le_pow_left₀ ( abs_nonneg _ ) ( hu_bound x hx.1 hx.2 ) 2;
  · refine' MeasureTheory.Integrable.mono' _ _ _;
    refine' fun x => 1;
    · norm_num;
    · exact MeasureTheory.AEStronglyMeasurable.mul ( measurable_id.aestronglyMeasurable ) ( hu_int.aestronglyMeasurable.pow 2 );
    · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using abs_le.mpr ⟨ by nlinarith only [ hx.1, hx.2, abs_le.mp ( hu_bound x hx.1 hx.2 ) ], by nlinarith only [ hx.1, hx.2, abs_le.mp ( hu_bound x hx.1 hx.2 ) ] ⟩

/-
Complex version of the lemma: For any complex-valued function g on [0,1] with |g| ≤ 1, |4(∫g)² - 2∫xg²| ≤ 3.
-/
theorem problem_15_lemma (g : ℝ → ℂ)
    (hg_int : MeasureTheory.IntegrableOn g (Set.Icc 0 1) MeasureTheory.volume)
    (hg_bound : ∀ x ∈ Set.Icc 0 1, Norm.norm (g x) ≤ 1) :
    Norm.norm (4 * (∫ x in Set.Icc 0 1, g x) ^ 2 - 2 * ∫ x in Set.Icc 0 1, x * (g x) ^ 2) ≤ 3 := by
  revert hg_int hg_bound;
  intro hg_int hg_bound
  obtain ⟨θ, hθ⟩ : ∃ θ : ℝ, 4 * (∫ x in Set.Icc 0 1, g x) ^ 2 - 2 * ∫ x in Set.Icc 0 1, x * g x ^ 2 = Complex.exp (θ * Complex.I) * ‖4 * (∫ x in Set.Icc 0 1, g x) ^ 2 - 2 * ∫ x in Set.Icc 0 1, x * g x ^ 2‖ := by
    exact ⟨ Complex.arg ( 4 * ( ∫ x in Set.Icc 0 1, g x ) ^ 2 - 2 * ∫ x in Set.Icc 0 1, x * g x ^ 2 ), by nth_rw 1 [ ← Complex.norm_mul_exp_arg_mul_I ( 4 * ( ∫ x in Set.Icc 0 1, g x ) ^ 2 - 2 * ∫ x in Set.Icc 0 1, x * g x ^ 2 ) ] ; ring ⟩;
  -- Let $h(x) = g(x) e^{-i\theta/2}$. Then $|h| \le 1$ and $J(h) = |J(g)|$.
  set h : ℝ → ℂ := fun x => g x * Complex.exp (-θ / 2 * Complex.I)
  have hh_int : MeasureTheory.IntegrableOn h (Set.Icc 0 1) MeasureTheory.MeasureSpace.volume := by
    exact hg_int.mul_const _
  have hh_bound : ∀ x ∈ Set.Icc 0 1, ‖h x‖ ≤ 1 := by
    exact fun x hx => by rw [ norm_mul, Complex.norm_exp ] ; norm_num; linarith [ hg_bound x hx ] ;
  have hh_J : 4 * (∫ x in Set.Icc 0 1, h x) ^ 2 - 2 * ∫ x in Set.Icc 0 1, x * h x ^ 2 = ‖4 * (∫ x in Set.Icc 0 1, g x) ^ 2 - 2 * ∫ x in Set.Icc 0 1, x * g x ^ 2‖ := by
    simp +zetaDelta at *;
    convert congr_arg ( fun x : ℂ => x * Complex.exp ( -θ * Complex.I ) ) hθ using 1 <;> ring;
    · norm_num [ mul_assoc, mul_comm, mul_left_comm, ← MeasureTheory.integral_const_mul, ← Complex.exp_nat_mul ] ; ring;
      rw [ MeasureTheory.integral_mul_const ] ; ring;
      rw [ ← Complex.exp_nat_mul ] ; ring;
    · norm_num [ mul_assoc, mul_comm, mul_left_comm, ← Complex.exp_add ];
      norm_num [ ← mul_assoc, ← Complex.exp_add ];
  -- Let $h = u + iv$. Then $J(h) = 4 (\int (u+iv))^2 - 2 \int x (u+iv)^2$.
  obtain ⟨u, v, hu, hv⟩ : ∃ u v : ℝ → ℝ, (∀ x ∈ Set.Icc 0 1, h x = u x + v x * Complex.I) ∧ MeasureTheory.IntegrableOn u (Set.Icc 0 1) MeasureTheory.MeasureSpace.volume ∧ MeasureTheory.IntegrableOn v (Set.Icc 0 1) MeasureTheory.MeasureSpace.volume ∧ (∀ x ∈ Set.Icc 0 1, u x ^ 2 + v x ^ 2 ≤ 1) := by
    refine' ⟨ fun x => ( h x |> Complex.re ), fun x => ( h x |> Complex.im ), _, _, _, _ ⟩ <;> norm_num [ Complex.ext_iff ] at *;
    · exact hh_int.re;
    · exact hh_int.im;
    · exact fun x hx₁ hx₂ => by simpa [ ← Complex.normSq_add_mul_I, Complex.normSq_eq_norm_sq ] using pow_le_pow_left₀ ( by positivity ) ( hh_bound x hx₁ hx₂ ) 2;
  -- Taking the real part: $\text{Re}(J(h)) = 4 ((\int u)^2 - (\int v)^2) - 2 \int x (u^2 - v^2) = (4 (\int u)^2 - 2 \int x u^2) - (4 (\int v)^2 - 2 \int x v^2)$.
  have h_real_part : Complex.re (4 * (∫ x in Set.Icc 0 1, h x) ^ 2 - 2 * ∫ x in Set.Icc 0 1, x * h x ^ 2) = (4 * (∫ x in Set.Icc 0 1, u x) ^ 2 - 2 * ∫ x in Set.Icc 0 1, x * u x ^ 2) - (4 * (∫ x in Set.Icc 0 1, v x) ^ 2 - 2 * ∫ x in Set.Icc 0 1, x * v x ^ 2) := by
    have h_real_part : ∫ x in Set.Icc 0 1, h x = (∫ x in Set.Icc 0 1, u x) + (∫ x in Set.Icc 0 1, v x) * Complex.I ∧ ∫ x in Set.Icc 0 1, x * h x ^ 2 = (∫ x in Set.Icc 0 1, x * (u x ^ 2 - v x ^ 2)) + (∫ x in Set.Icc 0 1, 2 * x * u x * v x) * Complex.I := by
      constructor;
      · rw [ MeasureTheory.setIntegral_congr_fun measurableSet_Icc hu, MeasureTheory.integral_add, MeasureTheory.integral_mul_const ];
        · exact congrArg₂ ( · + · ) ( integral_ofReal ) ( congr_arg₂ ( · * · ) ( integral_ofReal ) rfl );
        · exact hv.1.ofReal;
        · exact MeasureTheory.Integrable.mul_const ( by exact MeasureTheory.Integrable.ofReal hv.2.1 ) _;
      · have h_split : ∫ x in Set.Icc 0 1, x * h x ^ 2 = ∫ x in Set.Icc 0 1, (x * (u x ^ 2 - v x ^ 2) + 2 * x * u x * v x * Complex.I) := by
          exact MeasureTheory.setIntegral_congr_fun measurableSet_Icc fun x hx => by rw [ hu x hx ] ; ring_nf; norm_num ; ring;
        rw [ h_split, MeasureTheory.integral_add ];
        · norm_num [ MeasureTheory.integral_mul_const ];
          norm_cast;
          exact congrArg₂ ( · + · ) ( integral_ofReal ) ( congr_arg₂ ( · * · ) ( integral_ofReal ) rfl );
        · refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun x => 1 * ( 1 : ℝ );
          · norm_num;
          · refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
            · exact Complex.continuous_ofReal.aestronglyMeasurable;
            · exact MeasureTheory.AEStronglyMeasurable.sub ( MeasureTheory.AEStronglyMeasurable.pow ( Complex.continuous_ofReal.comp_aestronglyMeasurable hv.1.aestronglyMeasurable ) _ ) ( MeasureTheory.AEStronglyMeasurable.pow ( Complex.continuous_ofReal.comp_aestronglyMeasurable hv.2.1.aestronglyMeasurable ) _ );
          · norm_num +zetaDelta at *;
            exact Filter.eventually_inf_principal.mpr ( Filter.Eventually.of_forall fun x hx => by norm_cast; exact mul_le_one₀ ( abs_le.mpr ⟨ by linarith [ hx.1 ], by linarith [ hx.2 ] ⟩ ) ( abs_nonneg _ ) ( abs_le.mpr ⟨ by nlinarith [ hv.2.2 x hx.1 hx.2 ], by nlinarith [ hv.2.2 x hx.1 hx.2 ] ⟩ ) );
        · refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun x => 2 * 1 * 1 * 1 * 1;
          · norm_num;
          · exact MeasureTheory.AEStronglyMeasurable.mul ( MeasureTheory.AEStronglyMeasurable.mul ( MeasureTheory.AEStronglyMeasurable.mul ( MeasureTheory.AEStronglyMeasurable.mul ( MeasureTheory.aestronglyMeasurable_const ) ( Complex.continuous_ofReal.aestronglyMeasurable ) ) ( Complex.continuous_ofReal.comp_aestronglyMeasurable hv.1.aestronglyMeasurable ) ) ( Complex.continuous_ofReal.comp_aestronglyMeasurable hv.2.1.aestronglyMeasurable ) ) ( MeasureTheory.aestronglyMeasurable_const );
          · norm_num [ Complex.normSq, Complex.norm_def ];
            exact Filter.eventually_inf_principal.mpr ( Filter.Eventually.of_forall fun x hx => by nlinarith only [ abs_nonneg x, abs_nonneg ( u x ), abs_nonneg ( v x ), hx.1, hx.2, hv.2.2 x hx, sq_nonneg ( |u x| - |v x| ), abs_mul_abs_self x, abs_mul_abs_self ( u x ), abs_mul_abs_self ( v x ) ] );
    norm_num [ h_real_part, Complex.ext_iff, sq ];
    norm_num [ ← sq, h_real_part ] ; ring;
    rw [ MeasureTheory.integral_sub ];
    · ring;
    · refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => 1;
      · norm_num;
      · exact MeasureTheory.AEStronglyMeasurable.mul ( measurable_id.aestronglyMeasurable ) ( hv.1.aemeasurable.pow_const 2 |> fun h => h.aestronglyMeasurable );
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using abs_le.mpr ⟨ by nlinarith only [ hx.1, hx.2, hv.2.2 x hx ], by nlinarith only [ hx.1, hx.2, hv.2.2 x hx ] ⟩;
    · refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => 1;
      · norm_num;
      · exact MeasureTheory.AEStronglyMeasurable.mul ( measurable_id.aestronglyMeasurable ) ( hv.2.1.aestronglyMeasurable.pow 2 );
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using abs_le.mpr ⟨ by nlinarith only [ hx.1, hx.2, hv.2.2 x hx ], by nlinarith only [ hx.1, hx.2, hv.2.2 x hx ] ⟩;
  -- From `problem_15_real_lemma`, $2 (\int u)^2 \le 1 + 2 \int x u^2$, so $4 (\int u)^2 \le 2 + 4 \int x u^2$.
  have h_u : 4 * (∫ x in Set.Icc 0 1, u x) ^ 2 ≤ 2 + 4 * ∫ x in Set.Icc 0 1, x * u x ^ 2 := by
    have := problem_15_real_lemma u hv.1 ( fun x hx => abs_le.mpr ⟨ by nlinarith only [ hv.2.2 x hx ], by nlinarith only [ hv.2.2 x hx ] ⟩ );
    linarith;
  -- For $v$, $-F(v) = 2 \int x v^2 - 4 (\int v)^2 \le 2 \int x v^2$.
  have h_v : - (4 * (∫ x in Set.Icc 0 1, v x) ^ 2 - 2 * ∫ x in Set.Icc 0 1, x * v x ^ 2) ≤ 2 * ∫ x in Set.Icc 0 1, x * v x ^ 2 := by
    nlinarith only [ sq_nonneg ( ∫ x in Set.Icc 0 1, v x ) ];
  -- Since $u^2 + v^2 = |h|^2 \le 1$, $\int x (u^2 + v^2) \le \int x = 1/2$.
  have h_integral_bound : ∫ x in Set.Icc 0 1, x * (u x ^ 2 + v x ^ 2) ≤ 1 / 2 := by
    refine' le_trans ( MeasureTheory.setIntegral_mono_on _ _ measurableSet_Icc fun x hx => mul_le_of_le_one_right hx.1 ( hv.2.2 x hx ) ) _ <;> norm_num [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le zero_le_one ];
    · refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => 1;
      · norm_num;
      · exact MeasureTheory.AEStronglyMeasurable.mul ( measurable_id.aestronglyMeasurable ) ( MeasureTheory.AEStronglyMeasurable.add ( hv.1.aestronglyMeasurable.pow 2 ) ( hv.2.1.aestronglyMeasurable.pow 2 ) );
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using by rw [ Real.norm_of_nonneg ( mul_nonneg hx.1 ( add_nonneg ( sq_nonneg _ ) ( sq_nonneg _ ) ) ) ] ; nlinarith only [ hx.1, hx.2, hv.2.2 x hx ] ;
    · exact continuous_id.integrableOn_Icc;
  -- Therefore, $F(u) - F(v) \le 2 + 2 \int x (u^2 + v^2) \le 2 + 2(1/2) = 3$.
  have h_final : (4 * (∫ x in Set.Icc 0 1, u x) ^ 2 - 2 * ∫ x in Set.Icc 0 1, x * u x ^ 2) - (4 * (∫ x in Set.Icc 0 1, v x) ^ 2 - 2 * ∫ x in Set.Icc 0 1, x * v x ^ 2) ≤ 2 + 2 * (1 / 2) := by
    rw [ show ( fun x => x * ( u x ^ 2 + v x ^ 2 ) ) = fun x => x * u x ^ 2 + x * v x ^ 2 by ext; ring ] at h_integral_bound ; rw [ MeasureTheory.integral_add ] at h_integral_bound <;> norm_num at * ; linarith;
    · refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => 1;
      · norm_num;
      · exact MeasureTheory.AEStronglyMeasurable.mul ( measurable_id.aestronglyMeasurable ) ( hv.1.aestronglyMeasurable.pow 2 );
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using abs_le.mpr ⟨ by nlinarith only [ hx.1, hx.2, hv.2.2 x hx.1 hx.2 ], by nlinarith only [ hx.1, hx.2, hv.2.2 x hx.1 hx.2 ] ⟩;
    · refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => 1;
      · norm_num;
      · exact MeasureTheory.AEStronglyMeasurable.mul ( measurable_id.aestronglyMeasurable ) ( hv.2.1.aemeasurable.pow_const 2 |> fun h => h.aestronglyMeasurable );
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using abs_le.mpr ⟨ by nlinarith only [ hx.1, hx.2, hv.2.2 x hx.1 hx.2 ], by nlinarith only [ hx.1, hx.2, hv.2.2 x hx.1 hx.2 ] ⟩;
  norm_num [ Complex.ext_iff ] at * ; linarith

/-
Substitution lemma for Problem 15: The integral P can be transformed to an integral over [0,1] via x = exp(-t).
-/
theorem problem_15_substitution (φ : ℝ → ℝ)
    (hφ_loc_int : ∀ (a b : ℝ), 0 ≤ a → a ≤ b → MeasureTheory.IntegrableOn φ (Set.Icc a b) MeasureTheory.volume) :
    (∫ t in Set.Ioi (0 : ℝ), Complex.exp (-(t : ℂ) - Complex.I * (φ t : ℂ))) =
    ∫ x in Set.Icc 0 1, if x = 0 then 0 else Complex.exp (-Complex.I * (φ (-Real.log x) : ℂ)) := by
  -- Apply the substitution $x = e^{-t}$ to transform the integral.
  have h_subst : ∫ t in Set.Ioi (0 : ℝ), Complex.exp (-(t : ℂ) - Complex.I * (φ t)) = ∫ x in Set.Ioo (0 : ℝ) 1, Complex.exp (-Complex.I * (φ (-Real.log x))) := by
    have h_subst : ∫ t in Set.Ioi (0 : ℝ), Complex.exp (-(t : ℂ) - Complex.I * (φ t)) = ∫ x in (Set.image (fun t => Real.exp (-t)) (Set.Ioi (0 : ℝ))), Complex.exp (-Complex.I * (φ (-Real.log x))) := by
      rw [ MeasureTheory.integral_image_eq_integral_abs_deriv_smul ] <;> norm_num;
      any_goals intro x hx; exact HasDerivAt.hasDerivWithinAt ( by simpa using HasDerivAt.exp ( hasDerivAt_neg x ) );
      norm_num [ Complex.exp_sub, abs_neg, abs_of_pos, Real.exp_pos ];
      norm_num [ div_eq_mul_inv, Complex.exp_neg ];
    rw [ h_subst, show ( fun t => Real.exp ( -t ) ) '' Set.Ioi 0 = Set.Ioo 0 1 from ?_ ];
    norm_num [ Set.ext_iff ];
    exact fun x => ⟨ fun ⟨ t, ht, hx ⟩ => ⟨ hx ▸ Real.exp_pos _, hx ▸ Real.exp_lt_one_iff.mpr ( neg_lt_zero.mpr ht ) ⟩, fun hx => ⟨ -Real.log x, neg_pos.mpr ( Real.log_neg hx.1 hx.2 ), by rw [ neg_neg, Real.exp_log hx.1 ] ⟩ ⟩;
  rw [ h_subst, MeasureTheory.integral_Icc_eq_integral_Ioc, MeasureTheory.integral_Ioc_eq_integral_Ioo ] ; exact MeasureTheory.setIntegral_congr_fun measurableSet_Ioo fun x hx => by aesop;

/-
Substitution lemma for Q in Problem 15: The integral Q can be transformed to an integral over [0,1] via x = exp(-t).
-/
theorem problem_15_substitution_Q (φ : ℝ → ℝ)
    (hφ_loc_int : ∀ (a b : ℝ), 0 ≤ a → a ≤ b → MeasureTheory.IntegrableOn φ (Set.Icc a b) MeasureTheory.volume) :
    (∫ t in Set.Ioi (0 : ℝ), Complex.exp (-2 * (t : ℂ) - 2 * Complex.I * (φ t : ℂ))) =
    ∫ x in Set.Icc 0 1, x * (if x = 0 then 0 else Complex.exp (-Complex.I * (φ (-Real.log x) : ℂ))) ^ 2 := by
  -- Apply the substitution $x = e^{-t}$ to the integral.
  have h_subst : ∫ t in (Set.Ioi 0), (Complex.exp (-2 * t - 2 * Complex.I * (φ t))) = ∫ x in (Set.image (fun t => Real.exp (-t)) (Set.Ioi 0)), (x : ℂ) * (Complex.exp (-Complex.I * (φ (-Real.log x)))) ^ 2 := by
    rw [ MeasureTheory.integral_image_eq_integral_abs_deriv_smul ];
    any_goals intro x hx; exact HasDerivAt.hasDerivWithinAt ( by simpa using HasDerivAt.exp ( hasDerivAt_neg x ) );
    · norm_num [ ← Complex.exp_nat_mul, ← Complex.exp_add ] ; congr ; ext ; ring;
    · norm_num;
    · exact fun x hx y hy hxy => by simpa using hxy;
  rw [ h_subst, show ( fun t : ℝ => Real.exp ( -t ) ) '' Set.Ioi 0 = Set.Ioo 0 1 from ?_ ];
  · rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, MeasureTheory.integral_Ioc_eq_integral_Ioo ] ; exact MeasureTheory.setIntegral_congr_fun measurableSet_Ioo fun x hx => by aesop;
  · norm_num [ Set.ext_iff ];
    exact fun x => ⟨ fun ⟨ t, ht, hx ⟩ => ⟨ hx ▸ Real.exp_pos _, hx ▸ Real.exp_lt_one_iff.mpr ( neg_lt_zero.mpr ht ) ⟩, fun hx => ⟨ -Real.log x, neg_pos.mpr ( Real.log_neg hx.1 hx.2 ), by rw [ neg_neg, Real.exp_log hx.1 ] ⟩ ⟩

/-
Measurability lemma for Problem 15: The composition of φ with -log is measurable.
-/
theorem problem_15_measurability (φ : ℝ → ℝ)
    (hφ_loc_int : ∀ (a b : ℝ), 0 ≤ a → a ≤ b → MeasureTheory.IntegrableOn φ (Set.Icc a b) MeasureTheory.volume) :
    MeasureTheory.AEStronglyMeasurable (fun x => φ (-Real.log x)) (MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Ioo 0 1)) := by
  -- Since $\varphi$ is locally integrable on $[0, \infty)$, it is AE measurable on $(0, \infty)$.
  have h_phi_measurable : MeasureTheory.AEStronglyMeasurable φ (MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Ioi 0)) := by
    -- Since $\varphi$ is locally integrable on $[0, \infty)$, it is AE-strongly measurable on $[0, \infty)$.
    have h_phi_measurable : MeasureTheory.AEStronglyMeasurable φ (MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Ici 0)) := by
      have h_phi_measurable : ∀ n : ℕ, MeasureTheory.AEStronglyMeasurable φ (MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Icc 0 (n : ℝ))) := by
        exact fun n => ( hφ_loc_int 0 n le_rfl ( Nat.cast_nonneg _ ) |> MeasureTheory.Integrable.aestronglyMeasurable );
      convert MeasureTheory.AEStronglyMeasurable.iUnion h_phi_measurable;
      norm_num [ Set.ext_iff ];
      exact fun x hx => exists_nat_ge x;
    exact h_phi_measurable.mono_set <| Set.Ioi_subset_Ici_self;
  -- Since $-\log x$ is continuous on $(0, 1)$, the composition $\phi(-\log x)$ is measurable on $(0, 1)$.
  have h_log_measurable : MeasureTheory.AEStronglyMeasurable (fun x => -Real.log x) (MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Ioo 0 1)) := by
    exact Measurable.aestronglyMeasurable ( by exact Measurable.neg ( Real.measurable_log ) );
  have h_comp_measurable : MeasureTheory.AEStronglyMeasurable (fun x => φ x) (MeasureTheory.Measure.map (fun x => -Real.log x) (MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Ioo 0 1))) := by
    refine' h_phi_measurable.mono_ac _;
    refine' MeasureTheory.Measure.AbsolutelyContinuous.mk _;
    intro s hs hs';
    rw [ MeasureTheory.Measure.map_apply ];
    · simp_all +decide [ Set.preimage ];
      -- Since $-\log x$ is continuous and strictly decreasing on $(0, 1)$, the preimage of a set of measure zero under $-\log x$ also has measure zero.
      have h_preimage : MeasureTheory.MeasureSpace.volume (Set.image (fun x => Real.exp (-x)) (s ∩ Set.Ioi 0)) = 0 := by
        have h_preimage_zero : ∀ {t : Set ℝ}, MeasureTheory.MeasureSpace.volume t = 0 → MeasureTheory.MeasureSpace.volume (Set.image (fun x => Real.exp (-x)) t) = 0 := by
          intro t ht_zero
          have h_diff : DifferentiableOn ℝ (fun x => Real.exp (-x)) t := by
            exact DifferentiableOn.exp ( differentiableOn_id.neg );
          exact?;
        exact h_preimage_zero hs';
      refine' MeasureTheory.measure_mono_null _ h_preimage;
      exact fun x hx => ⟨ -Real.log x, ⟨ hx.1, neg_pos.mpr ( Real.log_neg hx.2.1 hx.2.2 ) ⟩, by simp +decide [ Real.exp_neg, Real.exp_log hx.2.1 ] ⟩;
    · exact Measurable.neg ( Real.measurable_log );
    · exact hs;
  exact h_comp_measurable.comp_aemeasurable h_log_measurable.aemeasurable

/-
Integrability lemma for Problem 15: The transformed function g is integrable on [0,1].
-/
theorem problem_15_g_integrable (φ : ℝ → ℝ)
    (hφ_loc_int : ∀ (a b : ℝ), 0 ≤ a → a ≤ b → MeasureTheory.IntegrableOn φ (Set.Icc a b) MeasureTheory.volume) :
    MeasureTheory.IntegrableOn (fun x => if x = 0 then 0 else Complex.exp (-Complex.I * (φ (-Real.log x) : ℂ))) (Set.Icc 0 1) MeasureTheory.volume := by
  refine' MeasureTheory.Integrable.mono' _ _ _;
  refine' fun x => 1;
  · norm_num;
  · -- The function $g(x)$ is measurable on $(0, 1)$ since it is a composition of measurable functions.
    have h_meas : MeasureTheory.AEStronglyMeasurable (fun x => Complex.exp (-Complex.I * (φ (-Real.log x)))) (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioo 0 1)) := by
      refine' Complex.continuous_exp.comp_aestronglyMeasurable _;
      apply_rules [ MeasureTheory.AEStronglyMeasurable.const_mul, Complex.continuous_ofReal.comp_aestronglyMeasurable ];
      exact?;
    rw [ MeasureTheory.Measure.restrict_congr_set MeasureTheory.Ioo_ae_eq_Icc ] at *;
    exact MeasureTheory.AEStronglyMeasurable.congr ( h_meas ) ( by filter_upwards [ MeasureTheory.measure_eq_zero_iff_ae_notMem.1 ( MeasureTheory.measure_singleton 0 ) ] with x hx; aesop );
  · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using by split_ifs <;> norm_num [ Complex.norm_exp ] ;

/-
Polya-Szego Problem 15: If φ is locally integrable, and P and Q are defined as certain integrals involving φ, then |4P² - 2Q| ≤ 3.
-/
theorem problem_15 (φ : ℝ → ℝ)
    (hφ_loc_int : ∀ (a b : ℝ), 0 ≤ a → a ≤ b → MeasureTheory.IntegrableOn φ (Set.Icc a b) MeasureTheory.volume) :
    let P : ℂ := ∫ t in Set.Ioi (0 : ℝ), Complex.exp (-(t : ℂ) - Complex.I * (φ t : ℂ))
    let Q : ℂ := ∫ t in Set.Ioi (0 : ℝ), Complex.exp (-2 * (t : ℂ) - 2 * Complex.I * (φ t : ℂ))
    Norm.norm (4 * P ^ 2 - 2 * Q) ≤ 3 := by
      -- Let $g(x) = \text{if } x=0 \text{ then } 0 \text{ else } \exp(-i \varphi(-\ln x))$.
      set g := fun x : ℝ => if x = 0 then 0 else Complex.exp (-Complex.I * (φ (-Real.log x) : ℂ));
      -- By the substitution lemma, we have $P = \int_0^1 g(x) dx$ and $Q = \int_0^1 x g(x)^2 dx$.
      have hP : ∫ t in Set.Ioi (0 : ℝ), Complex.exp (-(t : ℂ) - Complex.I * (φ t : ℂ)) = ∫ x in Set.Icc 0 1, g x := by
        convert problem_15_substitution φ hφ_loc_int using 1
      have hQ : ∫ t in Set.Ioi (0 : ℝ), Complex.exp (-2 * (t : ℂ) - 2 * Complex.I * (φ t : ℂ)) = ∫ x in Set.Icc 0 1, x * (g x) ^ 2 := by
        convert problem_15_substitution_Q φ hφ_loc_int using 1;
      -- By the lemma, we have $|4(\int g)^2 - 2 \int x g^2| \le 3$.
      have h_lemma : ‖4 * (∫ x in Set.Icc 0 1, g x) ^ 2 - 2 * (∫ x in Set.Icc 0 1, x * (g x) ^ 2)‖ ≤ 3 := by
        apply_rules [ problem_15_lemma ];
        · exact?;
        · norm_num +zetaDelta at *;
          intro x hx₁ hx₂; split_ifs <;> norm_num [ Complex.norm_exp ] ;
      aesop

/-
Equality condition for the real lemma: The bound is attained iff u is 1 or -1 almost everywhere.
-/
theorem problem_15_real_lemma_equality (u : ℝ → ℝ)
    (hu_int : MeasureTheory.IntegrableOn u (Set.Icc 0 1) MeasureTheory.volume)
    (hu_bound : ∀ x ∈ Set.Icc 0 1, |u x| ≤ 1) :
    2 * (∫ x in Set.Icc 0 1, u x) ^ 2 = 1 + 2 * ∫ x in Set.Icc 0 1, x * u x ^ 2 ↔
    (u =ᵐ[MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Icc 0 1)] 1 ∨
     u =ᵐ[MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Icc 0 1)] -1) := by
  -- Let's first show the forward direction of the equivalence.
  apply Iff.intro
  intro h_eq
  have h_const : (∫ x in Set.Icc 0 1, u x) ^ 2 = ∫ x in Set.Icc 0 1, u x ^ 2 := by
    have h_eq_part1 : (∫ x in Set.Icc 0 1, u x) ^ 2 ≤ ∫ x in Set.Icc 0 1, u x ^ 2 := by
      have h_cauchy_schwarz : (∫ x in Set.Icc 0 1, (u x - (∫ x in Set.Icc 0 1, u x)) ^ 2) ≥ 0 := by
        exact MeasureTheory.integral_nonneg fun x => sq_nonneg _;
      norm_num [ sub_sq, mul_assoc, MeasureTheory.integral_const_mul, MeasureTheory.integral_mul_const ] at *;
      rw [ MeasureTheory.integral_add, MeasureTheory.integral_sub ] at h_cauchy_schwarz <;> norm_num at *;
      · norm_num [ MeasureTheory.integral_const_mul, MeasureTheory.integral_mul_const ] at * ; nlinarith;
      · refine' MeasureTheory.Integrable.mono' _ _ _;
        exacts [ fun x => 1, by norm_num, by simpa only [ sq ] using hu_int.aestronglyMeasurable.mul hu_int.aestronglyMeasurable, Filter.eventually_of_mem ( MeasureTheory.ae_restrict_mem measurableSet_Icc ) fun x hx => by simpa using pow_le_pow_left₀ ( abs_nonneg _ ) ( hu_bound x hx.1 hx.2 ) 2 ];
      · exact MeasureTheory.Integrable.const_mul ( hu_int.mul_const _ ) _;
      · refine' MeasureTheory.Integrable.sub _ _;
        · refine' MeasureTheory.Integrable.mono' _ _ _;
          exacts [ fun x => 1, by norm_num, by exact MeasureTheory.AEStronglyMeasurable.pow ( hu_int.aestronglyMeasurable ) 2, Filter.eventually_of_mem ( MeasureTheory.ae_restrict_mem measurableSet_Icc ) fun x hx => by simpa using pow_le_pow_left₀ ( abs_nonneg _ ) ( hu_bound x hx.1 hx.2 ) 2 ];
        · exact MeasureTheory.Integrable.const_mul ( hu_int.mul_const _ ) _;
    have h_eq_part2 : ∫ x in Set.Icc 0 1, (1 - x) * u x ^ 2 ≤ ∫ x in Set.Icc 0 1, (1 - x) := by
      refine' MeasureTheory.setIntegral_mono_on _ _ measurableSet_Icc fun x hx => mul_le_of_le_one_right ( sub_nonneg.2 hx.2 ) ( by nlinarith only [ abs_le.mp ( hu_bound x hx ) ] );
      · refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun x => 1 - x;
        · exact Continuous.integrableOn_Icc ( by continuity );
        · exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( by continuity ) ) ( hu_int.aestronglyMeasurable.pow 2 );
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using by rw [ Real.norm_of_nonneg ( mul_nonneg ( sub_nonneg.2 hx.2 ) ( sq_nonneg _ ) ) ] ; exact mul_le_of_le_one_right ( sub_nonneg.2 hx.2 ) ( by nlinarith only [ abs_le.mp ( hu_bound x hx ) ] ) ;
      · exact Continuous.integrableOn_Icc ( by continuity );
    simp_all +decide [ sub_mul ];
    rw [ MeasureTheory.integral_sub ] at h_eq_part2;
    · rw [ MeasureTheory.integral_sub ] at h_eq_part2 <;> norm_num [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le zero_le_one ] at * ; linarith;
      exact Continuous.integrableOn_Icc <| by continuity;
    · refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => 1;
      · norm_num;
      · simpa only [ sq ] using hu_int.aestronglyMeasurable.mul hu_int.aestronglyMeasurable;
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using by simpa using pow_le_pow_left₀ ( abs_nonneg _ ) ( hu_bound x hx.1 hx.2 ) 2;
    · refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => 1;
      · norm_num;
      · exact MeasureTheory.AEStronglyMeasurable.mul ( measurable_id.aestronglyMeasurable ) ( hu_int.aestronglyMeasurable.pow 2 );
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using abs_le.mpr ⟨ by nlinarith only [ hx.1, hx.2, abs_le.mp ( hu_bound x hx.1 hx.2 ) ], by nlinarith only [ hx.1, hx.2, abs_le.mp ( hu_bound x hx.1 hx.2 ) ] ⟩;
  · -- Since $(\int u)^2 = \int u^2$, we have that $u$ is constant almost everywhere. Let $c$ be this constant.
    obtain ⟨c, hc⟩ : ∃ c : ℝ, ∀ᵐ x ∂MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Icc 0 1), u x = c := by
      have h_const : ∫ x in Set.Icc 0 1, (u x - (∫ x in Set.Icc 0 1, u x)) ^ 2 = 0 := by
        norm_num [ sub_sq ];
        rw [ MeasureTheory.integral_add, MeasureTheory.integral_sub ] <;> norm_num;
        · norm_num [ MeasureTheory.integral_const_mul, MeasureTheory.integral_mul_const ] ; linarith;
        · refine' MeasureTheory.Integrable.mono' _ _ _;
          exacts [ fun x => 1, by norm_num, by exact hu_int.aestronglyMeasurable.pow 2, Filter.eventually_of_mem ( MeasureTheory.ae_restrict_mem measurableSet_Icc ) fun x hx => by simpa using pow_le_pow_left₀ ( abs_nonneg _ ) ( hu_bound x hx ) 2 ];
        · exact MeasureTheory.Integrable.mul_const ( MeasureTheory.Integrable.const_mul hu_int _ ) _;
        · refine' MeasureTheory.Integrable.sub _ _;
          · refine' MeasureTheory.Integrable.mono' _ _ _;
            exacts [ fun x => 1, by norm_num, by exact hu_int.aestronglyMeasurable.pow 2, Filter.eventually_of_mem ( MeasureTheory.ae_restrict_mem measurableSet_Icc ) fun x hx => by simpa using pow_le_pow_left₀ ( abs_nonneg _ ) ( hu_bound x hx ) 2 ];
          · exact MeasureTheory.Integrable.mul_const ( MeasureTheory.Integrable.const_mul hu_int _ ) _;
      rw [ MeasureTheory.integral_eq_zero_iff_of_nonneg ( fun x => sq_nonneg _ ) ] at h_const;
      · exact ⟨ _, h_const.mono fun x hx => sub_eq_zero.mp <| sq_eq_zero_iff.mp hx ⟩;
      · refine' MeasureTheory.MemLp.integrable_sq _;
        refine' MeasureTheory.MemLp.sub _ _;
        · refine' MeasureTheory.MemLp.mono' _ _ _;
          exacts [ fun _ => 1, MeasureTheory.memLp_const _, hu_int.aestronglyMeasurable, Filter.eventually_of_mem ( MeasureTheory.ae_restrict_mem measurableSet_Icc ) fun x hx => hu_bound x hx ];
        · exact MeasureTheory.memLp_const _;
    -- Since $u$ is constant almost everywhere, we have $\int u^2 = c^2$.
    have h_c_sq : ∫ x in Set.Icc 0 1, u x ^ 2 = c ^ 2 := by
      rw [ MeasureTheory.integral_congr_ae ( hc.mono fun x hx => by rw [ hx ] ) ] ; norm_num;
    -- Since $u$ is constant almost everywhere, we have $\int x u^2 = c^2 \int x$.
    have h_c_sq_x : ∫ x in Set.Icc 0 1, x * u x ^ 2 = c ^ 2 * ∫ x in Set.Icc 0 1, x := by
      rw [ ← MeasureTheory.integral_const_mul ] ; exact MeasureTheory.integral_congr_ae ( by filter_upwards [ hc ] with x hx; rw [ hx ] ; ring ) ;
    norm_num [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le zero_le_one ] at *;
    exact Or.imp ( fun h => by filter_upwards [ hc ] with x hx; aesop ) ( fun h => by filter_upwards [ hc ] with x hx; aesop ) ( eq_or_eq_neg_of_sq_eq_sq c 1 <| by nlinarith );
  · rintro ( h|h ) <;> rw [ MeasureTheory.integral_congr_ae h ] <;> norm_num;
    · rw [ MeasureTheory.integral_congr_ae ( h.mono fun x hx => by aesop ) ] ; norm_num;
      rw [ MeasureTheory.integral_congr_ae ( h.mono fun x hx => by aesop ) ] ; norm_num [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le zero_le_one ];
    · rw [ MeasureTheory.integral_congr_ae ( by filter_upwards [ h ] with x hx; aesop ) ] ; norm_num [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le zero_le_one ]

/-
Converse of equality condition: If g is constant with modulus 1, the bound is 3.
-/
theorem problem_15_lemma_equality_converse (g : ℝ → ℂ)
    (hg_int : MeasureTheory.IntegrableOn g (Set.Icc 0 1) MeasureTheory.volume)
    (hg_bound : ∀ x ∈ Set.Icc 0 1, Norm.norm (g x) ≤ 1)
    (c : ℂ) (hc_norm : ‖c‖ = 1)
    (hg_eq : g =ᵐ[MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Icc 0 1)] fun _ => c) :
    Norm.norm (4 * (∫ x in Set.Icc 0 1, g x) ^ 2 - 2 * ∫ x in Set.Icc 0 1, x * (g x) ^ 2) = 3 := by
  simp +zetaDelta at *;
  -- Since $g = c$ almost everywhere, we can replace $g$ with $c$ in the integrals.
  have h_int_eq : ∫ x in Set.Icc (0 : ℝ) 1, g x = ∫ x in Set.Icc (0 : ℝ) 1, c ∧ ∫ x in Set.Icc (0 : ℝ) 1, x * g x ^ 2 = ∫ x in Set.Icc (0 : ℝ) 1, x * c ^ 2 := by
    rw [ Filter.EventuallyEq, Filter.eventually_inf_principal ] at hg_eq;
    exact ⟨ MeasureTheory.setIntegral_congr_ae measurableSet_Icc ( by filter_upwards [ hg_eq ] with x hx using by aesop ), MeasureTheory.setIntegral_congr_ae measurableSet_Icc ( by filter_upwards [ hg_eq ] with x hx using by aesop ) ⟩;
  simp_all +decide [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le zero_le_one ];
  erw [ intervalIntegral.integral_ofReal ] ; norm_num [ hc_norm ];
  ring_nf; norm_num [ hc_norm ]