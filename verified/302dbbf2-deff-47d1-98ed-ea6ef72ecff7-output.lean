/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 302dbbf2-deff-47d1-98ed-ea6ef72ecff7
-/

/-
We formalized the problem of finding values of $z$ for which the $n$-th term of the exponential series has the strictly largest absolute value.
The initial formalization was disproven by the ATP due to the edge case $z=0$.
We corrected the statement to handle $z=0$ and proved the corrected version:
`problem_11_corrected`: For a complex number $z$ and natural number $n$, the absolute value of the $n$-th term $|z^n/n!|$ is strictly greater than any other term $|z^k/k!|$ ($k \neq n$) if and only if $|z| < n+1$ and ($n=0$ or $n < |z|$).
This confirms the condition $n < |z| < n+1$ for $n > 0$, and $|z| < 1$ for $n=0$.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check (norm : ℂ → ℝ)

/-
For a complex number z and natural number n, the absolute value of the n-th term of the exponential series z^n/n! is strictly greater than any other term if and only if |z| < n+1 and (n=0 or n < |z|).
-/
theorem problem_11_corrected (z : ℂ) (n : ℕ) :
    (∀ k : ℕ, k ≠ n → norm (z ^ n / (Nat.factorial n : ℂ)) >
                    norm (z ^ k / (Nat.factorial k : ℂ))) ↔
    norm z < (n + 1 : ℝ) ∧ (n = 0 ∨ (n : ℝ) < norm z) := by
  by_cases hz : z = 0 <;> simp_all +decide [ div_eq_iff ];
  · by_cases hn : n = 0 <;> simp_all +decide [ Nat.factorial_ne_zero ];
    exact iff_of_false ( fun h => absurd ( h 0 ( by positivity ) ) ( by norm_num ) ) ( by norm_cast; aesop );
  · constructor <;> intro h;
    · constructor <;> contrapose! h;
      · use n + 1;
        rw [ div_le_div_iff₀ ] <;> first | positivity | norm_num [ pow_succ, Nat.factorial_succ ];
        nlinarith [ show 0 ≤ ‖z‖ ^ n * ( n.factorial : ℝ ) by positivity ];
      · field_simp;
        refine' ⟨ n - 1, _, _ ⟩ <;> rcases n with ( _ | n ) <;> simp_all +decide [ Nat.factorial_succ, mul_comm ];
        nlinarith [ pow_nonneg ( norm_nonneg z ) n, pow_succ' ( ‖z‖ ) n, show ( 0 : ℝ ) ≤ ‖z‖ ^ n * n.factorial by positivity ];
    · -- Let's consider the two cases: $k < n$ and $k > n$.
      intro k hk_ne_n
      by_cases hk_lt_n : k < n;
      · -- We can divide both sides by $‖z‖^k$ since it is positive.
        have h_div : ‖z‖ ^ (n - k) > (Nat.factorial n) / (Nat.factorial k) := by
          -- We can divide both sides by $‖z‖^k$ since it is positive, yielding $‖z‖^{n-k} > \frac{n!}{k!}$.
          have h_div : ‖z‖ ^ (n - k) > (∏ i ∈ Finset.Icc (k + 1) n, (i : ℝ)) := by
            refine' lt_of_le_of_lt _ ( pow_lt_pow_left₀ ( show ‖z‖ > n by cases h.2 <;> aesop ) ( by positivity ) ( Nat.sub_ne_zero_of_lt hk_lt_n ) );
            exact le_trans ( Finset.prod_le_prod ( fun _ _ => Nat.cast_nonneg _ ) fun _ _ => show ( _ : ℝ ) ≤ n by norm_cast; linarith [ Finset.mem_Icc.mp ‹_› ] ) ( by simp +decide [ hk_lt_n.le ] );
          convert h_div using 1;
          erw [ Finset.prod_Ico_eq_prod_range ];
          rw [ div_eq_iff ( by positivity ) ];
          rw_mod_cast [ ← Nat.add_sub_of_le hk_lt_n.le ];
          exact Nat.recOn ( n - k ) ( by norm_num ) fun n ih => by simp +decide [ Finset.prod_range_succ, Nat.factorial ] at * ; nlinarith;
        rw [ show ‖z‖ ^ n = ‖z‖ ^ ( n - k ) * ‖z‖ ^ k by rw [ ← pow_add, Nat.sub_add_cancel hk_lt_n.le ] ];
        rw [ div_lt_div_iff₀ ] <;> try positivity;
        rw [ gt_iff_lt, div_lt_iff₀ ] at h_div <;> first | positivity | nlinarith [ pow_pos ( norm_pos_iff.mpr hz ) k ] ;
      · -- Since $k > n$, we can write $k = n + m$ for some $m \geq 1$.
        obtain ⟨m, hm⟩ : ∃ m : ℕ, k = n + m ∧ 1 ≤ m := by
          exact ⟨ k - n, by rw [ Nat.add_sub_cancel' ( le_of_not_gt hk_lt_n ) ], Nat.sub_pos_of_lt ( lt_of_le_of_ne ( le_of_not_gt hk_lt_n ) ( Ne.symm hk_ne_n ) ) ⟩;
        -- We'll use that $‖z‖^{n+m} / (n+m)! < ‖z‖^n / n!$ simplifies to $‖z‖^m < (n+1)(n+2)...(n+m)$.
        suffices h_simp : ‖z‖^m < (∏ i ∈ Finset.range m, (n + 1 + i : ℝ)) by
          -- We can rewrite the inequality $‖z‖^m < (n+1)(n+2)...(n+m)$ as $‖z‖^m * n! < (n+m)!$.
          have h_rewrite : ‖z‖^m * (Nat.factorial n : ℝ) < (Nat.factorial (n + m) : ℝ) := by
            convert mul_lt_mul_of_pos_right h_simp ( Nat.cast_pos.mpr ( Nat.factorial_pos n ) ) using 1;
            exact mod_cast Nat.recOn m ( by norm_num ) fun k ih => by rw [ Nat.add_succ, Nat.factorial_succ, Finset.prod_range_succ ] ; nlinarith;
          field_simp;
          rw [ hm.1, pow_add ] ; nlinarith [ pow_pos ( norm_pos_iff.mpr hz ) n, pow_pos ( norm_pos_iff.mpr hz ) m ] ;
        exact lt_of_lt_of_le ( pow_lt_pow_left₀ h.1 ( norm_nonneg _ ) ( by linarith ) ) ( by exact le_trans ( by norm_num ) ( Finset.prod_le_prod ( fun _ _ => by positivity ) fun _ _ => show ( n : ℝ ) + 1 + _ ≥ ( n : ℝ ) + 1 by linarith ) )