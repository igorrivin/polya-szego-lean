/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5f36cfbb-d5d5-4a0b-bd1a-92d2ecbd00e6
-/

/-
We formalized Polya-Szego Problem 166 regarding the nesting of intervals $(x_n, y_n)$.
We defined $y_n = n! n^{-n-1/2} e^n$ and $x_n = y_n e^{-1/(12n)}$.
We proved that for $k \ge 1$, $x_{k+1} > x_k$ and $y_{k+1} < y_k$.
The proof relies on logarithmic inequalities derived from Taylor series expansions.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of y_n from Polya-Szego Problem 166.
-/
def problem_166_y_n (n : ℕ) : ℝ := (Nat.factorial n : ℝ) * ((n : ℝ) ^ (-(n : ℝ) - 1/2)) * Real.exp n

/-
Definition of x_n from Polya-Szego Problem 166.
-/
def problem_166_x_n (n : ℕ) : ℝ := problem_166_y_n n * Real.exp (-1/(12 * n))

/-
For x > 0, log(1+x) > 2x/(2+x).
-/
lemma log_ineq_1 (x : ℝ) (hx : x > 0) : Real.log (1 + x) > 2 * x / (2 + x) := by
  -- Let's define the function $f(x) = \log(1+x) - \frac{2x}{2+x}$ and show that its derivative is positive for $x > 0$.
  set f : ℝ → ℝ := fun x => Real.log (1 + x) - 2 * x / (2 + x)
  have h_deriv_pos : ∀ x > 0, deriv f x > 0 := by
    norm_num +zetaDelta at *;
    intro x hx; norm_num [ add_comm, mul_comm, ne_of_gt, add_pos, hx ];
    rw [ inv_eq_one_div, div_lt_div_iff₀ ] <;> nlinarith;
  -- Since $f$ is differentiable and its derivative is positive for $x > 0$, we can apply the Mean Value Theorem to $f$ on the interval $(0, x)$.
  have h_mvt : ∃ c ∈ Set.Ioo 0 x, deriv f c = (f x - f 0) / (x - 0) := by
    apply_rules [ exists_deriv_eq_slope ];
    · exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.sub ( ContinuousAt.log ( continuousAt_const.add continuousAt_id ) ( by linarith [ hx.1 ] ) ) ( ContinuousAt.div ( continuousAt_const.mul continuousAt_id ) ( continuousAt_const.add continuousAt_id ) ( by linarith [ hx.1 ] ) );
    · exact fun x hx => DifferentiableAt.differentiableWithinAt ( by exact DifferentiableAt.sub ( DifferentiableAt.log ( differentiableAt_id.const_add _ ) ( by linarith [ hx.1 ] ) ) ( DifferentiableAt.div ( differentiableAt_id.const_mul _ ) ( differentiableAt_id.const_add _ ) ( by linarith [ hx.1 ] ) ) );
  norm_num +zetaDelta at *;
  obtain ⟨ c, ⟨ hc₁, hc₂ ⟩, hc ⟩ := h_mvt; have := h_deriv_pos c hc₁; rw [ hc ] at this; rw [ lt_div_iff₀ hx ] at this; linarith;

/-
For x > 0, log(1+x) < 2x/(2+x) + x^3/(6(1+x)(2+x)).
-/
lemma log_ineq_2 (x : ℝ) (hx : x > 0) : Real.log (1 + x) < 2 * x / (2 + x) + x^3 / (6 * (1 + x) * (2 + x)) := by
  -- By definition of $g$, we know that $g(x) > 0$ for $x > 0$.
  have hg : ∀ x > 0, deriv (fun x => 2 * x / (2 + x) + x^3 / (6 * (1 + x) * (2 + x)) - Real.log (1 + x)) x > 0 := by
    intro x hx; norm_num [ add_comm, mul_comm, ne_of_gt, add_pos, hx ];
    rw [ inv_eq_one_div, div_add_div, div_lt_div_iff₀ ] <;> ring <;> nlinarith [ pow_pos hx 3, pow_pos hx 4, pow_pos hx 5, pow_pos hx 6 ];
  -- Apply the mean value theorem to $g$ on the interval $(0, x)$.
  obtain ⟨c, hc⟩ : ∃ c ∈ Set.Ioo 0 x, deriv (fun x => 2 * x / (2 + x) + x^3 / (6 * (1 + x) * (2 + x)) - Real.log (1 + x)) c = ( (fun x => 2 * x / (2 + x) + x^3 / (6 * (1 + x) * (2 + x)) - Real.log (1 + x)) x - (fun x => 2 * x / (2 + x) + x^3 / (6 * (1 + x) * (2 + x)) - Real.log (1 + x)) 0 ) / (x - 0) := by
    apply_rules [ exists_deriv_eq_slope ];
    · exact continuousOn_of_forall_continuousAt fun x hx => by exact ContinuousAt.sub ( ContinuousAt.add ( ContinuousAt.div ( continuousAt_const.mul continuousAt_id ) ( continuousAt_const.add continuousAt_id ) ( by linarith [ hx.1 ] ) ) ( ContinuousAt.div ( continuousAt_id.pow 3 ) ( ContinuousAt.mul ( continuousAt_const.mul ( continuousAt_const.add continuousAt_id ) ) ( continuousAt_const.add continuousAt_id ) ) ( by nlinarith [ hx.1 ] ) ) ) ( ContinuousAt.log ( continuousAt_const.add continuousAt_id ) ( by linarith [ hx.1 ] ) ) ;
    · exact fun x hx => DifferentiableAt.differentiableWithinAt ( by exact differentiableAt_of_deriv_ne_zero ( ne_of_gt ( hg x hx.1 ) ) );
  have := hg c hc.1.1; rw [ hc.2, div_eq_mul_inv ] at this; aesop;

/-
For k >= 1, y_{k+1} < y_k.
-/
lemma problem_166_y_decreasing (k : ℕ) (hk : k ≥ 1) : problem_166_y_n (k + 1) < problem_166_y_n k := by
  -- We show that log(y_{k+1}) < log(y_k).
  have h_log : Real.log (problem_166_y_n (k + 1)) < Real.log (problem_166_y_n k) := by
    -- Taking logs: log(y_{k+1}/y_k) = 1 - (k+1/2)log(1+1/k).
    have h_log_ratio : Real.log (problem_166_y_n (k + 1) / problem_166_y_n k) = 1 - (k + 1 / 2) * Real.log (1 + 1 / k) := by
      unfold problem_166_y_n; norm_num [ Nat.factorial_succ ];
      rw [ Real.log_div, Real.log_mul, Real.log_mul, Real.log_mul ] <;> first | positivity | norm_num [ Real.rpow_def_of_pos, add_pos, Nat.cast_add, Nat.cast_one, hk ] ; ring;
      rw [ Real.log_mul ( by positivity ) ( by positivity ), Real.log_mul ( by positivity ) ( by positivity ) ] ; norm_num [ Real.log_rpow ( by positivity : 0 < ( 1 + k : ℝ ) ), Real.log_rpow ( by positivity : 0 < ( k : ℝ ) ) ] ; ring;
      rw [ show ( 1 + ( k : ℝ ) ) = k * ( 1 + ( k : ℝ ) ⁻¹ ) by nlinarith only [ mul_inv_cancel₀ ( by positivity : ( k : ℝ ) ≠ 0 ) ], Real.log_mul ( by positivity ) ( by positivity ) ] ; ring;
    rw [ Real.log_div ] at h_log_ratio;
    · have := log_ineq_1 ( 1 / ( k : ℝ ) ) ( by positivity );
      -- Simplifying the inequality.
      field_simp at *;
      linarith;
    · exact ne_of_gt ( by exact mul_pos ( mul_pos ( Nat.cast_pos.mpr ( Nat.factorial_pos _ ) ) ( Real.rpow_pos_of_pos ( by positivity ) _ ) ) ( Real.exp_pos _ ) );
    · exact ne_of_gt ( by exact mul_pos ( mul_pos ( Nat.cast_pos.mpr ( Nat.factorial_pos _ ) ) ( Real.rpow_pos_of_pos ( by positivity ) _ ) ) ( Real.exp_pos _ ) );
  rwa [ Real.log_lt_log_iff ( by exact mul_pos ( mul_pos ( Nat.cast_pos.mpr ( Nat.factorial_pos _ ) ) ( Real.rpow_pos_of_pos ( Nat.cast_pos.mpr ( Nat.succ_pos _ ) ) _ ) ) ( Real.exp_pos _ ) ) ( by exact mul_pos ( mul_pos ( Nat.cast_pos.mpr ( Nat.factorial_pos _ ) ) ( Real.rpow_pos_of_pos ( Nat.cast_pos.mpr hk ) _ ) ) ( Real.exp_pos _ ) ) ] at h_log

/-
For k >= 1, x_{k+1} > x_k.
-/
lemma problem_166_x_increasing (k : ℕ) (hk : k ≥ 1) : problem_166_x_n (k + 1) > problem_166_x_n k := by
  -- We show that log(x_{k+1}) > log(x_k).
  have h_log : Real.log (problem_166_x_n (k + 1)) > Real.log (problem_166_x_n k) := by
    -- We show that log(x_{k+1}) > log(x_k) by simplifying the logarithm expressions and using the fact that y_{k+1}/y_k < exp(1/(12(k+1)) - 1/(12k)).
    have h_log : Real.log (problem_166_y_n (k + 1)) - Real.log (problem_166_y_n k) > 1 / (12 * (k + 1)) - 1 / (12 * k) := by
      -- We'll use the fact that $y_{k+1}/y_k = (1+1/k)^{-(k+1/2)} * e$.
      have h_ratio : Real.log (problem_166_y_n (k + 1)) - Real.log (problem_166_y_n k) = -(k + 1 / 2) * Real.log (1 + 1 / (k : ℝ)) + 1 := by
        unfold problem_166_y_n;
        norm_num [ Real.rpow_def_of_pos ( by positivity : 0 < ( k:ℝ ) + 1 ), Real.rpow_def_of_pos ( by positivity : 0 < ( k:ℝ ) ), Nat.factorial_succ ];
        norm_num [ Real.log_mul, Nat.factorial_ne_zero, Real.exp_ne_zero, ne_of_gt ( by positivity : 0 < ( k:ℝ ) + 1 ), ne_of_gt ( by positivity : 0 < ( k:ℝ ) ) ] ; ring;
        rw [ show ( 1 + k : ℝ ) = k * ( 1 + ( k : ℝ ) ⁻¹ ) by nlinarith only [ mul_inv_cancel₀ ( by positivity : ( k : ℝ ) ≠ 0 ) ], Real.log_mul ( by positivity ) ( by positivity ) ] ; ring;
      -- We'll use the fact that $Real.log (1 + x) < 2x / (2 + x) + x^3 / (6 * (1 + x) * (2 + x))$ for $x > 0$.
      have h_log_ineq : Real.log (1 + 1 / (k : ℝ)) < 2 * (1 / (k : ℝ)) / (2 + 1 / (k : ℝ)) + (1 / (k : ℝ))^3 / (6 * (1 + 1 / (k : ℝ)) * (2 + 1 / (k : ℝ))) := by
        apply log_ineq_2; positivity;
      field_simp at *;
      nlinarith [ ( by norm_cast : ( 1 :ℝ ) ≤ k ), pow_pos ( by positivity : 0 < ( k :ℝ ) ) 2, pow_pos ( by positivity : 0 < ( k :ℝ ) ) 3 ];
    unfold problem_166_x_n;
    rw [ Real.log_mul ( by exact ne_of_gt <| by exact mul_pos ( mul_pos ( Nat.cast_pos.mpr <| Nat.factorial_pos _ ) <| Real.rpow_pos_of_pos ( Nat.cast_pos.mpr <| by linarith ) _ ) <| Real.exp_pos _ ) ( by positivity ), Real.log_mul ( by exact ne_of_gt <| by exact mul_pos ( mul_pos ( Nat.cast_pos.mpr <| Nat.factorial_pos _ ) <| Real.rpow_pos_of_pos ( Nat.cast_pos.mpr <| by linarith ) _ ) <| Real.exp_pos _ ) ( by positivity ) ] ; norm_num ; ring_nf at * ; linarith;
  rwa [ gt_iff_lt, Real.log_lt_log_iff ] at h_log;
  · exact mul_pos ( mul_pos ( Nat.cast_pos.mpr ( Nat.factorial_pos _ ) ) ( Real.rpow_pos_of_pos ( Nat.cast_pos.mpr hk ) _ ) ) ( Real.exp_pos _ ) |> mul_pos <| Real.exp_pos _;
  · exact mul_pos ( by exact mul_pos ( mul_pos ( Nat.cast_pos.mpr <| Nat.factorial_pos _ ) <| by positivity ) <| Real.exp_pos _ ) <| Real.exp_pos _

/-
The sequence of intervals (x_k, y_k) is nested, i.e., x_{k+1} > x_k and y_{k+1} < y_k for k >= 1.
-/
theorem problem_166_interval_nesting (k : ℕ) (hk : k ≥ 1) :
    problem_166_x_n (k + 1) > problem_166_x_n k ∧ problem_166_y_n (k + 1) < problem_166_y_n k := by
  exact ⟨problem_166_x_increasing k hk, problem_166_y_decreasing k hk⟩