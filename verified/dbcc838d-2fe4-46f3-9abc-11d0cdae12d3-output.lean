/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: dbcc838d-2fe4-46f3-9abc-11d0cdae12d3

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Real
open Set
open scoped Real

/-
The statement "For every function f with continuous derivative on (a,b), and every ξ in (a,b), there exist x₁ < ξ < x₂ such that the secant slope equals f'(ξ)" is false.
-/
theorem problem_120_part1_corrected : ¬ (∀ {a b : ℝ} (hab : a < b) (f : ℝ → ℝ)
    (hf : DifferentiableOn ℝ f (Set.Ioo a b))
    (hf' : ContinuousOn (deriv f) (Set.Ioo a b)),
    ∀ ξ ∈ Set.Ioo a b, ∃ (x₁ x₂ : ℝ), x₁ < ξ ∧ ξ < x₂ ∧ x₁ ∈ Set.Ioo a b ∧ x₂ ∈ Set.Ioo a b ∧
    (f x₂ - f x₁) / (x₂ - x₁) = deriv f ξ) := by
  norm_num +zetaDelta at *;
  refine' ⟨ -1, 1, by norm_num, fun x => x ^ 3, _, _, 0, _, _ ⟩ <;> norm_num [ DifferentiableOn ];
  · exact fun x _ _ => differentiableWithinAt_pow 3;
  · exact Continuous.continuousOn ( by rw [ show deriv ( fun x : ℝ => x ^ 3 ) = fun x : ℝ => 3 * x ^ 2 by funext; norm_num ] ; continuity );
  · exact fun x hx y hy₁ hy₂ hy₃ hy₄ hy₅ => ⟨ by nlinarith [ sq_nonneg ( x^2 - y^2 ), pow_pos ( sub_pos.2 hx ) 3, pow_pos ( sub_pos.2 hy₁ ) 3 ], by linarith ⟩ ;

theorem problem_120_part2 {a b : ℝ} (hab : a < b) (f : ℝ → ℝ)
    (hf : DifferentiableOn ℝ f (Set.Icc a b))
    (hfa : f a = 0) (hfb : f b = 0)
    (hconst : ¬∀ x ∈ Set.Icc a b, f x = 0) :
    ∃ ξ ∈ Set.Ioo a b, |deriv f ξ| > 4 / ((b - a) ^ 2) * ∫ x in a..b, f x := by
  -- Let $I = \int_a^b f(x) dx$. If $I \le 0$, then since $f$ is not constant and $f(a)=f(b)=0$, $f'$ is not identically zero, so there exists $\xi$ with $|f'(\xi)| > 0 \ge \frac{4}{(b-a)^2} I$.
  by_cases hI : ∫ x in a..b, f x ≤ 0;
  · -- Since $f$ is not constant and $f(a)=f(b)=0$, there exists some $c \in (a,b)$ such that $f(c) \neq f(a)$.
    obtain ⟨c, hc⟩ : ∃ c ∈ Set.Ioo a b, f c ≠ 0 := by
      norm_num +zetaDelta at *;
      obtain ⟨ x, hx₁, hx₂, hx₃ ⟩ := hconst; exact ⟨ x, ⟨ lt_of_le_of_ne hx₁ ( by aesop ), lt_of_le_of_ne hx₂ ( by aesop ) ⟩, hx₃ ⟩ ;
    -- By the Mean Value Theorem, there exists some $\xi \in (a,c)$ such that $f'(\xi) = \frac{f(c) - f(a)}{c - a}$.
    obtain ⟨ξ₁, hξ₁⟩ : ∃ ξ₁ ∈ Set.Ioo a c, deriv f ξ₁ = (f c - f a) / (c - a) := by
      have := exists_deriv_eq_slope f hc.1.1;
      exact this ( hf.continuousOn.mono ( Set.Icc_subset_Icc le_rfl hc.1.2.le ) ) ( hf.mono ( Set.Ioo_subset_Icc_self.trans ( Set.Icc_subset_Icc le_rfl hc.1.2.le ) ) );
    use ξ₁;
    simp +zetaDelta at *;
    exact ⟨ ⟨ by linarith, by linarith ⟩, lt_of_le_of_lt ( mul_nonpos_of_nonneg_of_nonpos ( by exact div_nonneg zero_le_four ( sq_nonneg _ ) ) hI ) ( abs_pos.mpr ( show deriv f ξ₁ ≠ 0 from by rw [ hξ₁.2, hfa ] ; exact div_ne_zero ( sub_ne_zero.mpr <| by aesop ) <| by linarith ) ) ⟩;
  · by_contra h_contra;
    -- Then by the Mean Value Theorem, $|f(x)| \le K(x-a)$ and $|f(x)| \le K(b-x)$.
    set K := (4 / (b - a) ^ 2) * (∫ x in a..b, f x)
    have h_bound : ∀ x ∈ Set.Icc a b, |f x| ≤ K * min (x - a) (b - x) := by
      -- Applying the Mean Value Theorem to the intervals [a, x] and [x, b], we get that |f(x)| ≤ K(x - a) and |f(x)| ≤ K(b - x).
      have h_mvt : ∀ x ∈ Set.Ioo a b, |f x| ≤ K * (x - a) ∧ |f x| ≤ K * (b - x) := by
        intro x hx
        have h_mvt_left : ∃ c ∈ Set.Ioo a x, deriv f c = (f x - f a) / (x - a) := by
          have := exists_deriv_eq_slope f hx.1;
          exact this ( hf.continuousOn.mono ( Set.Icc_subset_Icc le_rfl hx.2.le ) ) ( hf.mono ( Set.Ioo_subset_Icc_self.trans ( Set.Icc_subset_Icc le_rfl hx.2.le ) ) )
        have h_mvt_right : ∃ c ∈ Set.Ioo x b, deriv f c = (f b - f x) / (b - x) := by
          have := exists_deriv_eq_slope f hx.2;
          exact this ( hf.continuousOn.mono ( Set.Icc_subset_Icc hx.1.le le_rfl ) ) ( hf.mono ( Set.Ioo_subset_Icc_self.trans ( Set.Icc_subset_Icc hx.1.le le_rfl ) ) );
        simp +zetaDelta at *;
        exact ⟨ by obtain ⟨ c, ⟨ hc₁, hc₂ ⟩, hc₃ ⟩ := h_mvt_left; rw [ abs_le ] ; constructor <;> nlinarith [ abs_le.mp ( h_contra c hc₁ ( by linarith ) ), mul_div_cancel₀ ( f x - f a ) ( by linarith : ( x - a ) ≠ 0 ) ], by obtain ⟨ c, ⟨ hc₁, hc₂ ⟩, hc₃ ⟩ := h_mvt_right; rw [ abs_le ] ; constructor <;> nlinarith [ abs_le.mp ( h_contra c ( by linarith ) hc₂ ), mul_div_cancel₀ ( f b - f x ) ( by linarith : ( b - x ) ≠ 0 ) ] ⟩;
      intro x hx; cases hx.1.eq_or_lt <;> cases hx.2.eq_or_lt <;> simp_all +decide ;
      cases min_cases ( x - a ) ( b - x ) <;> nlinarith [ h_mvt x ‹_› ‹_›, abs_nonneg ( f x ) ];
    -- Since $|f(x)| \le K \min(x-a, b-x)$, we have $f(x) = K \min(x-a, b-x)$ almost everywhere.
    have h_eq : ∀ᵐ x ∂MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Icc a b), f x = K * min (x - a) (b - x) := by
      have h_eq : ∫ x in Set.Icc a b, (K * min (x - a) (b - x) - f x) = 0 := by
        rw [ MeasureTheory.integral_sub ];
        · -- Evaluate the integral $\int_a^b \min(x-a, b-x) \, dx$.
          have h_integral_min : ∫ x in Set.Icc a b, min (x - a) (b - x) = (b - a) ^ 2 / 4 := by
            -- Split the integral into two parts: from $a$ to $(a+b)/2$ and from $(a+b)/2$ to $b$.
            have h_split : ∫ x in Set.Icc a b, min (x - a) (b - x) = (∫ x in Set.Icc a ((a + b) / 2), min (x - a) (b - x)) + (∫ x in Set.Icc ((a + b) / 2) b, min (x - a) (b - x)) := by
              norm_num [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le, hab.le ];
              rw [ ← intervalIntegral.integral_of_le ( by linarith ), ← intervalIntegral.integral_of_le ( by linarith ), intervalIntegral.integral_add_adjacent_intervals ] <;> exact Continuous.intervalIntegrable ( by continuity ) _ _;
            rw [ h_split, MeasureTheory.setIntegral_congr_fun measurableSet_Icc fun x hx => min_eq_left <| by linarith [ hx.1, hx.2 ], MeasureTheory.setIntegral_congr_fun measurableSet_Icc fun x hx => min_eq_right <| by linarith [ hx.1, hx.2 ] ];
            rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le, ← intervalIntegral.integral_of_le, intervalIntegral.integral_sub, intervalIntegral.integral_sub ] <;> norm_num <;> linarith;
          rw [ MeasureTheory.integral_const_mul, h_integral_min ];
          rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ] <;> norm_num [ hab.le ];
          rw [ sub_eq_zero, mul_comm ] ; rw [ div_mul_eq_mul_div, div_eq_iff ] <;> nlinarith [ mul_div_cancel₀ ( 4 : ℝ ) ( by nlinarith : ( b - a ) ^ 2 ≠ 0 ) ];
        · exact Continuous.integrableOn_Icc ( by continuity );
        · exact hf.continuousOn.integrableOn_Icc;
      rw [ MeasureTheory.integral_eq_zero_iff_of_nonneg_ae ] at h_eq;
      · filter_upwards [ h_eq ] with x hx using Eq.symm <| sub_eq_zero.mp hx;
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx using sub_nonneg_of_le <| le_of_abs_le <| h_bound x hx;
      · exact ContinuousOn.integrableOn_Icc ( by exact ContinuousOn.sub ( ContinuousOn.mul continuousOn_const <| ContinuousOn.inf ( continuousOn_id.sub continuousOn_const ) ( continuousOn_const.sub continuousOn_id ) ) hf.continuousOn );
    -- Since $f$ is continuous and $f(x) = K \min(x-a, b-x)$ almost everywhere, we have $f(x) = K \min(x-a, b-x)$ for all $x \in [a, b]$.
    have h_cont_eq : ∀ x ∈ Set.Icc a b, f x = K * min (x - a) (b - x) := by
      rw [ MeasureTheory.ae_restrict_iff' ] at h_eq;
      · rw [ MeasureTheory.ae_iff ] at h_eq;
        intro x hx; by_cases hx' : f x = K * Min.min ( x - a ) ( b - x ) <;> simp_all +decide [ Set.Icc_def ] ;
        -- Since $f$ is continuous and $f(x) \neq K \min(x-a, b-x)$, there exists an open interval around $x$ where $f$ does not take the value $K \min(x-a, b-x)$.
        obtain ⟨ε, hε⟩ : ∃ ε > 0, ∀ y, abs (y - x) < ε → y ∈ Set.Icc a b → f y ≠ K * min (y - a) (b - y) := by
          have := Metric.continuousOn_iff.mp ( show ContinuousOn ( fun y => f y - K * Min.min ( y - a ) ( b - y ) ) ( Set.Icc a b ) from ContinuousOn.sub ( hf.continuousOn ) ( ContinuousOn.mul continuousOn_const <| ContinuousOn.inf ( continuousOn_id.sub continuousOn_const ) ( continuousOn_const.sub continuousOn_id ) ) ) x hx;
          exact Exists.elim ( this ( |f x - K * Min.min ( x - a ) ( b - x )| ) ( abs_pos.mpr ( sub_ne_zero.mpr hx' ) ) ) fun δ hδ => ⟨ δ, hδ.1, fun y hy₁ hy₂ => fun hy₃ => hx' <| by cases abs_cases ( f x - K * Min.min ( x - a ) ( b - x ) ) <;> linarith [ abs_lt.mp ( hδ.2 y hy₂ hy₁ ) ] ⟩;
        -- Since $ε > 0$, the interval $(x - ε, x + ε)$ has positive measure.
        have h_pos_measure : 0 < MeasureTheory.MeasureSpace.volume (Set.Ioo (max a (x - ε)) (min b (x + ε))) := by
          simp;
          exact ⟨ ⟨ hab, by linarith ⟩, by linarith, by linarith ⟩;
        exact h_pos_measure.ne' ( MeasureTheory.measure_mono_null ( fun y hy => by exact ⟨ by cases max_cases a ( x - ε ) <;> linarith [ hy.1, hy.2 ], by cases min_cases b ( x + ε ) <;> linarith [ hy.1, hy.2 ], hε.2 y ( abs_lt.2 ⟨ by cases max_cases a ( x - ε ) <;> linarith [ hy.1, hy.2 ], by cases min_cases b ( x + ε ) <;> linarith [ hy.1, hy.2 ] ⟩ ) ⟨ by cases max_cases a ( x - ε ) <;> linarith [ hy.1, hy.2 ], by cases min_cases b ( x + ε ) <;> linarith [ hy.1, hy.2 ] ⟩ ⟩ ) h_eq );
      · norm_num;
    -- Since $f$ is differentiable on $[a, b]$, it must be differentiable at $x = \frac{a+b}{2}$.
    have h_diff_midpoint : DifferentiableAt ℝ f ((a + b) / 2) := by
      exact hf.differentiableAt ( Icc_mem_nhds ( by linarith ) ( by linarith ) );
    -- However, $K \min(x-a, b-x)$ is not differentiable at $x = \frac{a+b}{2}$.
    have h_not_diff_midpoint : ¬ DifferentiableAt ℝ (fun x => K * min (x - a) (b - x)) ((a + b) / 2) := by
      -- The function $K \min(x-a, b-x)$ is not differentiable at $x = \frac{a+b}{2}$ because the left-hand derivative and right-hand derivative are not equal.
      have h_not_diff_midpoint : ¬ DifferentiableAt ℝ (fun x => min (x - a) (b - x)) ((a + b) / 2) := by
        intro H; have := H.hasDerivAt; have := this.tendsto_slope_zero; norm_num [ min_def ] at this;
        rw [ Metric.tendsto_nhdsWithin_nhds ] at this;
        obtain ⟨ δ, δ_pos, H ⟩ := this ( 1 / 2 ) ( by norm_num ) ; have L := H ( show ( -δ / 2 ) ≠ 0 by linarith ) ( abs_lt.mpr ⟨ by linarith, by linarith ⟩ ) ; have R := H ( show ( δ / 2 ) ≠ 0 by linarith ) ( abs_lt.mpr ⟨ by linarith, by linarith ⟩ ) ; norm_num [ neg_div ] at L R;
        split_ifs at L R <;> nlinarith [ abs_lt.mp L, abs_lt.mp R, mul_div_cancel₀ ( 2 : ℝ ) δ_pos.ne' ];
      exact fun h => h_not_diff_midpoint <| by simpa [ show K ≠ 0 by exact mul_ne_zero ( div_ne_zero ( by norm_num ) <| pow_ne_zero 2 <| sub_ne_zero_of_ne hab.ne' ) <| by linarith ] using h.const_mul K⁻¹;
    exact h_not_diff_midpoint <| h_diff_midpoint.congr_of_eventuallyEq <| Filter.eventuallyEq_of_mem ( Icc_mem_nhds ( by linarith ) ( by linarith ) ) fun x hx => h_cont_eq x hx ▸ rfl

def problem_120_w (x₀ r t : ℝ) : ℝ := if t ≤ x₀ then (t - (x₀ - r))^2 / 2 else (x₀ + r - t)^2 / 2

theorem problem_120_w_integral {x₀ r : ℝ} (hr : 0 < r) :
    ∫ t in (x₀ - r)..(x₀ + r), problem_120_w x₀ r t = r^3 / 3 := by
  by_contra h_contra;
  -- Split the integral at $x_0$.
  have h_split : ∫ t in x₀ - r..x₀ + r, problem_120_w x₀ r t = (∫ t in x₀ - r..x₀, problem_120_w x₀ r t) + (∫ t in x₀..x₀ + r, problem_120_w x₀ r t) := by
    rw [ intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ Continuous.intervalIntegrable ] <;> unfold problem_120_w <;> apply_rules [ Continuous.if_le, Continuous.pow, Continuous.sub, continuous_id, continuous_const ] <;> norm_num;
    · continuity;
    · continuity;
    · continuity;
    · continuity;
  -- Evaluate the integral of $w(t)$ over $[x_0 - r, x_0]$.
  have h_left : ∫ t in x₀ - r..x₀, problem_120_w x₀ r t = ∫ t in x₀ - r..x₀, (t - (x₀ - r)) ^ 2 / 2 := by
    refine' intervalIntegral.integral_congr fun t ht => _;
    unfold problem_120_w;
    rw [ if_pos ( by cases Set.mem_uIcc.mp ht <;> linarith ) ];
  -- Evaluate the integral of $w(t)$ over $[x_0, x_0 + r]$.
  have h_right : ∫ t in x₀..x₀ + r, problem_120_w x₀ r t = ∫ t in x₀..x₀ + r, (x₀ + r - t) ^ 2 / 2 := by
    refine' intervalIntegral.integral_congr fun t ht => _;
    unfold problem_120_w;
    split_ifs <;> cases Set.mem_uIcc.mp ht <;> nlinarith;
  norm_num [ h_left, h_right, h_split ] at h_contra;
  exact h_contra <| by norm_num [ sub_sq, mul_comm ] ; ring;

lemma problem_120_identity_left_step2 {x₀ r : ℝ} (hr : 0 < r) (f : ℝ → ℝ)
    (hf : ContDiffOn ℝ 1 f (Set.Icc (x₀ - r) x₀)) :
    ∫ t in (x₀ - r)..x₀, deriv f t * (t - (x₀ - r)) =
    f x₀ * r - ∫ t in (x₀ - r)..x₀, f t := by
  -- By fundamental theorem of calculus, we can rewrite the integral as follows:
  have h_ftc : ∫ t in (x₀ - r)..x₀, deriv f t * (t - (x₀ - r)) = (∫ t in (x₀ - r)..x₀, deriv f t * t) - (∫ t in (x₀ - r)..x₀, deriv f t * (x₀ - r)) := by
    rw [ ← intervalIntegral.integral_sub ] ; congr ; ext ; ring;
    · rw [ intervalIntegrable_iff_integrableOn_Ioo_of_le ];
      · have := hf.continuousOn_derivWithin;
        specialize this ( by exact uniqueDiffOn_Icc ( by linarith ) ) le_rfl;
        have h_integrable : MeasureTheory.IntegrableOn (fun t => derivWithin f (Set.Icc (x₀ - r) x₀) t * t) (Set.Ioo (x₀ - r) x₀) := by
          exact ContinuousOn.integrableOn_Icc ( this.mul continuousOn_id ) |> fun h => h.mono_set <| Set.Ioo_subset_Icc_self;
        exact h_integrable.congr_fun ( fun x hx => by rw [ derivWithin_of_mem_nhds ( Icc_mem_nhds hx.1 hx.2 ) ] ) measurableSet_Ioo;
      · linarith;
    · have := hf.continuousOn_derivWithin;
      rw [ intervalIntegrable_iff_integrableOn_Ioo_of_le ( by linarith ) ];
      specialize this ( uniqueDiffOn_Icc ( by linarith ) ) le_rfl;
      exact MeasureTheory.IntegrableOn.congr_fun ( this.integrableOn_Icc.mono_set ( Set.Ioo_subset_Icc_self ) |> fun h => h.mul_const _ ) ( fun t ht => by rw [ derivWithin_of_mem_nhds ( Icc_mem_nhds ht.1 ht.2 ) ] ) measurableSet_Ioo;
  have h_ftc : ∫ t in (x₀ - r)..x₀, deriv f t * t = (f x₀) * x₀ - (f (x₀ - r)) * (x₀ - r) - ∫ t in (x₀ - r)..x₀, f t := by
    rw [ eq_sub_iff_add_eq ];
    rw [ ← intervalIntegral.integral_add, intervalIntegral.integral_eq_sub_of_hasDeriv_right ];
    · simpa only [ Set.uIcc_of_le ( by linarith : x₀ - r ≤ x₀ ) ] using hf.continuousOn.mul continuousOn_id;
    · intro x hx; convert HasDerivAt.hasDerivWithinAt ( HasDerivAt.mul ( hf.differentiableOn le_rfl |> DifferentiableOn.hasDerivAt <| Icc_mem_nhds ( show x > x₀ - r from by cases max_cases ( x₀ - r ) x₀ <;> cases min_cases ( x₀ - r ) x₀ <;> linarith [ hx.1, hx.2 ] ) ( show x < x₀ from by cases max_cases ( x₀ - r ) x₀ <;> cases min_cases ( x₀ - r ) x₀ <;> linarith [ hx.1, hx.2 ] ) ) ( hasDerivAt_id x ) ) using 1 ; ring;
      rfl;
    · rw [ intervalIntegrable_iff_integrableOn_Ioo_of_le ( by linarith ) ];
      have h_integrable : MeasureTheory.IntegrableOn (fun x => deriv f x) (Set.Ioo (x₀ - r) x₀) := by
        have := hf.continuousOn_derivWithin;
        specialize this ( by exact uniqueDiffOn_Icc ( by linarith ) ) le_rfl;
        refine' this.integrableOn_Icc.mono_set ( Set.Ioo_subset_Icc_self ) |> fun h => h.congr_fun ( fun x hx => _ ) measurableSet_Ioo;
        exact derivWithin_of_mem_nhds ( Icc_mem_nhds hx.1 hx.2 );
      refine' MeasureTheory.Integrable.add _ _;
      · refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun x => |deriv f x| * ( |x₀| + r );
        · exact MeasureTheory.Integrable.mul_const ( h_integrable.norm ) _;
        · exact MeasureTheory.AEStronglyMeasurable.mul ( h_integrable.aestronglyMeasurable ) ( measurable_id.aestronglyMeasurable );
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioo ] with x hx using by rw [ norm_mul ] ; exact mul_le_mul_of_nonneg_left ( abs_le.mpr ⟨ by cases abs_cases x₀ <;> linarith [ hx.1, hx.2 ], by cases abs_cases x₀ <;> linarith [ hx.1, hx.2 ] ⟩ ) ( abs_nonneg _ ) ;
      · exact hf.continuousOn.integrableOn_Icc.mono_set <| Set.Ioo_subset_Icc_self;
    · rw [ intervalIntegrable_iff_integrableOn_Ioo_of_le ( by linarith ) ];
      have h_integrable : MeasureTheory.IntegrableOn (deriv f) (Set.Ioo (x₀ - r) x₀) := by
        have := hf.continuousOn_derivWithin;
        specialize this ( by exact uniqueDiffOn_Icc ( by linarith ) ) le_rfl;
        exact ( this.integrableOn_Icc.mono_set <| Set.Ioo_subset_Icc_self ) |> fun h => h.congr_fun ( fun x hx => by rw [ derivWithin_of_mem_nhds ( Icc_mem_nhds hx.1 hx.2 ) ] ) measurableSet_Ioo;
      refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun t => |deriv f t| * ( |x₀| + r );
      · exact MeasureTheory.Integrable.mul_const ( h_integrable.norm ) _;
      · exact MeasureTheory.AEStronglyMeasurable.mul ( h_integrable.aestronglyMeasurable ) ( measurable_id.aestronglyMeasurable );
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioo ] with t ht using by rw [ norm_mul ] ; exact mul_le_mul_of_nonneg_left ( abs_le.mpr ⟨ by cases abs_cases x₀ <;> linarith [ ht.1, ht.2 ], by cases abs_cases x₀ <;> linarith [ ht.1, ht.2 ] ⟩ ) ( abs_nonneg _ ) ;
    · exact hf.continuousOn.intervalIntegrable_of_Icc ( by linarith );
  have h_ftc : ∫ t in (x₀ - r)..x₀, deriv f t * (x₀ - r) = (f x₀) * (x₀ - r) - (f (x₀ - r)) * (x₀ - r) := by
    rw [ intervalIntegral.integral_eq_sub_of_hasDeriv_right ];
    rotate_right;
    use fun t => f t * ( x₀ - r );
    · norm_num;
    · simpa only [ Set.uIcc_of_le ( by linarith : x₀ - r ≤ x₀ ) ] using hf.continuousOn.mul continuousOn_const;
    · field_simp;
      exact fun t ht => HasDerivAt.hasDerivWithinAt ( HasDerivAt.const_mul _ <| hf.differentiableOn le_rfl |> DifferentiableOn.hasDerivAt <| Icc_mem_nhds ( by cases max_cases ( x₀ - r ) x₀ <;> cases min_cases ( x₀ - r ) x₀ <;> linarith [ ht.1, ht.2 ] ) ( by cases max_cases ( x₀ - r ) x₀ <;> cases min_cases ( x₀ - r ) x₀ <;> linarith [ ht.1, ht.2 ] ) );
    · rw [ intervalIntegrable_iff_integrableOn_Ioo_of_le ( by linarith ) ];
      have h_integrable : MeasureTheory.IntegrableOn (fun t => deriv f t) (Set.Ioo (x₀ - r) x₀) := by
        have := hf.continuousOn_derivWithin;
        specialize this ( by exact uniqueDiffOn_Icc ( by linarith ) ) le_rfl;
        exact ( this.integrableOn_Icc.mono_set <| Set.Ioo_subset_Icc_self ) |> fun h => h.congr_fun ( fun x hx => by rw [ derivWithin_of_mem_nhds ( Icc_mem_nhds hx.1 hx.2 ) ] ) measurableSet_Ioo;
      exact h_integrable.mul_const _;
  linarith

lemma problem_120_identity_right_step2 {x₀ r : ℝ} (hr : 0 < r) (f : ℝ → ℝ)
    (hf : ContDiffOn ℝ 1 f (Set.Icc x₀ (x₀ + r))) :
    ∫ t in x₀..(x₀ + r), deriv f t * (x₀ + r - t) =
    -f x₀ * r + ∫ t in x₀..(x₀ + r), f t := by
  rw [ intervalIntegral.integral_eq_sub_of_hasDeriv_right ];
  rotate_right;
  use fun x => ( x₀ + r - x ) * f x + ∫ t in x₀..x, f t;
  · simpa using by ring;
  · refine' ContinuousOn.add _ _;
    · simpa only [ Set.uIcc_of_le ( by linarith : x₀ ≤ x₀ + r ) ] using ContinuousOn.mul ( continuousOn_const.sub continuousOn_id ) hf.continuousOn;
    · intro x hx; apply_rules [ intervalIntegral.continuousWithinAt_primitive, hf.continuousOn ] ; aesop;
      apply_rules [ ContinuousOn.intervalIntegrable, hf.continuousOn ];
      simpa [ hr.le ] using hf.continuousOn;
  · intro x hx
    have h_deriv : HasDerivWithinAt (fun x => (x₀ + r - x) * f x) (-(f x) + (x₀ + r - x) * deriv f x) (Set.Ioi x) x := by
      convert HasDerivAt.hasDerivWithinAt ( HasDerivAt.mul ( hasDerivAt_id' x |> HasDerivAt.const_sub _ ) ( hf.differentiableOn le_rfl |> DifferentiableOn.hasDerivAt <| Icc_mem_nhds ( show x > x₀ by cases min_cases x₀ ( x₀ + r ) <;> cases max_cases x₀ ( x₀ + r ) <;> linarith [ hx.1, hx.2 ] ) ( show x < x₀ + r by cases min_cases x₀ ( x₀ + r ) <;> cases max_cases x₀ ( x₀ + r ) <;> linarith [ hx.1, hx.2 ] ) ) ) using 1 ; ring!;
    have h_ftc : HasDerivWithinAt (fun x => ∫ t in x₀..x, f t) (f x) (Set.Ioi x) x := by
      have h_ftc : ∀ x ∈ Set.Ioo x₀ (x₀ + r), HasDerivAt (fun x => ∫ t in x₀..x, f t) (f x) x := by
        intro x hx;
        apply_rules [ intervalIntegral.integral_hasDerivAt_right ];
        · apply_rules [ ContinuousOn.intervalIntegrable, hf.continuousOn ];
          exact hf.continuousOn.mono ( by rw [ Set.uIcc_of_le hx.1.le ] ; exact Set.Icc_subset_Icc le_rfl hx.2.le );
        · exact ⟨ Set.Ioo x₀ ( x₀ + r ), Ioo_mem_nhds hx.1 hx.2, hf.continuousOn.aestronglyMeasurable ( measurableSet_Icc ) |> fun h => h.mono_set <| Set.Ioo_subset_Icc_self ⟩;
        · exact hf.continuousOn.continuousAt ( Icc_mem_nhds hx.1 hx.2 );
      exact HasDerivAt.hasDerivWithinAt ( h_ftc x ⟨ by cases min_cases x₀ ( x₀ + r ) <;> cases max_cases x₀ ( x₀ + r ) <;> linarith [ hx.1, hx.2 ], by cases min_cases x₀ ( x₀ + r ) <;> cases max_cases x₀ ( x₀ + r ) <;> linarith [ hx.1, hx.2 ] ⟩ );
    convert h_deriv.add h_ftc using 1 ; ring;
  · rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le ];
    · have h_integrable : MeasureTheory.IntegrableOn (fun t => deriv f t) (Set.Ioc x₀ (x₀ + r)) := by
        have h_deriv_integrable : MeasureTheory.IntegrableOn (fun t => deriv f t) (Set.Ioo x₀ (x₀ + r)) := by
          have := hf.continuousOn_derivWithin;
          specialize this ( by exact uniqueDiffOn_Icc ( by linarith ) ) le_rfl;
          exact ( this.integrableOn_Icc.mono_set <| Set.Ioo_subset_Icc_self ) |> fun h => h.congr_fun ( fun x hx => by rw [ derivWithin_of_mem_nhds ( Icc_mem_nhds hx.1 hx.2 ) ] ) measurableSet_Ioo;
        rwa [ MeasureTheory.IntegrableOn, MeasureTheory.Measure.restrict_congr_set MeasureTheory.Ioo_ae_eq_Ioc ] at *;
      refine' h_integrable.norm.mul_const _ |> fun h => h.mono' _ _;
      exacts [ r, MeasureTheory.AEStronglyMeasurable.mul ( h_integrable.aestronglyMeasurable ) ( Continuous.aestronglyMeasurable ( by continuity ) ), Filter.eventually_of_mem ( MeasureTheory.ae_restrict_mem measurableSet_Ioc ) fun t ht => by rw [ norm_mul ] ; exact mul_le_mul_of_nonneg_left ( abs_le.mpr ⟨ by linarith [ ht.1, ht.2 ], by linarith [ ht.1, ht.2 ] ⟩ ) ( norm_nonneg _ ) ];
    · linarith