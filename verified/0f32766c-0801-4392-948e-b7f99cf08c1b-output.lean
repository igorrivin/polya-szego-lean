/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0f32766c-0801-4392-948e-b7f99cf08c1b
-/

/-
We have formalized and proved Polya-Szego Problem 128, which states that for a continuous function f on [a, b] (with a ≤ b), the integral of f over [a, b] is bounded by m(b - a) and M(b - a), where m and M are the minimum and maximum values of f on [a, b] respectively.

The formalization uses `Set.uIcc` for the interval and `intervalIntegral` for the integral. The proof relies on the monotonicity of the integral (`intervalIntegral.integral_mono_on`) and the fact that a continuous function on a compact interval attains its bounds.

The theorem is formalized as `problem_128`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Checking if definitions and notation are available.
-/
#check Set.uIcc
#check sInf
#check sSup
#check ∫ x in (0:ℝ)..(1:ℝ), x

/-
If f is continuous on [a,b], then the integral of f from a to b is between m*(b-a) and M*(b-a), where m and M are the min and max of f on [a,b].
-/
theorem problem_128 (a b : ℝ) (hab : a ≤ b) (f : ℝ → ℝ)
    (hcont : ContinuousOn f (Set.uIcc a b)) :
    (sInf (f '' Set.uIcc a b)) * (b - a) ≤ ∫ x in a..b, f x ∧ ∫ x in a..b, f x ≤ (sSup (f '' Set.uIcc a b)) * (b - a) := by
      -- By definition of integrals, we know that ∫ x in a..b, f x is between m*(b-a) and M*(b-a), where m and M are the minimum and maximum values of f on [a,b].
      have h_integral_bounds : (∫ x in a..b, f x) ≥ (∫ x in a..b, (InfSet.sInf (f '' (Set.uIcc a b)) : ℝ)) ∧ (∫ x in a..b, f x) ≤ (∫ x in a..b, (SupSet.sSup (f '' (Set.uIcc a b)) : ℝ)) := by
        constructor;
        · apply_rules [ intervalIntegral.integral_mono_on ];
          · norm_num;
          · apply_rules [ ContinuousOn.intervalIntegrable, hcont ];
          · exact fun x hx => csInf_le ( IsCompact.bddBelow ( isCompact_uIcc.image_of_continuousOn hcont ) ) ( Set.mem_image_of_mem _ <| by simpa [ hab ] using hx );
        · apply_rules [ intervalIntegral.integral_mono_on ];
          · apply_rules [ ContinuousOn.intervalIntegrable, hcont ];
          · norm_num;
          · exact fun x hx => le_csSup ( IsCompact.bddAbove ( isCompact_Icc.image_of_continuousOn hcont ) ) ( Set.mem_image_of_mem _ ( by simpa [ hab ] using hx ) );
      simpa [ mul_comm, hab ] using h_integral_bounds