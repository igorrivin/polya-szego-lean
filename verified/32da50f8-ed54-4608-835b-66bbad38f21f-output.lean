/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 32da50f8-ed54-4608-835b-66bbad38f21f
-/

/-
We define the sequence $u_n = \frac{v_n}{n+v_n}$ and prove that the set of its cluster points is a closed interval.
We first show that the difference between consecutive terms tends to 0 (specifically $u_n - u_{n+1} \le \frac{1}{n+1}$).
Then we use the fact that the set of cluster points of a sequence with diminishing steps is connected.
Since the sequence is bounded, the set of cluster points is also closed and bounded, hence a closed interval.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The difference between consecutive terms of the sequence u_n is at most 1/(n+1).
-/
open Filter Topology Set

noncomputable def u (v : ‚Ñï ‚Üí ‚Ñï) (n : ‚Ñï) : ‚Ñù := (v n : ‚Ñù) / (n + v n)

lemma u_diff_le (v : ‚Ñï ‚Üí ‚Ñï) (hv_pos : ‚àÄ n, 0 < v n) (hv_mono : ‚àÄ n, v n ‚â§ v (n + 1)) (n : ‚Ñï) :
    u v n - u v (n + 1) ‚â§ 1 / (n + 1) := by
  norm_num [ u ];
  rw [ inv_eq_one_div, div_add_div, div_le_div_iff‚ÇÄ ] <;> try positivity;
  ¬∑ nlinarith [ show ( v n : ‚Ñù ) ‚â§ v ( n + 1 ) by exact_mod_cast hv_mono n, sq ( n : ‚Ñù ) ];
  ¬∑ exact add_pos_of_nonneg_of_pos ( Nat.cast_nonneg _ ) ( Nat.cast_pos.mpr ( hv_pos _ ) )

/-
If a sequence frequently visits values below a and above b, and its downward steps tend to 0, it must frequently visit (a, b).
-/
open Filter Topology Set

lemma frequently_mem_Ioo_of_frequently_le_and_frequently_ge {u : ‚Ñï ‚Üí ‚Ñù} {a b : ‚Ñù} (hab : a < b)
    (h_step : Tendsto (fun n ‚Ü¶ max 0 (u n - u (n + 1))) atTop (ùìù 0))
    (h_le : ‚àÉ·∂† n in atTop, u n ‚â§ a)
    (h_ge : ‚àÉ·∂† n in atTop, b ‚â§ u n) :
    ‚àÉ·∂† n in atTop, u n ‚àà Ioo a b := by
  rw [ Filter.frequently_atTop ] at *;
  -- Assume for contradiction that $u_n$ is eventually not in $(a, b)$.
  by_contra h_contra
  obtain ‚ü®N‚ÇÄ, hN‚ÇÄ‚ü© : ‚àÉ N‚ÇÄ, ‚àÄ n ‚â• N‚ÇÄ, u n ‚àâ Set.Ioo a b := by
    aesop;
  -- Since $u_n$ is frequently $\le a$ and frequently $\ge b$, it must cross from $[b, \infty)$ to $(-\infty, a]$ infinitely often.
  have h_cross : ‚àÄ N ‚â• N‚ÇÄ, ‚àÉ n ‚â• N, u n ‚â• b ‚àß ‚àÉ m ‚â• n, u m ‚â§ a := by
    intro N hN; obtain ‚ü® n, hn‚ÇÅ, hn‚ÇÇ ‚ü© := h_ge N; obtain ‚ü® m, hm‚ÇÅ, hm‚ÇÇ ‚ü© := h_le n; use n; aesop;
  -- For such $n$, $u_n - u_{n+1} \ge b - a$.
  have h_diff : ‚àÄ N ‚â• N‚ÇÄ, ‚àÉ n ‚â• N, u n ‚â• b ‚àß u (n + 1) ‚â§ a := by
    intros N hN
    obtain ‚ü®n, hn‚ÇÅ, hn‚ÇÇ, m, hm‚ÇÅ, hm‚ÇÇ‚ü© := h_cross N hN
    induction' hm‚ÇÅ with m hm ih;
    ¬∑ linarith;
    ¬∑ by_cases h_case : u m ‚â§ a;
      ¬∑ exact ih h_case;
      ¬∑ exact ‚ü® m, le_trans hn‚ÇÅ hm, by linarith [ show u m ‚â• b from le_of_not_gt fun h => hN‚ÇÄ m ( le_trans hN ( le_trans hn‚ÇÅ hm ) ) ‚ü® by linarith, h ‚ü© ], hm‚ÇÇ ‚ü©;
  -- But $\max(0, u_n - u_{n+1}) \to 0$ and $b - a > 0$, a contradiction.
  have h_contra : Filter.Tendsto (fun n => max 0 (u n - u (n + 1))) Filter.atTop (ùìù 0) ‚Üí False := by
    rw [ Metric.tendsto_nhds ] ; norm_num;
    exact ‚ü® b - a, sub_pos.mpr hab, fun n => by obtain ‚ü® m, hm‚ÇÅ, hm‚ÇÇ, hm‚ÇÉ ‚ü© := h_diff ( Max.max n N‚ÇÄ ) ( le_max_right _ _ ) ; exact ‚ü® m, le_trans ( le_max_left _ _ ) hm‚ÇÅ, by rw [ abs_of_nonneg ] <;> cases max_cases ( 0 : ‚Ñù ) ( u m - u ( m + 1 ) ) <;> linarith ‚ü© ‚ü©;
  exact h_contra h_step

/-
If the downward steps of a sequence tend to 0, the set of cluster points is connected.
-/
open Filter Topology Set

lemma isPreconnected_clusterPt_of_descent_small {u : ‚Ñï ‚Üí ‚Ñù}
    (h_step : Tendsto (fun n ‚Ü¶ max 0 (u n - u (n + 1))) atTop (ùìù 0)) :
    IsPreconnected {x | MapClusterPt x atTop u} := by
  refine' isPreconnected_iff_ordConnected.mpr _;
  refine' ‚ü® fun x hx y hy z hz => _ ‚ü©;
  -- If $z \notin K$, then there exists a neighborhood $(c-\epsilon, c+\epsilon)$ such that $u_n$ is eventually outside this neighborhood.
  by_contra h_contra
  obtain ‚ü®Œµ, hŒµ‚ü© : ‚àÉ Œµ > 0, ‚àÄ·∂† n in Filter.atTop, u n ‚àâ Set.Ioo (z - Œµ) (z + Œµ) := by
    simp_all +decide [ MapClusterPt ];
    contrapose! h_contra;
    rw [ clusterPt_iff_frequently ];
    intro s hs; rcases Metric.mem_nhds_iff.mp hs with ‚ü® Œµ, Œµpos, hŒµ ‚ü© ; rcases h_contra Œµ Œµpos 0 with ‚ü® N, hN‚ÇÅ, hN‚ÇÇ, hN‚ÇÉ ‚ü© ; exact Filter.frequently_atTop.mpr fun n => by rcases h_contra Œµ Œµpos ( n + N ) with ‚ü® m, hm‚ÇÅ, hm‚ÇÇ, hm‚ÇÉ ‚ü© ; exact ‚ü® m, by linarith, hŒµ <| mem_ball_iff_norm.mpr <| abs_lt.mpr ‚ü® by linarith, by linarith ‚ü© ‚ü© ;
  -- Choose $\epsilon$ small enough such that $x < z-\epsilon$ and $y > z+\epsilon$.
  obtain ‚ü®Œµ', hŒµ'‚ü© : ‚àÉ Œµ' > 0, Œµ' < Œµ ‚àß x < z - Œµ' ‚àß z + Œµ' < y := by
    by_cases hxz : x < z;
    ¬∑ by_cases hyz : y > z;
      ¬∑ exact ‚ü® Min.min ( Œµ / 2 ) ( Min.min ( ( z - x ) / 2 ) ( ( y - z ) / 2 ) ), lt_min ( half_pos hŒµ.1 ) ( lt_min ( half_pos ( sub_pos.mpr hxz ) ) ( half_pos ( sub_pos.mpr hyz ) ) ), min_lt_of_left_lt ( half_lt_self hŒµ.1 ), by linarith [ min_le_left ( Œµ / 2 ) ( Min.min ( ( z - x ) / 2 ) ( ( y - z ) / 2 ) ), min_le_right ( Œµ / 2 ) ( Min.min ( ( z - x ) / 2 ) ( ( y - z ) / 2 ) ), min_le_left ( ( z - x ) / 2 ) ( ( y - z ) / 2 ), min_le_right ( ( z - x ) / 2 ) ( ( y - z ) / 2 ) ], by linarith [ min_le_left ( Œµ / 2 ) ( Min.min ( ( z - x ) / 2 ) ( ( y - z ) / 2 ) ), min_le_right ( Œµ / 2 ) ( Min.min ( ( z - x ) / 2 ) ( ( y - z ) / 2 ) ), min_le_left ( ( z - x ) / 2 ) ( ( y - z ) / 2 ), min_le_right ( ( z - x ) / 2 ) ( ( y - z ) / 2 ) ] ‚ü©;
      ¬∑ cases eq_or_lt_of_le hz.2 <;> aesop;
    ¬∑ cases eq_or_lt_of_le hz.1 <;> aesop;
  -- Since $x \in K$, $u_n$ is frequently in any neighborhood of $x$, so frequently $u_n < z-\epsilon'$.
  have h_frequently_lt : ‚àÉ·∂† n in Filter.atTop, u n < z - Œµ' := by
    simp_all +decide [ MapClusterPt ];
    rw [ clusterPt_iff_frequently ] at hx;
    specialize hx ( Set.Iio ( z - Œµ' ) ) ( Iio_mem_nhds <| by linarith ) ; aesop;
  -- Since $y \in K$, $u_n$ is frequently in any neighborhood of $y$, so frequently $u_n > z+\epsilon'$.
  have h_frequently_gt : ‚àÉ·∂† n in Filter.atTop, u n > z + Œµ' := by
    simp_all +decide [ MapClusterPt ];
    rw [ clusterPt_iff_frequently ] at hy;
    specialize hy ( Set.Ioi ( z + Œµ' ) ) ( Ioi_mem_nhds ( by linarith ) ) ; aesop;
  -- By `frequently_mem_Ioo_of_frequently_le_and_frequently_ge` applied to the interval $(z-\epsilon', z+\epsilon')$, $u_n$ must frequently be in $(z-\epsilon', z+\epsilon')$.
  have h_frequently_in_interval : ‚àÉ·∂† n in Filter.atTop, u n ‚àà Set.Ioo (z - Œµ') (z + Œµ') := by
    apply_rules [ frequently_mem_Ioo_of_frequently_le_and_frequently_ge ];
    ¬∑ linarith;
    ¬∑ exact h_frequently_lt.mono fun n hn => le_of_lt hn;
    ¬∑ exact h_frequently_gt.mono fun n hn => le_of_lt hn;
  exact h_frequently_in_interval <| by filter_upwards [ hŒµ.2 ] with n hn using fun h => hn <| ‚ü® by linarith [ h.1 ], by linarith [ h.2 ] ‚ü© ;

/-
The set of limit points of the sequence v_n / (n + v_n) is a closed interval.
-/
open Filter Topology Set

theorem problem_103 (v : ‚Ñï ‚Üí ‚Ñï) (hv_pos : ‚àÄ n, 0 < v n) (hv_mono : ‚àÄ n, v n ‚â§ v (n + 1)) :
    ‚àÉ (a b : ‚Ñù), a ‚â§ b ‚àß {x : ‚Ñù | MapClusterPt x atTop (u v)} = Icc a b := by
      -- The set of cluster points $S$ is closed, preconnected, bounded, and nonempty.
      have h_closed : IsClosed {x | MapClusterPt x Filter.atTop (u v)} := by
        exact?
      have h_preconnected : IsPreconnected {x | MapClusterPt x Filter.atTop (u v)} := by
        apply_rules [ isPreconnected_clusterPt_of_descent_small ];
        -- By lemma u_diff_le, we know that $u n - u (n + 1) \leq 1 / (n + 1)$.
        have h_diff_le : ‚àÄ n, u v n - u v (n + 1) ‚â§ 1 / (n + 1) := by
          exact?;
        exact squeeze_zero ( fun n => by positivity ) ( fun n => max_le ( by positivity ) ( h_diff_le n ) ) ( tendsto_one_div_add_atTop_nhds_zero_nat )
      have h_bounded : BddBelow {x | MapClusterPt x Filter.atTop (u v)} ‚àß BddAbove {x | MapClusterPt x Filter.atTop (u v)} := by
        have h_bounded : ‚àÄ x, MapClusterPt x Filter.atTop (u v) ‚Üí 0 ‚â§ x ‚àß x ‚â§ 1 := by
          intro x hx;
          rw [ MapClusterPt ] at hx;
          rw [ clusterPt_iff_nonempty ] at hx;
          constructor <;> contrapose! hx;
          ¬∑ exact ‚ü® Set.Iio 0, Iio_mem_nhds hx, Set.Ici 0, Filter.eventually_atTop.mpr ‚ü® 0, fun n hn => by exact Set.mem_Ici.mpr <| div_nonneg ( Nat.cast_nonneg _ ) <| add_nonneg ( Nat.cast_nonneg _ ) <| Nat.cast_nonneg _ ‚ü©, by ext; aesop ‚ü©;
          ¬∑ refine' ‚ü® Set.Ioi 1, Ioi_mem_nhds hx, Set.Iic 1, _, _ ‚ü© <;> norm_num [ Set.ext_iff ];
            exact ‚ü® 0, fun n _ => div_le_one_of_le‚ÇÄ ( by linarith [ hv_pos n ] ) ( by linarith [ hv_pos n ] ) ‚ü©;
        exact ‚ü® ‚ü® 0, fun x hx => h_bounded x hx |>.1 ‚ü©, ‚ü® 1, fun x hx => h_bounded x hx |>.2 ‚ü© ‚ü©
      have h_nonempty : {x | MapClusterPt x Filter.atTop (u v)}.Nonempty := by
        have h_compact : IsCompact (closure (Set.range (u v))) := by
          exact CompactIccSpace.isCompact_Icc.of_isClosed_subset ( isClosed_closure ) ( closure_minimal ( Set.range_subset_iff.mpr fun n => ‚ü® show 0 ‚â§ u v n from div_nonneg ( Nat.cast_nonneg _ ) ( by linarith ), show u v n ‚â§ 1 from div_le_one_of_le‚ÇÄ ( by linarith [ hv_pos n ] ) ( by linarith [ hv_pos n ] ) ‚ü© ) isClosed_Icc );
        have h_cluster : ‚àÉ x ‚àà closure (Set.range (u v)), MapClusterPt x Filter.atTop (u v) := by
          apply_rules [ h_compact.exists_clusterPt ];
          exact Filter.tendsto_principal.2 <| Filter.Eventually.of_forall fun n => subset_closure <| Set.mem_range_self n;
        exact ‚ü® h_cluster.choose, h_cluster.choose_spec.2 ‚ü©;
      refine' ‚ü® ( InfSet.sInf { x | MapClusterPt x Filter.atTop ( u v ) } ), ( SupSet.sSup { x | MapClusterPt x Filter.atTop ( u v ) } ), _, _ ‚ü©;
      ¬∑ exact le_trans ( csInf_le h_bounded.1 h_nonempty.choose_spec ) ( le_csSup h_bounded.2 h_nonempty.choose_spec );
      ¬∑ refine' Set.Subset.antisymm _ _;
        ¬∑ exact fun x hx => ‚ü® ( csInf_le h_bounded.1 hx ), ( le_csSup h_bounded.2 hx ) ‚ü©;
        ¬∑ exact fun x hx => h_preconnected.Icc_subset ( show InfSet.sInf { x | MapClusterPt x Filter.atTop ( u v ) } ‚àà { x | MapClusterPt x Filter.atTop ( u v ) } from ( IsCompact.sInf_mem ( show IsCompact { x | MapClusterPt x Filter.atTop ( u v ) } from by exact CompactIccSpace.isCompact_Icc.of_isClosed_subset h_closed fun x hx => ‚ü® h_bounded.1.choose_spec hx, h_bounded.2.choose_spec hx ‚ü© ) h_nonempty ) ) ( show SupSet.sSup { x | MapClusterPt x Filter.atTop ( u v ) } ‚àà { x | MapClusterPt x Filter.atTop ( u v ) } from ( IsCompact.sSup_mem ( show IsCompact { x | MapClusterPt x Filter.atTop ( u v ) } from by exact CompactIccSpace.isCompact_Icc.of_isClosed_subset h_closed fun x hx => ‚ü® h_bounded.1.choose_spec hx, h_bounded.2.choose_spec hx ‚ü© ) h_nonempty ) ) hx

#check eq_Icc_csInf_csSup_of_connected_bdd_closed

open Filter Topology Set

#check tendsto_of_tendsto_of_tendsto_of_le_of_le
#check squeeze_zero
#check tendsto_one_div_add_atTop_nhds_zero_nat

#print axioms problem_103
#print axioms u_diff_le
#print axioms isPreconnected_clusterPt_of_descent_small
#print axioms eq_Icc_csInf_csSup_of_connected_bdd_closed

/-
The set of limit points of the sequence v_n / (n + v_n) is a closed interval.
-/
open Filter Topology Set

theorem problem_103' (v : ‚Ñï ‚Üí ‚Ñï) (hv_pos : ‚àÄ n, 0 < v n) (hv_mono : ‚àÄ n, v n ‚â§ v (n + 1)) :
    ‚àÉ (a b : ‚Ñù), a ‚â§ b ‚àß {x : ‚Ñù | MapClusterPt x atTop (u v)} = Icc a b := by
      exact?

/-
The set of limit points of the sequence v_n / (n + v_n) is a closed interval.
-/
open Filter Topology Set Bornology

theorem problem_103_final (v : ‚Ñï ‚Üí ‚Ñï) (hv_pos : ‚àÄ n, 0 < v n) (hv_mono : ‚àÄ n, v n ‚â§ v (n + 1)) :
    ‚àÉ (a b : ‚Ñù), a ‚â§ b ‚àß {x : ‚Ñù | MapClusterPt x atTop (u v)} = Icc a b := by
      exact?

/-
The set of limit points of the sequence v_n / (n + v_n) is a closed interval.
-/
open Filter Topology Set Bornology

theorem problem_103_v2 (v : ‚Ñï ‚Üí ‚Ñï) (hv_pos : ‚àÄ n, 0 < v n) (hv_mono : ‚àÄ n, v n ‚â§ v (n + 1)) :
    ‚àÉ (a b : ‚Ñù), a ‚â§ b ‚àß {x : ‚Ñù | MapClusterPt x atTop (u v)} = Icc a b := by
      -- Apply the theorem problem_103' to our sequence u.
      obtain ‚ü®a, b, hab‚ü© : ‚àÉ a b : ‚Ñù, a ‚â§ b ‚àß {x | MapClusterPt x atTop (u v)} = Icc a b := problem_103' v hv_pos hv_mono;
      use a, b

/-
The set of limit points of the sequence v_n / (n + v_n) is a closed interval.
-/
open Filter Topology Set Bornology

theorem problem_103_solved (v : ‚Ñï ‚Üí ‚Ñï) (hv_pos : ‚àÄ n, 0 < v n) (hv_mono : ‚àÄ n, v n ‚â§ v (n + 1)) :
    ‚àÉ (a b : ‚Ñù), a ‚â§ b ‚àß {x : ‚Ñù | MapClusterPt x atTop (u v)} = Icc a b := by
      exact?

/-
The set of limit points of the sequence v_n / (n + v_n) is a closed interval.
-/
open Filter Topology Set Bornology

theorem problem_103_final_v3 (v : ‚Ñï ‚Üí ‚Ñï) (hv_pos : ‚àÄ n, 0 < v n) (hv_mono : ‚àÄ n, v n ‚â§ v (n + 1)) :
    ‚àÉ (a b : ‚Ñù), a ‚â§ b ‚àß {x : ‚Ñù | MapClusterPt x atTop (u v)} = Icc a b := by
      exact?

/-
The set of limit points of the sequence v_n / (n + v_n) is a closed interval.
-/
open Filter Topology Set Bornology

theorem problem_103_final_v4 (v : ‚Ñï ‚Üí ‚Ñï) (hv_pos : ‚àÄ n, 0 < v n) (hv_mono : ‚àÄ n, v n ‚â§ v (n + 1)) :
    ‚àÉ (a b : ‚Ñù), a ‚â§ b ‚àß {x : ‚Ñù | MapClusterPt x atTop (u v)} = Icc a b := by
      exact?

/-
The set of limit points of the sequence v_n / (n + v_n) is a closed interval.
-/
open Filter Topology Set Bornology

theorem problem_103_done (v : ‚Ñï ‚Üí ‚Ñï) (hv_pos : ‚àÄ n, 0 < v n) (hv_mono : ‚àÄ n, v n ‚â§ v (n + 1)) :
    ‚àÉ (a b : ‚Ñù), a ‚â§ b ‚àß {x : ‚Ñù | MapClusterPt x atTop (u v)} = Icc a b := by
      convert problem_103 v hv_pos hv_mono

/-
The set of limit points of the sequence v_n / (n + v_n) is a closed interval.
-/
open Filter Topology Set Bornology

theorem problem_103_correct (v : ‚Ñï ‚Üí ‚Ñï) (hv_pos : ‚àÄ n, 0 < v n) (hv_mono : ‚àÄ n, v n ‚â§ v (n + 1)) :
    ‚àÉ (a b : ‚Ñù), a ‚â§ b ‚àß {x : ‚Ñù | MapClusterPt x atTop (u v)} = Icc a b := by
      exact?

/-
The set of limit points of the sequence v_n / (n + v_n) is a closed interval.
-/
open Filter Topology Set Bornology

theorem problem_103_fixed (v : ‚Ñï ‚Üí ‚Ñï) (hv_pos : ‚àÄ n, 0 < v n) (hv_mono : ‚àÄ n, v n ‚â§ v (n + 1)) :
    ‚àÉ (a b : ‚Ñù), a ‚â§ b ‚àß {x : ‚Ñù | MapClusterPt x atTop (u v)} = Icc a b := by
      exact?

#check csInf_le_csSup

/-
The set of limit points of the sequence v_n / (n + v_n) is a closed interval.
-/
open Filter Topology Set Bornology

theorem problem_103_complete (v : ‚Ñï ‚Üí ‚Ñï) (hv_pos : ‚àÄ n, 0 < v n) (hv_mono : ‚àÄ n, v n ‚â§ v (n + 1)) :
    ‚àÉ (a b : ‚Ñù), a ‚â§ b ‚àß {x : ‚Ñù | MapClusterPt x atTop (u v)} = Icc a b := by
      exact?

/-
The difference between consecutive terms of the sequence u_n is at most 1/(n+1).
-/
open Filter Topology Set

lemma u_diff_le_proven (v : ‚Ñï ‚Üí ‚Ñï) (hv_pos : ‚àÄ n, 0 < v n) (hv_mono : ‚àÄ n, v n ‚â§ v (n + 1)) (n : ‚Ñï) :
    u v n - u v (n + 1) ‚â§ 1 / (n + 1) := by
  -- By simplifying, we can see that the inequality holds.
  apply u_diff_le v hv_pos hv_mono n