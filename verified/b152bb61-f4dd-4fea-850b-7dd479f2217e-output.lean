/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b152bb61-f4dd-4fea-850b-7dd479f2217e

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Real Set Interval MeasureTheory

#check fun (f : ℝ → ℝ) (n : ℕ) => ∀ k : ℕ, k ≤ n → (∫ x in (0:ℝ)..(2 * π), Real.cos (k * x) * f x = 0)

def TrigBasis (n : ℕ) : Set (ℝ → ℝ) :=
  { g | ∃ k ≤ n, g = fun x ↦ Real.cos ((k : ℝ) * x) } ∪
  { g | ∃ k ≤ n, g = fun x ↦ Real.sin ((k : ℝ) * x) }

def IsTrigPoly (n : ℕ) (p : ℝ → ℝ) : Prop :=
  p ∈ Submodule.span ℝ (TrigBasis n)

/-
Any trigonometric polynomial of degree at most n is continuous.
-/
lemma trig_poly_continuous (n : ℕ) (p : ℝ → ℝ) (hp : IsTrigPoly n p) : Continuous p := by
  revert hp;
  refine' Submodule.span_induction _ _ _ _;
  · exact fun x hx => by rcases hx with ( ⟨ k, hk, rfl ⟩ | ⟨ k, hk, rfl ⟩ ) <;> [ exact Real.continuous_cos.comp ( continuous_const.mul continuous_id' ) ; exact Real.continuous_sin.comp ( continuous_const.mul continuous_id' ) ] ;
  · fun_prop;
  · exact fun x y hx hy hx' hy' => hx'.add hy';
  · exact fun a x hx hx' => continuous_const.mul hx'

/-
If $f$ is orthogonal to the trigonometric basis functions up to degree $n$, then it is orthogonal to any trigonometric polynomial of degree at most $n$.
-/
lemma integral_mul_trig_poly_eq_zero (f : ℝ → ℝ) (hf : Continuous f) (n : ℕ)
    (hzero : ∀ k : ℕ, k ≤ n →
        (∫ x in (0:ℝ)..(2 * π), Real.cos ((k : ℝ) * x) * f x = 0) ∧
        (∫ x in (0:ℝ)..(2 * π), Real.sin ((k : ℝ) * x) * f x = 0))
    (p : ℝ → ℝ) (hp : IsTrigPoly n p) :
    ∫ x in (0:ℝ)..(2 * π), p x * f x = 0 := by
  refine' Submodule.span_induction _ _ _ _ hp;
  · unfold TrigBasis; aesop;
  · norm_num;
  · intro x y hx hy hx' hy'; simp_all +decide [ add_mul ] ;
    rw [ intervalIntegral.integral_add ( by exact Continuous.intervalIntegrable ( by exact Continuous.mul ( show Continuous x from by exact trig_poly_continuous n x hx ) hf ) _ _ ) ( by exact Continuous.intervalIntegrable ( by exact Continuous.mul ( show Continuous y from by exact trig_poly_continuous n y hy ) hf ) _ _ ), hx', hy', add_zero ];
  · simp +contextual [ mul_assoc ]

/-
The product of a trigonometric polynomial of degree n and one of degree m is a trigonometric polynomial of degree n+m.
-/
lemma isTrigPoly_mul {n m : ℕ} {p q : ℝ → ℝ} (hp : IsTrigPoly n p) (hq : IsTrigPoly m q) :
    IsTrigPoly (n + m) (p * q) := by
  have h_prod : ∀ p q : ℝ → ℝ, (∃ k : ℕ, k ≤ n ∧ p = fun x => Real.cos (k * x)) ∨ (∃ k : ℕ, k ≤ n ∧ p = fun x => Real.sin (k * x)) → (∃ k : ℕ, k ≤ m ∧ q = fun x => Real.cos (k * x)) ∨ (∃ k : ℕ, k ≤ m ∧ q = fun x => Real.sin (k * x)) → IsTrigPoly (n + m) (p * q) := by
    rintro p q ( ⟨ k, hk, rfl ⟩ | ⟨ k, hk, rfl ⟩ ) ( ⟨ l, hl, rfl ⟩ | ⟨ l, hl, rfl ⟩ );
    · -- Using the product-to-sum formula, we have $\cos(kx)\cos(lx) = \frac{1}{2}(\cos((k+l)x) + \cos((k-l)x))$.
      have h_prod : ∀ x : ℝ, Real.cos (k * x) * Real.cos (l * x) = (1 / 2) * (Real.cos ((k + l) * x) + Real.cos ((k - l) * x)) := by
        intro x; rw [ Real.cos_add_cos ] ; ring;
      -- Since $\cos((k+l)x)$ and $\cos((k-l)x)$ are both in the span of the trigonometric basis functions up to degree $n+m$, their linear combination is also in the span.
      have h_span : (fun x => Real.cos ((k + l) * x)) ∈ Submodule.span ℝ (TrigBasis (n + m)) ∧ (fun x => Real.cos ((k - l) * x)) ∈ Submodule.span ℝ (TrigBasis (n + m)) := by
        constructor;
        · exact Submodule.subset_span <| Or.inl ⟨ k + l, by linarith, by norm_cast ⟩;
        · by_cases hkl : k ≤ l;
          · rw [ show ( fun x => Real.cos ( ( k - l : ℝ ) * x ) ) = fun x => Real.cos ( ( l - k : ℝ ) * x ) by ext; rw [ ← Real.cos_neg ] ; ring ];
            exact Submodule.subset_span <| Or.inl ⟨ l - k, by omega, by ext; simp +decide [ Nat.cast_sub hkl ] ⟩;
          · exact Submodule.subset_span <| Or.inl ⟨ k - l, by omega, by ext; simp +decide [ Nat.cast_sub ( le_of_not_ge hkl ) ] ⟩;
      convert Submodule.smul_mem _ ( 1 / 2 : ℝ ) ( Submodule.add_mem _ h_span.1 h_span.2 ) using 1 ; ext ; aesop;
    · have h_prod : IsTrigPoly (n + m) (fun x => (Real.sin ((k + l) * x) - Real.sin ((k - l) * x)) / 2) := by
        have h_prod : IsTrigPoly (n + m) (fun x => Real.sin ((k + l) * x)) ∧ IsTrigPoly (n + m) (fun x => Real.sin ((k - l) * x)) := by
          constructor;
          · exact Submodule.subset_span <| Or.inr ⟨ k + l, by linarith, by norm_num ⟩;
          · have h_sin_diff : IsTrigPoly (n + m) (fun x => Real.sin ((Int.natAbs (k - l)) * x)) := by
              exact Submodule.subset_span <| Set.mem_union_right _ ⟨ _, by omega, rfl ⟩;
            cases abs_cases ( k - l : ℤ ) <;> simp_all +decide [ sub_mul ];
            convert Submodule.neg_mem _ h_sin_diff using 1 ; ext ; simp +decide [ Real.sin_sub ];
            ring;
        convert Submodule.smul_mem _ ( 1 / 2 : ℝ ) ( Submodule.sub_mem _ h_prod.1 h_prod.2 ) using 1 ; ext ; norm_num ; ring;
      convert h_prod using 2 ; norm_num ; ring;
      rw [ Real.sin_add, Real.sin_sub ] ; ring;
    · -- Using the product-to-sum identities, we can rewrite $\sin(kx)\cos(lx)$ as $\frac{1}{2}[\sin((k+l)x) + \sin((k-l)x)]$.
      have h_prod_to_sum : ∀ x : ℝ, Real.sin (k * x) * Real.cos (l * x) = (1 / 2) * (Real.sin ((k + l) * x) + Real.sin ((k - l) * x)) := by
        intro x; rw [ add_mul, sub_mul ] ; rw [ Real.sin_add, Real.sin_sub ] ; ring;
      -- Since $\sin((k+l)x)$ and $\sin((k-l)x)$ are both in the span of the trigonometric basis functions up to degree $n+m$, their sum is also in the span.
      have h_sum : (fun x => Real.sin ((k + l) * x)) ∈ Submodule.span ℝ (TrigBasis (n + m)) ∧ (fun x => Real.sin ((k - l) * x)) ∈ Submodule.span ℝ (TrigBasis (n + m)) := by
        constructor;
        · exact Submodule.subset_span <| Or.inr ⟨ k + l, by linarith, by norm_cast ⟩;
        · by_cases h : k ≥ l;
          · exact Submodule.subset_span <| Set.mem_union_right _ ⟨ k - l, by omega, by simp +decide [ h ] ⟩;
          · rw [ show ( fun x => Real.sin ( ( k - l : ℝ ) * x ) ) = fun x => -Real.sin ( ( l - k : ℝ ) * x ) by ext; rw [ ← Real.sin_neg ] ; ring ];
            exact Submodule.neg_mem _ ( Submodule.subset_span <| Or.inr ⟨ l - k, by omega, by ext; simp +decide [ Nat.cast_sub ( show k ≤ l by linarith ) ] ⟩ );
      convert Submodule.smul_mem _ ( 1 / 2 : ℝ ) ( Submodule.add_mem _ h_sum.1 h_sum.2 ) using 1 ; ext ; aesop;
    · -- Using the product-to-sum formula, we have $\sin(kx)\sin(lx) = \frac{1}{2}[\cos((k-l)x) - \cos((k+l)x)]$.
      have h_prod_to_sum : ∀ x : ℝ, Real.sin (k * x) * Real.sin (l * x) = (1 / 2) * (Real.cos ((k - l) * x) - Real.cos ((k + l) * x)) := by
        intro x; rw [ Real.cos_sub_cos ] ; ring ; norm_num;
      -- Since $\cos((k-l)x)$ and $\cos((k+l)x)$ are trigonometric polynomials of degree at most $n+m$, their linear combination is also a trigonometric polynomial of degree at most $n+m$.
      have h_cos_poly : IsTrigPoly (n + m) (fun x => Real.cos ((k - l) * x)) ∧ IsTrigPoly (n + m) (fun x => Real.cos ((k + l) * x)) := by
        constructor <;> refine' Submodule.subset_span _;
        · refine' Or.inl ⟨ Int.natAbs ( k - l ), _, _ ⟩ <;> norm_num;
          · omega;
          · cases abs_cases ( ( k : ℝ ) - l ) <;> simp +decide [ * ];
            exact funext fun x => by rw [ ← Real.cos_neg ] ; ring;
        · exact Or.inl ⟨ k + l, by linarith, by norm_cast ⟩;
      convert Submodule.smul_mem _ ( 1 / 2 : ℝ ) ( Submodule.sub_mem _ h_cos_poly.1 h_cos_poly.2 ) using 1 ; aesop;
  have h_span : ∀ (p : ℝ → ℝ), p ∈ Submodule.span ℝ (TrigBasis n) → ∀ (q : ℝ → ℝ), q ∈ Submodule.span ℝ (TrigBasis m) → IsTrigPoly (n + m) (p * q) := by
    intro p hp q hq;
    induction hp using Submodule.span_induction;
    · induction hq using Submodule.span_induction;
      · unfold TrigBasis at *; aesop;
      · exact by rw [ show ( _:ℝ → ℝ ) * 0 = 0 by ext; norm_num ] ; exact Submodule.zero_mem _;
      · simp_all +decide [ mul_add ];
        exact Submodule.add_mem _ ‹_› ‹_›;
      · rename_i a ha;
        simp_all +decide [ mul_assoc, mul_left_comm, Submodule.smul_mem_iff ];
        exact Submodule.smul_mem _ _ ha;
    · simp [IsTrigPoly];
    · simp_all +decide [ add_mul ];
      exact Submodule.add_mem _ ‹_› ‹_›;
    · simp_all +decide [ mul_assoc, Submodule.smul_mem_iff ];
      exact Submodule.smul_mem _ _ ‹_›;
  exact h_span p hp q hq

/-
Any constant function is a trigonometric polynomial of degree 0.
-/
lemma isTrigPoly_const (c : ℝ) : IsTrigPoly 0 (fun _ => c) := by
  -- The constant function $c$ is in the span of the trigonometric basis functions of degree 0 because it can be written as $c \cdot \cos(0 \cdot x)$.
  simp [IsTrigPoly, TrigBasis];
  exact Submodule.mem_span_pair.mpr ⟨ 0, c, by ext; norm_num ⟩

/-
If a function is a trigonometric polynomial of degree at most n, it is also a trigonometric polynomial of degree at most m for any m ≥ n.
-/
lemma isTrigPoly_mono {n m : ℕ} (h : n ≤ m) {p : ℝ → ℝ} (hp : IsTrigPoly n p) : IsTrigPoly m p := by
  -- Since $n \leq m$, the trigonometric basis functions up to degree $n$ are also included in the trigonometric basis functions up to degree $m$.
  have h_basis_subset : TrigBasis n ⊆ TrigBasis m := by
    exact fun x hx => by rcases hx with ( ⟨ k, hk, rfl ⟩ | ⟨ k, hk, rfl ⟩ ) <;> [ exact Or.inl ⟨ k, by linarith, rfl ⟩ ; exact Or.inr ⟨ k, by linarith, rfl ⟩ ] ;
  exact Submodule.span_mono h_basis_subset hp

/-
The product of $\sin((x-t_1)/2)$ and $\sin((x-t_2)/2)$ is a trigonometric polynomial of degree 1.
-/
lemma signChangePoly_two_terms (t1 t2 : ℝ) :
    IsTrigPoly 1 (fun x => Real.sin ((x - t1) / 2) * Real.sin ((x - t2) / 2)) := by
  -- Use the identity $\sin(A)\sin(B) = \frac{1}{2}(\cos(A-B) - \cos(A+B))$.
  have h_identity : ∀ x, Real.sin ((x - t1) / 2) * Real.sin ((x - t2) / 2) = (1 / 2) * (Real.cos ((t2 - t1) / 2) - Real.cos (x - (t1 + t2) / 2)) := by
    intro x; rw [ Real.cos_sub_cos ] ; ring ; norm_num;
    norm_num [ Real.sin_add, Real.sin_sub ] ; ring;
  simp_all +decide [ IsTrigPoly ];
  refine' Submodule.mem_span.mpr _;
  intro p hp
  have h_cos : (fun x => Real.cos (x - (t1 + t2) / 2)) ∈ p := by
    have h_cos : (fun x => Real.cos x * Real.cos ((t1 + t2) / 2) + Real.sin x * Real.sin ((t1 + t2) / 2)) ∈ p := by
      have h_cos : (fun x => Real.cos x) ∈ p := by
        exact hp <| Or.inl ⟨ 1, by norm_num, by norm_num ⟩
      have h_sin : (fun x => Real.sin x) ∈ p := by
        exact hp <| Set.mem_union_right _ ⟨ 1, by norm_num, by norm_num ⟩;
      convert p.add_mem ( p.smul_mem ( Real.cos ( ( t1 + t2 ) / 2 ) ) h_cos ) ( p.smul_mem ( Real.sin ( ( t1 + t2 ) / 2 ) ) h_sin ) using 1 ; ext ; simp +decide [ mul_comm ];
    simpa only [ Real.cos_sub ] using h_cos;
  have h_const : (fun x => Real.cos ((t2 - t1) / 2)) ∈ p := by
    convert p.smul_mem ( Real.cos ( ( t2 - t1 ) / 2 ) ) ( hp <| Or.inl ⟨ 0, by norm_num, rfl ⟩ ) using 1 ; norm_num;
    exact funext fun x => by simp +decide ;
  convert p.smul_mem ( 2⁻¹ : ℝ ) ( p.sub_mem h_const h_cos ) using 1

/-
Recurrence relation for signChangePoly: peeling off two elements.
-/
def signChangePoly (l : List ℝ) (x : ℝ) : ℝ :=
  (l.map (fun t => Real.sin ((x - t) / 2))).prod

lemma signChangePoly_cons_cons (a b : ℝ) (l : List ℝ) :
    signChangePoly (a :: b :: l) = fun x => (Real.sin ((x - a) / 2) * Real.sin ((x - b) / 2)) * signChangePoly l x := by
  funext x; simp [signChangePoly];
  ring

/-
If a list has even length, the associated sign change polynomial is a trigonometric polynomial of degree half the length.
-/
lemma signChangePoly_isTrigPoly (l : List ℝ) (hl : Even l.length) :
    IsTrigPoly (l.length / 2) (signChangePoly l) := by
  -- By induction on $k$, we can show that the product of the first $2k$ terms is a trigonometric polynomial of degree $k$.
  have h_ind : ∀ k : ℕ, ∀ l : List ℝ, l.length = 2 * k → IsTrigPoly k (signChangePoly l) := by
    intro k l hl; induction' k with k ih generalizing l <;> simp_all +decide [ Nat.mul_succ ] ;
    · exact isTrigPoly_const 1;
    · rcases l with ( _ | ⟨ a, _ | ⟨ b, l ⟩ ⟩ ) <;> simp_all +arith +decide;
      convert isTrigPoly_mul ( signChangePoly_two_terms a b ) ( ih l hl ) using 1;
      · ring;
      · exact funext fun x => by simp +decide [ signChangePoly ] ; ring;
  grind

/-
If the list has even length, the sign change polynomial is 2π-periodic.
-/
lemma signChangePoly_periodic (l : List ℝ) (hl : Even l.length) :
    ∀ x, signChangePoly l (x + 2 * π) = signChangePoly l x := by
  -- By definition of signChangePoly, we can write it as a product of sine terms.
  have h_prod : ∀ x : ℝ, signChangePoly l x = List.prod (List.map (fun t => Real.sin ((x - t) / 2)) l) := by
    exact?;
  -- By definition of sine, we know that $\sin(\theta + \pi) = -\sin(\theta)$.
  have h_sin_periodic : ∀ x t : ℝ, Real.sin ((x + 2 * Real.pi - t) / 2) = -Real.sin ((x - t) / 2) := by
    exact fun x t => by rw [ ← Real.sin_add_pi ] ; ring;
  simp_all +decide [ List.map_map, mul_comm ];
  intro x; rw [ List.map_congr_left fun t ht => neg_eq_neg_one_mul _, List.prod_map_mul ] ; aesop;

def HasSignChanges (f : ℝ → ℝ) (a b : ℝ) (k : ℕ) : Prop :=
  ∃ l : List ℝ, l.length = k + 1 ∧ l.Sorted (· < ·) ∧ (∀ x ∈ l, a < x ∧ x < b) ∧
    l.Chain' (fun x y ↦ f x * f y < 0)

/-
If the number of sign changes is bounded, there exists a chain of maximal length.
-/
lemma exists_maximal_chain (f : ℝ → ℝ) (a b : ℝ) (k : ℕ) (h : ¬ HasSignChanges f a b k) :
    ∃ l : List ℝ, l.Sorted (· < ·) ∧ (∀ x ∈ l, a < x ∧ x < b) ∧
    l.Chain' (fun x y ↦ f x * f y < 0) ∧
    ∀ l' : List ℝ, l'.Sorted (· < ·) → (∀ x ∈ l', a < x ∧ x < b) →
    l'.Chain' (fun x y ↦ f x * f y < 0) → l'.length ≤ l.length := by
  -- By definition of negation, if $\neg HasSignChanges f a b k$, then for any chain of sign changes of length $k$, there exists a longer chain.
  obtain ⟨m, hm⟩ : ∃ m, ∀ l : List ℝ, List.Sorted (· < ·) l → (∀ x ∈ l, a < x ∧ x < b) → List.Chain' (fun x y => f x * f y < 0) l → l.length ≤ m := by
    use 2 * k + 2;
    intro l hl1 hl2 hl3; contrapose! h;
    -- Since $l$ has length greater than $2k + 2$, we can extract a subsequence of length $k + 1$ from it.
    obtain ⟨l', hl'_subseq, hl'_length⟩ : ∃ l' : List ℝ, l' ⊆ l ∧ l'.length = k + 1 ∧ l'.Sorted (· < ·) ∧ (∀ x ∈ l', a < x ∧ x < b) ∧ l'.Chain' (fun x y => f x * f y < 0) := by
      refine' ⟨ l.take ( k + 1 ), _, _, _, _, _ ⟩ <;> norm_num;
      · exact List.take_subset _ _;
      · linarith;
      · exact hl1.sublist ( List.take_sublist _ _ );
      · exact fun x hx => hl2 x <| List.mem_of_mem_take hx;
      · exact List.IsChain.take ( hl3 ) _;
    exact ⟨ l', hl'_length.1, hl'_length.2.1, hl'_length.2.2.1, hl'_length.2.2.2 ⟩;
  -- By the definition of bounded sets, such a maximum length $m$ exists.
  obtain ⟨m, hm⟩ : ∃ m, m ∈ {l_len : ℕ | ∃ l : List ℝ, l_len = l.length ∧ l.Sorted (· < ·) ∧ (∀ x ∈ l, a < x ∧ x < b) ∧ l.Chain' (fun x y => f x * f y < 0)} ∧ ∀ l_len ∈ {l_len : ℕ | ∃ l : List ℝ, l_len = l.length ∧ l.Sorted (· < ·) ∧ (∀ x ∈ l, a < x ∧ x < b) ∧ l.Chain' (fun x y => f x * f y < 0)}, l_len ≤ m := by
    apply_rules [ Set.exists_max_image ];
    · exact Set.finite_iff_bddAbove.mpr ⟨ m, by rintro x ⟨ l, rfl, hl₁, hl₂, hl₃ ⟩ ; exact hm l hl₁ hl₂ hl₃ ⟩;
    · exact ⟨ _, ⟨ [ ], rfl, List.sorted_nil, by norm_num, List.isChain_nil ⟩ ⟩;
  rcases hm.1 with ⟨ l, rfl, hl₁, hl₂, hl₃ ⟩ ; exact ⟨ l, hl₁, hl₂, hl₃, fun l' hl₁' hl₂' hl₃' => hm.2 _ ⟨ l', rfl, hl₁', hl₂', hl₃' ⟩ ⟩ ;

/-
Given a sorted chain of points where a continuous function alternates sign, there exists a list of roots interlacing the chain.
-/
def Interlaces : List ℝ → List ℝ → Prop
| [], [] => True
| [_], [] => True
| x :: y :: l, z :: t => x < z ∧ z < y ∧ Interlaces (y :: l) t
| _, _ => False

lemma exists_roots_of_chain (f : ℝ → ℝ) (hf : Continuous f) (l : List ℝ)
    (hl_chain : l.Chain' (fun x y ↦ f x * f y < 0)) (hl_sorted : l.Sorted (· < ·)) :
    ∃ t : List ℝ, Interlaces l t ∧ ∀ x ∈ t, f x = 0 := by
  induction l <;> simp_all +decide [ List.isChain_singleton ];
  · exact ⟨ [ ], by tauto ⟩;
  · rename_i k hk ih;
    rcases hk with ( _ | ⟨ x, _ | ⟨ y, hk ⟩ ⟩ ) <;> simp_all +decide [ List.chain'_cons' ];
    · exact ⟨ [ ], by tauto ⟩;
    · -- By the Intermediate Value Theorem, since $f(k) * f(x) < 0$, there exists some $c \in (k, x)$ such that $f(c) = 0$.
      obtain ⟨c, hc⟩ : ∃ c ∈ Set.Ioo k x, f c = 0 := by
        have h_ivt : ContinuousOn f (Set.Icc k x) := by
          exact hf.continuousOn;
        have := hl_chain; simp_all +decide [ List.isChain_singleton ] ;
        have h_ivt : ∃ c ∈ Set.Ioo k x, f c = 0 := by
          have h_sign : f k * f x < 0 := by
            exact List.isChain_cons_cons.mp this |>.1
          rw [ mul_neg_iff ] at h_sign;
          cases' h_sign with h_sign h_sign <;> [ exact intermediate_value_Ioo' hl_sorted.le h_ivt ( by aesop ) ; exact intermediate_value_Ioo hl_sorted.le h_ivt ( by aesop ) ];
        exact h_ivt;
      norm_num +zetaDelta at *;
      use [c]; simp [hc];
      constructor ; aesop;
      exact ⟨ hc.1.2, by tauto ⟩;
    · -- By the Intermediate Value Theorem, since $f(k) * f(x) < 0$, there exists $z \in (k, x)$ such that $f(z) = 0$.
      obtain ⟨z, hz⟩ : ∃ z ∈ Set.Ioo k x, f z = 0 := by
        have h_ivt : f k * f x < 0 := by
          cases hl_chain ; aesop;
        have h_ivt : ContinuousOn f (Set.Icc k x) := by
          exact hf.continuousOn;
        have := h_ivt.image_Icc ( by linarith : k ≤ x );
        exact this.symm.subset ( Set.mem_Icc.mpr ⟨ by nlinarith [ Set.mem_Icc.mp ( this ▸ Set.mem_image_of_mem f ( Set.left_mem_Icc.mpr ( by linarith ) ) ), Set.mem_Icc.mp ( this ▸ Set.mem_image_of_mem f ( Set.right_mem_Icc.mpr ( by linarith ) ) ) ], by nlinarith [ Set.mem_Icc.mp ( this ▸ Set.mem_image_of_mem f ( Set.left_mem_Icc.mpr ( by linarith ) ) ), Set.mem_Icc.mp ( this ▸ Set.mem_image_of_mem f ( Set.right_mem_Icc.mpr ( by linarith ) ) ) ] ⟩ ) |> fun ⟨ z, hz₁, hz₂ ⟩ => ⟨ z, ⟨ lt_of_le_of_ne hz₁.1 ( by aesop_cat ), lt_of_le_of_ne hz₁.2 ( by aesop_cat ) ⟩, hz₂ ⟩;
      obtain ⟨ t, ht₁, ht₂ ⟩ := ih ( by exact List.chain'_cons'.mp hl_chain |>.2 );
      use z :: t;
      constructor;
      · constructor <;> aesop;
      · aesop

/-
If the list has odd length, the sign change polynomial is 2π-antiperiodic.
-/
lemma signChangePoly_antiperiodic (l : List ℝ) (hl : Odd l.length) :
    ∀ x, signChangePoly l (x + 2 * π) = -signChangePoly l x := by
  -- Since the length of the list is odd, each sine term in the product will change its sign when we add $2\pi$ to $x$. Therefore, the product of an odd number of such terms will result in a negative sign.
  intros x
  simp [signChangePoly];
  -- By periodicity and symmetry of the sine function, we know that $\sin((x + 2\pi - t)/2) = -\sin((x - t)/2)$ for any $t$.
  have h_sin_periodic : ∀ t : ℝ, Real.sin ((x + 2 * Real.pi - t) / 2) = -Real.sin ((x - t) / 2) := by
    intro t; rw [ ← Real.sin_sub_pi ] ; ring;
    norm_num [ Real.sin_add, Real.sin_sub ];
  norm_num [ h_sin_periodic ];
  rw [ List.map_congr_left fun t ht => neg_eq_neg_one_mul _, List.prod_map_mul ] ; aesop

/-
If $f(a)$ and $f(x_1)$ have opposite signs, we can find a point $z$ between $a$ and $x_1$ such that $f(z)$ and $f(x_1)$ have opposite signs.
-/
lemma extend_chain_left (f : ℝ → ℝ) (hf : Continuous f) (a x1 : ℝ) (h_ax : a < x1)
    (h_sign : f a * f x1 < 0) :
    ∃ z, a < z ∧ z < x1 ∧ f z * f x1 < 0 := by
  have h_exists_z : ∃ ε > 0, ∀ z, abs (z - a) < ε → f z * f x1 < 0 := by
    exact Metric.mem_nhds_iff.mp ( hf.continuousAt.mul continuousAt_const |> fun h => h.eventually ( gt_mem_nhds h_sign ) );
  obtain ⟨ ε, ε_pos, hε ⟩ := h_exists_z; exact ⟨ a + Min.min ( x1 - a ) ε / 2, by linarith [ lt_min ( sub_pos.mpr h_ax ) ε_pos ], by linarith [ min_le_left ( x1 - a ) ε, min_le_right ( x1 - a ) ε ], hε _ <| by rw [ abs_of_pos ] <;> linarith [ lt_min ( sub_pos.mpr h_ax ) ε_pos, min_le_left ( x1 - a ) ε, min_le_right ( x1 - a ) ε ] ⟩ ;

/-
If $f(x_k)$ and $f(b)$ have opposite signs, we can find a point $z$ between $x_k$ and $b$ such that $f(x_k)$ and $f(z)$ have opposite signs.
-/
lemma extend_chain_right (f : ℝ → ℝ) (hf : Continuous f) (xk b : ℝ) (h_xb : xk < b)
    (h_sign : f xk * f b < 0) :
    ∃ z, xk < z ∧ z < b ∧ f xk * f z < 0 := by
  -- By the Intermediate Value Theorem, since $f$ is continuous and $f(x_k)$ and $f(b)$ have opposite signs, there exists some $c \in (x_k, b)$ such that $f(c) = 0$.
  have h_ivt : ∀ᶠ y in nhdsWithin b (Set.Iio b), f xk * f y < 0 := by
    exact hf.continuousWithinAt.const_mul _ |> fun h => h.eventually ( gt_mem_nhds h_sign );
  rcases ( h_ivt.and ( Ioo_mem_nhdsLT h_xb ) ) with h ; obtain ⟨ z, hz₁, hz₂ ⟩ := h.exists ; exact ⟨ z, hz₂.1, hz₂.2, hz₁ ⟩

/-
If a chain of sign changes has even length, the first and last elements have opposite signs.
-/
lemma chain_even_length_opposite_signs (f : ℝ → ℝ) (l : List ℝ)
    (hl_chain : l.Chain' (fun x y ↦ f x * f y < 0))
    (hl_even : Even l.length) (hl_pos : l.length > 0) :
    f (l.head!) * f (l.getLast!) < 0 := by
  -- By induction on the length of l₁, we can show that f l₁.head! * f l₁.getLast! < 0 if l₁.length is odd, and f l₁.head! * f l₁.getLast! > 0 if l₁.length is even.
  have h_ind : ∀ (l : List ℝ), List.Chain' (fun x y => f x * f y < 0) l → ∀ i j : ℕ, i < j → i < l.length → j < l.length → (j - i) % 2 = 1 → f (l.get! i) * f (l.get! j) < 0 := by
    intros l hl_chain i j hij hi hj h_odd
    induction' h : j - i using Nat.strong_induction_on with d ih generalizing i j;
    rcases hij with ( _ | _ | hij ) <;> simp_all +decide [ Nat.add_mod ];
    · have := List.isChain_iff_get.mp hl_chain; aesop;
    · omega;
    · have h_ind_step : f l[i] * f l[i + 1] < 0 ∧ f l[i + 1] * f l[i + 2] < 0 := by
        have := List.isChain_iff_get.mp hl_chain;
        exact ⟨ this i ( by linarith ), this ( i + 1 ) ( by linarith ) ⟩;
      specialize ih ( ‹_› + 1 + 1 - i - 2 ) ?_ ( i + 2 ) ( ‹_› + 1 + 1 ) ?_ ?_ ?_ ?_ <;> norm_num at *;
      any_goals omega;
      specialize ih ( by omega );
      cases lt_or_ge 0 ( f l[i] ) <;> cases lt_or_ge 0 ( f l[i + 1] ) <;> cases lt_or_ge 0 ( f l[i + 2] ) <;> nlinarith;
  convert h_ind l hl_chain 0 ( l.length - 1 ) _ _ _ _ using 1 <;> norm_num [ hl_pos ];
  · rcases l <;> simp +decide [ List.getLast? ];
    · contradiction;
    · exact Or.inl ( by rw [ List.getLast_eq_getElem ] ; simp +decide );
  · grind;
  · exact Nat.odd_iff.mp ( by rw [ Nat.odd_iff ] ; obtain ⟨ k, hk ⟩ := hl_even; omega )