/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 50d3f914-475d-4c97-98ac-ba52b2b2b1f7

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Filter Topology Set Real

/-
Definition of the counting function N(r) and a lemma stating that the set of indices n such that r_n n ‚â§ r is finite if r_n tends to infinity.
-/
noncomputable def N (r_n : ‚Ñï ‚Üí ‚Ñù) (r : ‚Ñù) : ‚Ñï := Set.ncard {n | r_n n ‚â§ r}

lemma finite_le_of_tendsto {r_n : ‚Ñï ‚Üí ‚Ñù} (h_tendsto : Tendsto r_n atTop atTop) (r : ‚Ñù) :
  Set.Finite {n | r_n n ‚â§ r} := by
    exact Set.finite_iff_bddAbove.2 ( Filter.eventually_atTop.1 ( h_tendsto.eventually_gt_atTop r ) |> fun ‚ü® n, hn ‚ü© => ‚ü® n, fun m hm => le_of_not_gt fun hnm => not_le_of_gt ( hn m hnm.le ) hm ‚ü© )

#check intervalIntegral

/-
Definition of the sum S(r) = Œ£ (r_n/r)^(Œ±-Œª) for r_n ‚â§ r.
-/
noncomputable def S (r_n : ‚Ñï ‚Üí ‚Ñù) (h_tendsto : Tendsto r_n atTop atTop) (Œ± lam r : ‚Ñù) : ‚Ñù :=
  ‚àë n ‚àà (finite_le_of_tendsto h_tendsto r).toFinset, ((r_n n) / r) ^ (Œ± - lam)

#check ‚à´ x in (0:‚Ñù)..(1:‚Ñù), x

/-
Part 2 of Problem 157: The integral of x^((Œ±-Œª)/Œª) from 0 to 1 is Œª/Œ±.
-/
theorem problem_157_part2 (Œ± lam : ‚Ñù) (hŒ±_pos : 0 < Œ±) (hlam_pos : 0 < lam) :
  ‚à´ x in (0:‚Ñù)..1, x ^ ((Œ± - lam) / lam) = lam / Œ± := by
  rw [ integral_rpow ] <;> norm_num;
  ¬∑ rw [ Real.zero_rpow ] <;> norm_num [ hŒ±_pos.ne', hlam_pos.ne' ];
    ¬∑ rw [ inv_eq_one_div, div_add_one, div_div_eq_mul_div ] <;> ring ; positivity;
    ¬∑ rw [ div_add_one, div_eq_iff ] <;> linarith;
  ¬∑ rw [ lt_div_iff‚ÇÄ ] <;> linarith

/-
The limit of (N(br) - N(ar))/N(r) is b^Œª - a^Œª.
-/
lemma interval_limit {r_n : ‚Ñï ‚Üí ‚Ñù} (lam : ‚Ñù) (h_regular : ‚àÄ (c : ‚Ñù) (hc : 0 < c),
    Tendsto (fun (r : ‚Ñù) => (N r_n (c * r) : ‚Ñù) / (N r_n r : ‚Ñù)) atTop (ùìù (c ^ lam)))
  (a b : ‚Ñù) (ha : 0 < a) (hb : a < b) :
  Tendsto (fun r => ((N r_n (b * r) : ‚Ñù) - N r_n (a * r)) / N r_n r) atTop (ùìù (b ^ lam - a ^ lam)) := by
    simpa only [ sub_div ] using Filter.Tendsto.sub ( h_regular b ( by linarith ) ) ( h_regular a ( by linarith ) )

/-
The limit of the sum for the indicator function of an interval (u, v] is v^Œª - u^Œª.
-/
lemma limit_sum_indicator {r_n : ‚Ñï ‚Üí ‚Ñù} (h_tendsto : Tendsto r_n atTop atTop)
  (lam : ‚Ñù) (hlam_pos : 0 < lam)
  (h_regular : ‚àÄ (c : ‚Ñù) (hc : 0 < c),
    Tendsto (fun (r : ‚Ñù) => (N r_n (c * r) : ‚Ñù) / (N r_n r : ‚Ñù)) atTop (ùìù (c ^ lam)))
  (a b u v : ‚Ñù) (ha : 0 < a) (hb : a < b) (hu : a ‚â§ u) (huv : u < v) (hv : v ‚â§ b) :
  Tendsto (fun (r : ‚Ñù) =>
    (‚àë n ‚àà (finite_le_of_tendsto h_tendsto (b * r)).toFinset.filter (fun n => a * r < r_n n),
      Set.indicator (Set.Ioc u v) (fun _ => (1:‚Ñù)) ((r_n n) / r)) / (N r_n r : ‚Ñù))
    atTop (ùìù (v ^ lam - u ^ lam)) := by
  refine' Filter.Tendsto.congr' _ ( interval_limit lam h_regular u v ( by linarith ) ( by linarith ) );
  filter_upwards [ Filter.eventually_gt_atTop 0 ] with r hr;
  simp +decide [ Set.indicator, N ];
  rw [ show { n : ‚Ñï | r_n n ‚â§ v * r } = { n : ‚Ñï | r_n n ‚â§ u * r } ‚à™ { n : ‚Ñï | u * r < r_n n ‚àß r_n n ‚â§ v * r } from ?_, @Set.ncard_union_eq ];
  ¬∑ simp +decide [ Set.ncard_def, Set.encard, hr.ne' ];
    rw [ ‚Üê Set.ncard_coe_finset ] ; congr ; ext ; simp +decide [ hr.ne', le_div_iff‚ÇÄ hr, div_le_iff‚ÇÄ hr ] ;
    exact ‚ü® fun h => ‚ü® ‚ü® by nlinarith, by nlinarith ‚ü©, by rw [ lt_div_iff‚ÇÄ hr ] ; linarith, h.2 ‚ü©, fun h => ‚ü® by nlinarith [ mul_div_cancel‚ÇÄ ( r_n ‚Äπ_‚Ä∫ ) hr.ne' ], h.2.2 ‚ü© ‚ü©;
  ¬∑ exact Set.disjoint_left.mpr fun x hx‚ÇÅ hx‚ÇÇ => hx‚ÇÅ.out.not_lt hx‚ÇÇ.1;
  ¬∑ exact Set.finite_iff_bddAbove.mpr ( Filter.eventually_atTop.mp ( h_tendsto.eventually_gt_atTop ( u * r ) ) |> fun ‚ü® n, hn ‚ü© => ‚ü® n, fun m hm => not_lt.mp fun contra => not_le_of_gt ( hn m contra.le ) hm ‚ü© );
  ¬∑ exact Set.finite_iff_bddAbove.mpr ( by rcases Filter.eventually_atTop.mp ( h_tendsto.eventually_gt_atTop ( v * r ) ) with ‚ü® n, hn ‚ü© ; exact ‚ü® n, fun m hm => not_lt.mp fun contra => not_lt_of_ge hm.2 <| hn m contra.le ‚ü© );
  ¬∑ field_simp;
    exact Set.ext fun x => ‚ü® fun hx => if h : r_n x ‚â§ r * u then Or.inl h else Or.inr ‚ü® not_le.mp h, hx ‚ü©, fun hx => hx.elim ( fun hx => hx.out.trans ( by nlinarith ) ) fun hx => hx.2 ‚ü©

/-
Definition of the Riemann-like sum.
-/
noncomputable def RiemannSum (r_n : ‚Ñï ‚Üí ‚Ñù) (h_tendsto : Tendsto r_n atTop atTop) (r : ‚Ñù) (a b : ‚Ñù) (f : ‚Ñù ‚Üí ‚Ñù) : ‚Ñù :=
  (‚àë n ‚àà (finite_le_of_tendsto h_tendsto (b * r)).toFinset.filter (fun n => a * r < r_n n), 
      f ((r_n n) / r)) / (N r_n r : ‚Ñù)

/-
The number of terms in the Riemann sum is N(br) - N(ar).
-/
lemma card_indices_eq {r_n : ‚Ñï ‚Üí ‚Ñù} (h_tendsto : Tendsto r_n atTop atTop)
  (r : ‚Ñù) (a b : ‚Ñù) (h_r : 0 < r) (h_ab : a < b) :
  ((finite_le_of_tendsto h_tendsto (b * r)).toFinset.filter (fun n => a * r < r_n n)).card =
  N r_n (b * r) - N r_n (a * r) := by
  unfold N;
  rw [ ‚Üê Set.ncard_diff _ _ ];
  ¬∑ rw [ ‚Üê Set.ncard_coe_finset ] ; congr ; ext ; aesop;
  ¬∑ exact fun n hn => le_trans hn.out ( mul_le_mul_of_nonneg_right h_ab.le h_r.le );
  ¬∑ exact?

/-
Helper lemma: indices in the Riemann sum correspond to points in (a, b].
-/
lemma mem_Ioc_of_mem_filter {r_n : ‚Ñï ‚Üí ‚Ñù} (h_tendsto : Tendsto r_n atTop atTop)
  (r : ‚Ñù) (a b : ‚Ñù) (hr : 0 < r) (n : ‚Ñï)
  (hn : n ‚àà (finite_le_of_tendsto h_tendsto (b * r)).toFinset.filter (fun n => a * r < r_n n)) :
  (r_n n) / r ‚àà Set.Ioc a b := by
  exact ‚ü® by rw [ lt_div_iff‚ÇÄ hr ] ; aesop, by rw [ div_le_iff‚ÇÄ hr ] ; aesop ‚ü©

/-
If f and g are Œµ-close on (a, b], their Riemann sums are close.
-/
lemma RiemannSum_bound {r_n : ‚Ñï ‚Üí ‚Ñù} (h_tendsto : Tendsto r_n atTop atTop)
  (r : ‚Ñù) (a b : ‚Ñù) (hr : 0 < r) (hab : a < b) (f g : ‚Ñù ‚Üí ‚Ñù) (Œµ : ‚Ñù)
  (h_bound : ‚àÄ x ‚àà Set.Ioc a b, |f x - g x| ‚â§ Œµ) :
  |RiemannSum r_n h_tendsto r a b f - RiemannSum r_n h_tendsto r a b g| ‚â§
  Œµ * ((N r_n (b * r) : ‚Ñù) - N r_n (a * r)) / (N r_n r : ‚Ñù) := by
  -- The absolute value of the difference of the Riemann sums is the absolute value of the sum of (f(x) - g(x)) over the interval times N(r).
  have h_abs_diff_sum : |(‚àë n ‚àà ((finite_le_of_tendsto h_tendsto (b * r)).toFinset.filter (fun n => a * r < r_n n)), (f ((r_n n) / r) - g ((r_n n) / r))) / (N r_n r : ‚Ñù)| ‚â§ (‚àë n ‚àà ((finite_le_of_tendsto h_tendsto (b * r)).toFinset.filter (fun n => a * r < r_n n)), |f ((r_n n) / r) - g ((r_n n) / r)|) / (N r_n r : ‚Ñù) := by
    rw [ abs_div, abs_of_nonneg ( Nat.cast_nonneg _ : ( 0 : ‚Ñù ) ‚â§ N r_n r ) ] ; exact div_le_div_of_nonneg_right ( Finset.abs_sum_le_sum_abs _ _ ) ( Nat.cast_nonneg _ );
  -- Since |f(x) - g(x)| ‚â§ Œµ for all x ‚àà (a, b], we can replace each term in the sum with Œµ.
  have h_abs_diff_sum_le : (‚àë n ‚àà ((finite_le_of_tendsto h_tendsto (b * r)).toFinset.filter (fun n => a * r < r_n n)), |f ((r_n n) / r) - g ((r_n n) / r)|) ‚â§ (‚àë n ‚àà ((finite_le_of_tendsto h_tendsto (b * r)).toFinset.filter (fun n => a * r < r_n n)), Œµ) := by
    refine Finset.sum_le_sum fun n hn => h_bound _ ?_;
    exact?;
  convert h_abs_diff_sum.trans ( div_le_div_of_nonneg_right h_abs_diff_sum_le <| Nat.cast_nonneg _ ) using 1;
  ¬∑ unfold RiemannSum; norm_num [ Finset.sum_sub_distrib, sub_div ] ;
  ¬∑ simp +decide [ ‚Üê Finset.sum_filter, card_indices_eq, * ];
    rw [ Nat.cast_sub ( show N r_n ( b * r ) ‚â• N r_n ( a * r ) from _ ) ] ; ring;
    apply_rules [ Set.ncard_le_ncard ];
    ¬∑ exact fun x hx => le_trans hx.out ( mul_le_mul_of_nonneg_right hab.le hr.le );
    ¬∑ exact Set.finite_iff_bddAbove.mpr ( by rcases Filter.eventually_atTop.mp ( h_tendsto.eventually_gt_atTop ( b * r ) ) with ‚ü® N, hN ‚ü© ; exact ‚ü® N, fun n hn => not_lt.1 fun contra => not_le_of_gt ( hN n contra.le ) hn ‚ü© )

/-
Linearity of RiemannSum.
-/
lemma RiemannSum_add {r_n : ‚Ñï ‚Üí ‚Ñù} (h_tendsto : Tendsto r_n atTop atTop)
  (r : ‚Ñù) (a b : ‚Ñù) (f g : ‚Ñù ‚Üí ‚Ñù) :
  RiemannSum r_n h_tendsto r a b (f + g) = 
  RiemannSum r_n h_tendsto r a b f + RiemannSum r_n h_tendsto r a b g := by
  simp [RiemannSum, Finset.sum_add_distrib, add_div]

lemma RiemannSum_const_mul {r_n : ‚Ñï ‚Üí ‚Ñù} (h_tendsto : Tendsto r_n atTop atTop)
  (r : ‚Ñù) (a b : ‚Ñù) (c : ‚Ñù) (f : ‚Ñù ‚Üí ‚Ñù) :
  RiemannSum r_n h_tendsto r a b (fun x => c * f x) = 
  c * RiemannSum r_n h_tendsto r a b f := by
  simp [RiemannSum, Finset.mul_sum, mul_div]

/-
Definition of the target limit integral.
-/
noncomputable def TargetLimit (lam : ‚Ñù) (a b : ‚Ñù) (f : ‚Ñù ‚Üí ‚Ñù) : ‚Ñù :=
  ‚à´ x in a..b, f x * lam * x ^ (lam - 1)

/-
Bound on weighted integral.
-/
lemma integral_bound_weighted {a b : ‚Ñù} (hab : a ‚â§ b) {f : ‚Ñù ‚Üí ‚Ñù} {w : ‚Ñù ‚Üí ‚Ñù}
  (hw_nonneg : ‚àÄ x ‚àà Set.Ioc a b, 0 ‚â§ w x)
  (hf : IntervalIntegrable (fun x => f x * w x) MeasureTheory.volume a b)
  (hw : IntervalIntegrable w MeasureTheory.volume a b)
  (C : ‚Ñù) (hC : 0 ‚â§ C)
  (h_bound : ‚àÄ x ‚àà Set.Ioc a b, |f x| ‚â§ C) :
  |‚à´ x in a..b, f x * w x| ‚â§ C * ‚à´ x in a..b, w x := by
  -- Apply the bound on the integrand to the integral.
  have h_integral_bound : |‚à´ x in a..b, f x * w x| ‚â§ ‚à´ x in a..b, |f x * w x| := by
    apply_rules [ intervalIntegral.abs_integral_le_integral_abs, hab ];
  -- Apply the bound on the integrand to the integral: $|f x * w x| \leq C * w x$ for all $x \in (a, b]$.
  have h_integral_bound : ‚à´ x in a..b, |f x * w x| ‚â§ ‚à´ x in a..b, C * w x := by
    rw [ intervalIntegral.integral_of_le hab, intervalIntegral.integral_of_le hab ];
    refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
    ¬∑ exact Filter.Eventually.of_forall fun x => abs_nonneg _;
    ¬∑ exact MeasureTheory.Integrable.const_mul ( hw.1 ) _;
    ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx using by simpa only [ abs_mul, abs_of_nonneg ( hw_nonneg x hx ) ] using mul_le_mul_of_nonneg_right ( h_bound x hx ) ( hw_nonneg x hx ) ;
  simpa only [ intervalIntegral.integral_const_mul ] using le_trans ‚Äπ_‚Ä∫ h_integral_bound

/-
Bound on the difference of TargetLimits.
-/
lemma TargetLimit_bound {lam : ‚Ñù} {a b : ‚Ñù} (ha : 0 < a) (hab : a ‚â§ b) (hlam : 0 < lam) {f g : ‚Ñù ‚Üí ‚Ñù} {Œµ : ‚Ñù} (hŒµ : 0 ‚â§ Œµ)
  (hf : IntervalIntegrable (fun x => f x * lam * x ^ (lam - 1)) MeasureTheory.volume a b)
  (hg : IntervalIntegrable (fun x => g x * lam * x ^ (lam - 1)) MeasureTheory.volume a b)
  (h_bound : ‚àÄ x ‚àà Set.Ioc a b, |f x - g x| ‚â§ Œµ) :
  |TargetLimit lam a b f - TargetLimit lam a b g| ‚â§ Œµ * (b ^ lam - a ^ lam) := by
  -- Apply the bound on the difference of TargetLimits.
  have h_integral_diff : ‚à´ x in a..b, (f x - g x) * lam * x ^ (lam - 1) = (TargetLimit lam a b f) - (TargetLimit lam a b g) := by
    simp +decide [ sub_mul, mul_assoc, TargetLimit ];
    exact intervalIntegral.integral_sub ( by simpa only [ mul_assoc ] using hf ) ( by simpa only [ mul_assoc ] using hg );
  rw [ ‚Üê h_integral_diff, intervalIntegral.integral_of_le hab ];
  -- Apply the bound on the difference of TargetLimits using the fact that $|f(x) - g(x)| \leq \epsilon$ for all $x \in (a, b]$.
  have h_integral_bound : ‚à´ x in Set.Ioc a b, |(f x - g x) * lam * x ^ (lam - 1)| ‚â§ ‚à´ x in Set.Ioc a b, Œµ * lam * x ^ (lam - 1) := by
    refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
    ¬∑ exact Filter.Eventually.of_forall fun x => abs_nonneg _;
    ¬∑ exact ContinuousOn.integrableOn_Icc ( by exact continuousOn_of_forall_continuousAt fun x hx => by exact ContinuousAt.mul ( continuousAt_const.mul continuousAt_const ) ( ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by linarith [ hx.1 ] ) ) |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self;
    ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx using by rw [ abs_le ] ; constructor <;> nlinarith [ abs_le.mp ( h_bound x hx ), show 0 ‚â§ lam * x ^ ( lam - 1 ) by exact mul_nonneg hlam.le ( Real.rpow_nonneg ( by linarith [ hx.1 ] ) _ ) ] ;
  refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ‚Ñù ‚Üí ‚Ñù ) ) ( h_integral_bound.trans _ );
  rw [ ‚Üê intervalIntegral.integral_of_le hab, intervalIntegral.integral_const_mul, integral_rpow ] <;> norm_num [ hlam.ne', ha.le, hab ];
  ¬∑ rw [ mul_assoc, mul_div_cancel‚ÇÄ _ hlam.ne' ];
  ¬∑ exact Or.inl hlam

/-
Predicate stating that the Riemann sum of f converges to the TargetLimit of f.
-/
def HasLimit (r_n : ‚Ñï ‚Üí ‚Ñù) (h_tendsto : Tendsto r_n atTop atTop)
  (lam : ‚Ñù) (a b : ‚Ñù) (f : ‚Ñù ‚Üí ‚Ñù) : Prop :=
  Tendsto (fun r => RiemannSum r_n h_tendsto r a b f) atTop (ùìù (TargetLimit lam a b f))

/-
If f can be uniformly approximated by functions satisfying HasLimit, then f satisfies HasLimit.
-/
lemma HasLimit_of_approx {r_n : ‚Ñï ‚Üí ‚Ñù} (h_tendsto : Tendsto r_n atTop atTop)
  (lam : ‚Ñù) (hlam : 0 < lam) (a b : ‚Ñù) (ha : 0 < a) (hab : a < b)
  (h_regular : ‚àÄ (c : ‚Ñù) (hc : 0 < c),
    Tendsto (fun (r : ‚Ñù) => (N r_n (c * r) : ‚Ñù) / (N r_n r : ‚Ñù)) atTop (ùìù (c ^ lam)))
  (f : ‚Ñù ‚Üí ‚Ñù)
  (h_approx : ‚àÄ Œµ > 0, ‚àÉ g : ‚Ñù ‚Üí ‚Ñù, (‚àÄ x ‚àà Set.Ioc a b, |f x - g x| ‚â§ Œµ) ‚àß
    IntervalIntegrable (fun x => g x * lam * x ^ (lam - 1)) MeasureTheory.volume a b ‚àß
    HasLimit r_n h_tendsto lam a b g)
  (hf : IntervalIntegrable (fun x => f x * lam * x ^ (lam - 1)) MeasureTheory.volume a b) :
  HasLimit r_n h_tendsto lam a b f := by
  refine' Metric.tendsto_nhds.mpr _;
  intro Œµ Œµ_pos
  obtain ‚ü®g, hg‚ÇÅ, hg‚ÇÇ, hg‚ÇÉ‚ü© := h_approx (Œµ / (3 * (b ^ lam - a ^ lam + 1))) (by
  exact div_pos Œµ_pos ( mul_pos zero_lt_three ( add_pos ( sub_pos.mpr ( Real.rpow_lt_rpow ( by linarith ) hab ( by linarith ) ) ) zero_lt_one ) ));
  have h_bound : ‚àÄ·∂† r in Filter.atTop, |RiemannSum r_n h_tendsto r a b f - RiemannSum r_n h_tendsto r a b g| ‚â§ (Œµ / (3 * (b ^ lam - a ^ lam + 1))) * ((N r_n (b * r) : ‚Ñù) - N r_n (a * r)) / (N r_n r : ‚Ñù) := by
    filter_upwards [ Filter.eventually_gt_atTop 0, Filter.eventually_gt_atTop a ] with r hr‚ÇÅ hr‚ÇÇ;
    convert RiemannSum_bound h_tendsto r a b hr‚ÇÅ ( by linarith ) f g ( Œµ / ( 3 * ( b ^ lam - a ^ lam + 1 ) ) ) ( fun x hx => hg‚ÇÅ x hx ) using 1;
  -- Using the bounds from `h_bound` and `hg‚ÇÉ`, we can show that the distance between the Riemann sums and the target limits is small.
  have h_dist : ‚àÄ·∂† r in Filter.atTop, |RiemannSum r_n h_tendsto r a b f - RiemannSum r_n h_tendsto r a b g| ‚â§ Œµ / 3 := by
    have h_dist : Filter.Tendsto (fun r => ((N r_n (b * r) : ‚Ñù) - N r_n (a * r)) / (N r_n r : ‚Ñù)) Filter.atTop (nhds (b ^ lam - a ^ lam)) := by
      simpa [ sub_div ] using Filter.Tendsto.sub ( h_regular b ( by linarith ) ) ( h_regular a ( by linarith ) );
    have := h_dist.const_mul ( Œµ / ( 3 * ( b ^ lam - a ^ lam + 1 ) ) );
    filter_upwards [ h_bound, this.eventually ( gt_mem_nhds <| show Œµ / ( 3 * ( b ^ lam - a ^ lam + 1 ) ) * ( b ^ lam - a ^ lam ) < Œµ / 3 by rw [ div_mul_eq_mul_div, div_lt_iff‚ÇÄ ] <;> nlinarith [ Real.rpow_pos_of_pos ha lam, Real.rpow_lt_rpow ( by linarith ) hab hlam, mul_div_cancel‚ÇÄ Œµ ( by linarith [ Real.rpow_pos_of_pos ha lam, Real.rpow_lt_rpow ( by linarith ) hab hlam ] : ( 3 * ( b ^ lam - a ^ lam + 1 ) ) ‚â† 0 ) ] ) ] with r hr‚ÇÅ hr‚ÇÇ using le_trans hr‚ÇÅ <| by ring_nf at *; linarith;
  have h_target_dist : |TargetLimit lam a b f - TargetLimit lam a b g| ‚â§ Œµ / 3 := by
    have h_target_dist : |TargetLimit lam a b f - TargetLimit lam a b g| ‚â§ (Œµ / (3 * (b ^ lam - a ^ lam + 1))) * (b ^ lam - a ^ lam) := by
      apply_rules [ TargetLimit_bound ];
      ¬∑ linarith;
      ¬∑ exact div_nonneg Œµ_pos.le ( mul_nonneg zero_le_three ( add_nonneg ( sub_nonneg.mpr ( Real.rpow_le_rpow ( by linarith ) ( by linarith ) ( by linarith ) ) ) zero_le_one ) );
    exact h_target_dist.trans ( by rw [ div_mul_eq_mul_div, div_le_iff‚ÇÄ ] <;> nlinarith [ Real.rpow_pos_of_pos ha lam, Real.rpow_lt_rpow ( by linarith ) hab hlam ] );
  filter_upwards [ h_dist, hg‚ÇÉ.eventually ( Metric.ball_mem_nhds _ ( show 0 < Œµ / 3 by positivity ) ) ] with x hx‚ÇÅ hx‚ÇÇ using abs_lt.mpr ‚ü® by linarith [ abs_lt.mp hx‚ÇÇ, abs_le.mp hx‚ÇÅ, abs_le.mp h_target_dist ], by linarith [ abs_lt.mp hx‚ÇÇ, abs_le.mp hx‚ÇÅ, abs_le.mp h_target_dist ] ‚ü©

/-
Indicator functions satisfy HasLimit.
-/
lemma HasLimit_indicator {r_n : ‚Ñï ‚Üí ‚Ñù} (h_tendsto : Tendsto r_n atTop atTop)
  (lam : ‚Ñù) (hlam : 0 < lam) (a b u v : ‚Ñù) (ha : 0 < a) (hab : a < b) (hu : a ‚â§ u) (huv : u < v) (hv : v ‚â§ b)
  (h_regular : ‚àÄ (c : ‚Ñù) (hc : 0 < c),
    Tendsto (fun (r : ‚Ñù) => (N r_n (c * r) : ‚Ñù) / (N r_n r : ‚Ñù)) atTop (ùìù (c ^ lam))) :
  HasLimit r_n h_tendsto lam a b (Set.indicator (Set.Ioc u v) (fun _ => 1)) := by
  have h_target_limit : TargetLimit lam a b ((Set.Ioc u v).indicator fun _ => (1:‚Ñù)) = v ^ lam - u ^ lam := by
    unfold TargetLimit;
    rw [ intervalIntegral.integral_of_le ( by linarith ) ];
    -- Evaluate the integral of the indicator function over the interval [a, b].
    have h_indicator_integral : ‚à´ x in Set.Ioc a b, (Set.Ioc u v).indicator (fun _ => (1:‚Ñù)) x * lam * x ^ (lam - 1) = ‚à´ x in Set.Ioc u v, lam * x ^ (lam - 1) := by
      rw [ ‚Üê MeasureTheory.integral_indicator, ‚Üê MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
      grind;
    rw [ h_indicator_integral, ‚Üê intervalIntegral.integral_of_le ] <;> norm_num [ huv.le ];
    rw [ integral_rpow ] <;> norm_num [ hlam.ne' ];
    ¬∑ rw [ mul_div_cancel‚ÇÄ _ hlam.ne' ];
    ¬∑ exact Or.inl hlam;
  convert limit_sum_indicator h_tendsto lam hlam h_regular a b u v ha hab hu huv hv using 1;
  exact?

/-
Linearity of TargetLimit.
-/
lemma TargetLimit_add {lam : ‚Ñù} {a b : ‚Ñù} {f g : ‚Ñù ‚Üí ‚Ñù}
  (hf : IntervalIntegrable (fun x => f x * lam * x ^ (lam - 1)) MeasureTheory.volume a b)
  (hg : IntervalIntegrable (fun x => g x * lam * x ^ (lam - 1)) MeasureTheory.volume a b) :
  TargetLimit lam a b (f + g) = TargetLimit lam a b f + TargetLimit lam a b g := by
    unfold TargetLimit;
    rw [ ‚Üê intervalIntegral.integral_add ];
    ¬∑ simp +decide only [Pi.add_apply, add_mul];
    ¬∑ exact hf;
    ¬∑ exact hg

/-
HasLimit is closed under addition (with integrability assumptions).
-/
lemma HasLimit_add {r_n : ‚Ñï ‚Üí ‚Ñù} {h_tendsto : Tendsto r_n atTop atTop}
  {lam : ‚Ñù} {a b : ‚Ñù} {f g : ‚Ñù ‚Üí ‚Ñù}
  (hf_int : IntervalIntegrable (fun x => f x * lam * x ^ (lam - 1)) MeasureTheory.volume a b)
  (hg_int : IntervalIntegrable (fun x => g x * lam * x ^ (lam - 1)) MeasureTheory.volume a b)
  (hf : HasLimit r_n h_tendsto lam a b f)
  (hg : HasLimit r_n h_tendsto lam a b g) :
  HasLimit r_n h_tendsto lam a b (f + g) := by
    unfold HasLimit at *;
    convert hf.add hg using 2;
    ¬∑ exact?;
    ¬∑ exact?

/-
Linearity of TargetLimit (scalar multiplication).
-/
lemma TargetLimit_const_mul {lam : ‚Ñù} {a b : ‚Ñù} {c : ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù} :
  TargetLimit lam a b (fun x => c * f x) = c * TargetLimit lam a b f := by
  unfold TargetLimit
  simp only [mul_assoc]
  rw [intervalIntegral.integral_const_mul]

/-
Definition of a step function approximation of f on [a, b] with n steps.
-/
noncomputable def StepApprox (f : ‚Ñù ‚Üí ‚Ñù) (a b : ‚Ñù) (n : ‚Ñï) : ‚Ñù ‚Üí ‚Ñù :=
  fun x => ‚àë i ‚àà Finset.range n, 
    f (a + (i + 1) * (b - a) / n) * Set.indicator (Set.Ioc (a + i * (b - a) / n) (a + (i + 1) * (b - a) / n)) (fun _ => 1) x

#check HasLimit_add

/-
HasLimit is closed under scalar multiplication.
-/
lemma HasLimit_const_mul {r_n : ‚Ñï ‚Üí ‚Ñù} {h_tendsto : Tendsto r_n atTop atTop}
  {lam : ‚Ñù} {a b : ‚Ñù} {c : ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù}
  (hf : HasLimit r_n h_tendsto lam a b f) :
  HasLimit r_n h_tendsto lam a b (fun x => c * f x) := by
  unfold HasLimit at *
  simp only [RiemannSum_const_mul h_tendsto, TargetLimit_const_mul]
  exact Tendsto.const_mul c hf

/-
HasLimit is closed under finite sums.
-/
lemma HasLimit_sum {r_n : ‚Ñï ‚Üí ‚Ñù} {h_tendsto : Tendsto r_n atTop atTop}
  {lam : ‚Ñù} {a b : ‚Ñù} {Œπ : Type*} {s : Finset Œπ} {f : Œπ ‚Üí ‚Ñù ‚Üí ‚Ñù}
  (hf_int : ‚àÄ i ‚àà s, IntervalIntegrable (fun x => f i x * lam * x ^ (lam - 1)) MeasureTheory.volume a b)
  (hf : ‚àÄ i ‚àà s, HasLimit r_n h_tendsto lam a b (f i)) :
  HasLimit r_n h_tendsto lam a b (fun x => ‚àë i ‚àà s, f i x) := by
    -- Apply induction on the size of the finite set `s`.
    induction' s using Finset.induction with i s hi ih;
    ¬∑ -- The sum over the empty set is the zero function, and the Riemann sum for the zero function is zero.
      simp [HasLimit];
      unfold RiemannSum TargetLimit; aesop;
    ¬∑ convert HasLimit_add _ _ ( hf i ( Finset.mem_insert_self i s ) ) ( ih ( fun j hj => hf_int j ( Finset.mem_insert_of_mem hj ) ) ( fun j hj => hf j ( Finset.mem_insert_of_mem hj ) ) ) using 1;
      ¬∑ exact funext fun x => by simp +decide [ Finset.sum_insert hi ] ;
      ¬∑ exact hf_int i ( Finset.mem_insert_self i s );
      ¬∑ have h_sum_int : IntervalIntegrable (fun x => ‚àë i ‚àà s, f i x * lam * x ^ (lam - 1)) MeasureTheory.MeasureSpace.volume a b := by
          rw [ intervalIntegrable_iff ] at *;
          have h_sum_int : ‚àÄ i ‚àà s, MeasureTheory.IntegrableOn (fun x => f i x * lam * x ^ (lam - 1)) (Set.uIoc a b) MeasureTheory.MeasureSpace.volume := by
            exact fun i hi => by simpa only [ intervalIntegrable_iff ] using hf_int i ( Finset.mem_insert_of_mem hi ) ;
          exact MeasureTheory.integrable_finset_sum _ fun i hi => h_sum_int i hi;
        simpa only [ Finset.sum_mul _ _ _, mul_assoc ] using h_sum_int

/-
HasLimit is closed under addition (renamed to avoid conflict).
-/
lemma HasLimit_add_correct {r_n : ‚Ñï ‚Üí ‚Ñù} {h_tendsto : Tendsto r_n atTop atTop}
  {lam : ‚Ñù} {a b : ‚Ñù} {f g : ‚Ñù ‚Üí ‚Ñù}
  (hf_int : IntervalIntegrable (fun x => f x * lam * x ^ (lam - 1)) MeasureTheory.volume a b)
  (hg_int : IntervalIntegrable (fun x => g x * lam * x ^ (lam - 1)) MeasureTheory.volume a b)
  (hf : HasLimit r_n h_tendsto lam a b f)
  (hg : HasLimit r_n h_tendsto lam a b g) :
  HasLimit r_n h_tendsto lam a b (f + g) := by
  unfold HasLimit at *
  simp only [RiemannSum_add h_tendsto, TargetLimit_add hf_int hg_int]
  exact Tendsto.add hf hg

/-
StepApprox satisfies HasLimit.
-/
lemma HasLimit_StepApprox {r_n : ‚Ñï ‚Üí ‚Ñù} (h_tendsto : Tendsto r_n atTop atTop)
  (lam : ‚Ñù) (hlam : 0 < lam) (a b : ‚Ñù) (ha : 0 < a) (hab : a < b)
  (h_regular : ‚àÄ (c : ‚Ñù) (hc : 0 < c),
    Tendsto (fun (r : ‚Ñù) => (N r_n (c * r) : ‚Ñù) / (N r_n r : ‚Ñù)) atTop (ùìù (c ^ lam)))
  (f : ‚Ñù ‚Üí ‚Ñù) (n : ‚Ñï) (hn : 0 < n) :
  HasLimit r_n h_tendsto lam a b (StepApprox f a b n) := by
    -- Each term in the sum is an indicator function of an interval, which satisfies HasLimit by the previous lemma.
    have h_indicator : ‚àÄ i ‚àà Finset.range n, HasLimit r_n h_tendsto lam a b (fun x => f (a + (i + 1) * (b - a) / n) * Set.indicator (Set.Ioc (a + i * (b - a) / n) (a + (i + 1) * (b - a) / n)) (fun _ => 1) x) := by
      intro i hi
      have h_indicator_term : HasLimit r_n h_tendsto lam a b (fun x => Set.indicator (Set.Ioc (a + i * (b - a) / n) (a + (i + 1) * (b - a) / n)) (fun _ => 1) x) := by
        apply HasLimit_indicator;
        all_goals norm_num ; try nlinarith [ show ( i : ‚Ñù ) + 1 ‚â§ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel‚ÇÄ ( ( i : ‚Ñù ) * ( b - a ) ) ( by positivity : ( n : ‚Ñù ) ‚â† 0 ), mul_div_cancel‚ÇÄ ( ( ( i : ‚Ñù ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ‚Ñù ) ‚â† 0 ) ] ;
        assumption;
      -- Apply the linearity of the limit to the indicator function.
      apply HasLimit_const_mul h_indicator_term;
    apply HasLimit_sum;
    ¬∑ intro i hi;
      rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le hab.le ];
      refine' MeasureTheory.Integrable.mono' _ _ _;
      refine' fun x => |f ( a + ( i + 1 ) * ( b - a ) / n ) * lam| * x ^ ( lam - 1 );
      ¬∑ exact ( intervalIntegral.intervalIntegrable_rpow' ( by linarith ) ).1.const_mul _;
      ¬∑ exact Measurable.aestronglyMeasurable ( by exact Measurable.mul ( Measurable.mul ( Measurable.mul ( measurable_const ) ( measurable_const.indicator ( measurableSet_Ioc ) ) ) measurable_const ) ( measurable_id.pow_const _ ) );
      ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx;
        by_cases hi' : x ‚àà Set.Ioc ( a + i * ( b - a ) / n ) ( a + ( i + 1 ) * ( b - a ) / n ) <;> simp_all +decide [ abs_mul, abs_of_nonneg, Real.rpow_nonneg, hx.1.le, hx.2 ];
        ¬∑ rw [ abs_of_nonneg ( Real.rpow_nonneg ( by linarith ) _ ) ];
        ¬∑ exact mul_nonneg ( mul_nonneg ( abs_nonneg _ ) ( abs_nonneg _ ) ) ( Real.rpow_nonneg ( by linarith ) _ );
    ¬∑ assumption

/-
StepApprox evaluates to the function value at the right endpoint of the interval containing x.
-/
lemma StepApprox_spec {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} {n : ‚Ñï} {x : ‚Ñù} {i : ‚Ñï}
  (hn : 0 < n) (hi : i < n)
  (hx : x ‚àà Set.Ioc (a + i * (b - a) / n) (a + (i + 1) * (b - a) / n))
  (hab : a < b) :
  StepApprox f a b n x = f (a + (i + 1) * (b - a) / n) := by
    -- Since $x \in (a + i * (b - a) / n, a + (i + 1) * (b - a) / n]$, the indicator function $\mathbf{1}_{(a + i * (b - a) / n, a + (i + 1) * (b - a) / n]}(x)$ is 1.
    have h_indicator : ‚àÄ j : ‚Ñï, j ‚â† i ‚Üí Set.indicator (Set.Ioc (a + j * (b - a) / n) (a + (j + 1) * (b - a) / n)) (fun _ => 1) x = 0 := by
      intro j hj_ne; by_cases h_cases : j < i <;> simp_all +decide [ Set.indicator_apply ];
      ¬∑ intro hx'; ring_nf at *; nlinarith [ ( by norm_cast : ( j : ‚Ñù ) + 1 ‚â§ i ), mul_inv_cancel_left‚ÇÄ ( by positivity : ( n : ‚Ñù ) ‚â† 0 ) ( b - a ) ] ;
      ¬∑ intro hx'; ring_nf at *; nlinarith [ show ( j : ‚Ñù ) ‚â• i + 1 by exact_mod_cast lt_of_le_of_ne h_cases ( Ne.symm hj_ne ), mul_inv_cancel‚ÇÄ ( by positivity : ( n : ‚Ñù ) ‚â† 0 ) ] ;
    unfold StepApprox; erw [ Finset.sum_eq_single i ] <;> aesop;

/-
StepApprox uniformly approximates f.
-/
lemma StepApprox_close {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} (hab : a < b) (hf : ContinuousOn f (Set.Icc a b)) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :
  ‚àÉ n : ‚Ñï, 0 < n ‚àß ‚àÄ x ‚àà Set.Ioc a b, |f x - StepApprox f a b n x| ‚â§ Œµ := by
  -- Since `f` is continuous on `[a, b]`, it is uniformly continuous.
  have h_unif_cont : UniformContinuousOn f (Set.Icc a b) := by
    exact ( isCompact_Icc.uniformContinuousOn_of_continuous hf );
  -- Choose `n` such that `(b - a) / n < Œ¥`.
  obtain ‚ü®Œ¥, hŒ¥_pos, hŒ¥‚ü© : ‚àÉ Œ¥ > 0, ‚àÄ x y, x ‚àà Set.Icc a b ‚Üí y ‚àà Set.Icc a b ‚Üí |x - y| < Œ¥ ‚Üí |f x - f y| < Œµ := by
    exact Metric.uniformContinuousOn_iff.mp h_unif_cont Œµ hŒµ |> Exists.imp fun Œ¥ => by tauto;
  -- Choose `n` such that `(b - a) / n < Œ¥`. This ensures that the length of each subinterval is less than Œ¥.
  obtain ‚ü®n, hn_pos, hn_sub‚ü© : ‚àÉ n : ‚Ñï, 0 < n ‚àß (b - a) / n < Œ¥ := by
    exact ‚ü® ‚åä ( b - a ) / Œ¥‚åã‚Çä + 1, Nat.succ_pos _, by rw [ div_lt_iff‚ÇÄ ] <;> push_cast <;> nlinarith [ Nat.lt_floor_add_one ( ( b - a ) / Œ¥ ), mul_div_cancel‚ÇÄ ( b - a ) hŒ¥_pos.ne' ] ‚ü©;
  refine' ‚ü® n, hn_pos, fun x hx => _ ‚ü©;
  -- Since $x \neq b$, there exists $i$ such that $a + i * (b - a) / n < x \leq a + (i + 1) * (b - a) / n$.
  obtain ‚ü®i, hi‚ü© : ‚àÉ i : ‚Ñï, i < n ‚àß a + i * (b - a) / n < x ‚àß x ‚â§ a + (i + 1) * (b - a) / n := by
    field_simp;
    refine' ‚ü® ‚åà ( n : ‚Ñù ) * ( x - a ) / ( b - a ) ‚åâ‚Çä - 1, _, _, _ ‚ü©;
    ¬∑ rw [ tsub_lt_iff_right ] <;> norm_num;
      ¬∑ rw [ Nat.lt_succ_iff ] ; exact Nat.ceil_le.mpr ( by rw [ div_le_iff‚ÇÄ ] <;> nlinarith [ hx.1, hx.2, show ( n : ‚Ñù ) ‚â• 1 by norm_cast ] );
      ¬∑ exact div_pos ( mul_pos ( Nat.cast_pos.mpr hn_pos ) ( sub_pos.mpr hx.1 ) ) ( sub_pos.mpr hab );
    ¬∑ rw [ Nat.cast_sub ] <;> norm_num;
      ¬∑ nlinarith [ Nat.ceil_lt_add_one ( show 0 ‚â§ ( n : ‚Ñù ) * ( x - a ) / ( b - a ) by exact div_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg.mpr hx.1.le ) ) ( sub_nonneg.mpr hab.le ) ), mul_div_cancel‚ÇÄ ( ( n : ‚Ñù ) * ( x - a ) ) ( sub_ne_zero.mpr hab.ne' ), hx.1, hx.2 ];
      ¬∑ exact div_pos ( mul_pos ( Nat.cast_pos.mpr hn_pos ) ( sub_pos.mpr hx.1 ) ) ( sub_pos.mpr hab );
    ¬∑ rw [ Nat.cast_sub ] <;> norm_num;
      ¬∑ nlinarith [ Nat.le_ceil ( ( n : ‚Ñù ) * ( x - a ) / ( b - a ) ), mul_div_cancel‚ÇÄ ( ( n : ‚Ñù ) * ( x - a ) ) ( sub_ne_zero_of_ne hab.ne' ) ];
      ¬∑ exact div_pos ( mul_pos ( Nat.cast_pos.mpr hn_pos ) ( sub_pos.mpr hx.1 ) ) ( sub_pos.mpr hab );
  -- By definition of `StepApprox`, we have `StepApprox f a b n x = f (a + (i + 1) * (b - a) / n)`.
  have h_step_approx : StepApprox f a b n x = f (a + (i + 1) * (b - a) / n) := by
    apply StepApprox_spec hn_pos hi.left;
    ¬∑ aesop;
    ¬∑ linarith;
  exact h_step_approx.symm ‚ñ∏ le_of_lt ( hŒ¥ x ( a + ( i + 1 ) * ( b - a ) / n ) ‚ü® by linarith [ hx.1 ], by linarith [ hx.2 ] ‚ü© ‚ü® by nlinarith [ hx.1, hx.2, show ( i : ‚Ñù ) + 1 ‚â§ n by norm_cast; linarith, mul_div_cancel‚ÇÄ ( ( i + 1 ) * ( b - a ) ) ( by positivity : ( n : ‚Ñù ) ‚â† 0 ) ], by nlinarith [ hx.1, hx.2, show ( i : ‚Ñù ) + 1 ‚â§ n by norm_cast; linarith, mul_div_cancel‚ÇÄ ( ( i + 1 ) * ( b - a ) ) ( by positivity : ( n : ‚Ñù ) ‚â† 0 ) ] ‚ü© ( by rw [ abs_lt ] ; constructor <;> nlinarith [ hx.1, hx.2, show ( i : ‚Ñù ) + 1 ‚â§ n by norm_cast; linarith, mul_div_cancel‚ÇÄ ( ( i + 1 ) * ( b - a ) ) ( by positivity : ( n : ‚Ñù ) ‚â† 0 ), mul_div_cancel‚ÇÄ ( ( i : ‚Ñù ) * ( b - a ) ) ( by positivity : ( n : ‚Ñù ) ‚â† 0 ), div_mul_cancel‚ÇÄ ( b - a ) ( by positivity : ( n : ‚Ñù ) ‚â† 0 ) ] ) )