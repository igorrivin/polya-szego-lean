/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b8559e14-a9e2-4a8c-8a8f-517b0584a0aa
-/

/-
Formalization of Polya-Szego Problem 146. We define `PolyaSzegoEnvelopingSeries` to capture the notion of a series strictly enveloping a function. We then prove `problem_146_final`, showing that if a series strictly envelopes a function, its coefficients `a_n` for `n ≥ 1` must have alternating signs.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of an enveloping series. Note: The user's definition might be non-standard (checking strict envelopment).
-/
structure EnvelopingSeries (f : ℝ → ℝ) (R : ℝ) (a : ℕ → ℝ) : Prop where
  pos_R : R > 0
  series_envelopes : ∀ x > R, ∀ n : ℕ, 
    let S_n := a 0 + ∑ k ∈ Finset.range (n + 1), a (k + 1) / (x : ℝ) ^ (k + 1)
    let next_term := a (n + 2) / (x : ℝ) ^ (n + 2)
    (f x - S_n) * next_term < 0

/-
Definition of partial sum and enveloping series (corrected to strict envelopment).
-/
def polyaSzegoPartialSum (a : ℕ → ℝ) (x : ℝ) (n : ℕ) : ℝ := ∑ k ∈ Finset.range (n + 1), a k / x ^ k

structure PolyaSzegoEnvelopingSeries (f : ℝ → ℝ) (R : ℝ) (a : ℕ → ℝ) : Prop where
  pos_R : R > 0
  strict_envelope : ∀ x > R, ∀ n : ℕ, (f x - polyaSzegoPartialSum a x n) * (f x - polyaSzegoPartialSum a x (n + 1)) < 0

/-
Corrected Polya-Szego Problem 146: If a series strictly envelopes a function, then the coefficients alternate in sign.
-/
theorem problem_146_corrected (f : ℝ → ℝ) (R : ℝ) (a : ℕ → ℝ) (h : PolyaSzegoEnvelopingSeries f R a) :
  ∀ n ≥ 1, a n * a (n + 1) < 0 := by
  intro n hn
  have h_env := h.strict_envelope
  -- We need to show a_n * a_{n+1} < 0
  -- We know a_n has same sign as (f x - S_{n-1})
  -- And a_{n+1} has same sign as (f x - S_n)
  -- And (f x - S_{n-1}) * (f x - S_n) < 0
  -- So a_n * a_{n+1} < 0
  -- Let's choose any $x > R$.
  obtain ⟨x₀, hx₀⟩ : ∃ x₀ > R, True := by
    exact ⟨ R + 1, by linarith, trivial ⟩;
  -- By definition of $S_n$, we have $S_{n+1} = S_n + a_{n+1}/x^{n+1}$.
  have h_diff : ∀ n, (f x₀ - polyaSzegoPartialSum a x₀ n) = (f x₀ - polyaSzegoPartialSum a x₀ (n + 1)) + a (n + 1) / x₀ ^ (n + 1) := by
    intro n; unfold polyaSzegoPartialSum; simp +decide [ Finset.sum_range_succ ] ; ring;
  -- Since δ_n and δ_{n+1} have opposite signs, δ_n - δ_{n+1} has the same sign as δ_n.
  have h_sign : ∀ n, (a (n + 1) / x₀ ^ (n + 1)) * (f x₀ - polyaSzegoPartialSum a x₀ n) > 0 := by
    intro n; specialize h_env x₀ hx₀.1 n; specialize h_diff n; rcases lt_trichotomy ( f x₀ - polyaSzegoPartialSum a x₀ n ) 0 with hn | hn | hn <;> rcases lt_trichotomy ( f x₀ - polyaSzegoPartialSum a x₀ ( n + 1 ) ) 0 with hn' | hn' | hn' <;> nlinarith;
  -- Since $x₀ > 0$, $a_{n+1}$ has the same sign as $\delta_n$.
  have h_sign_a : ∀ n, (a (n + 1)) * (f x₀ - polyaSzegoPartialSum a x₀ n) > 0 := by
    intro n; specialize h_sign n; rw [ div_mul_eq_mul_div, gt_iff_lt ] at *; rw [ lt_div_iff₀ ] at * <;> norm_num at * ; tauto;
    exact pow_pos ( by linarith [ h.pos_R ] ) _;
  rcases n <;> norm_num at *;
  have := h_sign_a ‹_›; have := h_sign_a ( Nat.succ ‹_› ) ; have := h_env x₀ hx₀ ‹_›; norm_num at * ; nlinarith [ h_sign ‹_›, h_sign ( Nat.succ ‹_› ) ] ;

/-
Final theorem matching the user's requested format, derived from the corrected formalization.
-/
theorem problem_146_final (f : ℝ → ℝ) (R : ℝ) (a : ℕ → ℝ) 
    (h : PolyaSzegoEnvelopingSeries f R a) : 
    (∀ n : ℕ, n ≥ 1 → ((a n > 0 ∧ a (n + 1) < 0) ∨ (a n < 0 ∧ a (n + 1) > 0))) ∧
    (∀ x > R, ∀ n : ℕ, (f x - polyaSzegoPartialSum a x n) * (f x - polyaSzegoPartialSum a x (n + 1)) < 0) := by
  constructor
  · intro n hn
    have := problem_146_corrected f R a h n hn
    rw [mul_neg_iff] at this
    exact this
  · exact h.strict_envelope