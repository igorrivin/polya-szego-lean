/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 45f6b4a7-01a4-4801-a154-c11e07561003
-/

/-
Formalization of Polya-Szego Problem 150 and examples from 151.
We define the hypothesis `max_deriv_only_at_origin` and prove that for an entire function `f`, its Maclaurin series converges to `f` (Problem 150a).
For Problem 150b, we provide a corrected statement `problem_150b_corrected` which assumes the absolute convergence of the series to justify the interchange of summation and integration (Fubini's theorem), proving that the integral transform `F(z)` is represented by the series `‚àë f‚ÅΩ‚Åø‚Åæ(0) z‚Åª‚Åø`.
We also prove the convergence of the Maclaurin series for `e‚Åª·∂ª`, `log(1+z)`, and `(1+z)‚Åª·µñ` (Problem 151 examples) within their respective regions of convergence.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-- Part (b): Integral transform F(z) is enveloped by series -/
noncomputable def F (f : ‚ÑÇ ‚Üí ‚ÑÇ) (z : ‚ÑÇ) : ‚ÑÇ :=
  ‚à´ t in Set.Ioi (0 : ‚Ñù), Complex.exp (-t) * f (t / z)

theorem exp_neg_z_enveloped :
    ‚àÄ z : ‚ÑÇ, 0 ‚â§ z.re ‚Üí z ‚â† 0 ‚Üí HasSum (fun n : ‚Ñï => ((-1 : ‚ÑÇ)^n / (n.factorial : ‚ÑÇ)) * z ^ n) (Complex.exp (-z)) := by
  -- We'll use the exponential representation of the series. Note that $\sum_{n=0}^{\infty} \frac{(-z)^n}{n!} = e^{-z}$.
  intro z hz hz_ne_zero
  have h_exp : ‚àë' n : ‚Ñï, (-z) ^ n / (Nat.factorial n) = Complex.exp (-z) := by
    -- By definition of the exponential function, we know that $\sum_{n=0}^{\infty} \frac{(-z)^n}{n!} = e^{-z}$.
    simp [Complex.exp_eq_exp_‚ÑÇ, NormedSpace.exp_eq_tsum_div];
  -- Since the series converges to the same value as the exponential series, we can conclude that it has the same sum.
  convert h_exp ‚ñ∏ Summable.hasSum _ using 1;
  ¬∑ -- By simplifying, we can see that the two functions are indeed equal.
    funext n; ring;
  ¬∑ -- The series $\sum_{n=0}^{\infty} \frac{(-z)^n}{n!}$ is the Taylor series for $e^{-z}$, which converges for all $z$.
    apply Complex.exp_eq_exp_‚ÑÇ.symm ‚ñ∏ NormedSpace.expSeries_div_hasSum_exp ‚ÑÇ _ |> HasSum.summable

open Complex
open Set
open Filter
open scoped Topology
open MeasureTheory

variable {f : ‚ÑÇ ‚Üí ‚ÑÇ} {ùîÖ : Set ‚ÑÇ}

/-- Hypothesis: ùîÖ is a ray from origin where all derivatives of f attain maximum absolute value only at origin -/
def max_deriv_only_at_origin (f : ‚ÑÇ ‚Üí ‚ÑÇ) (ùîÖ : Set ‚ÑÇ) : Prop :=
  ùîÖ ‚äÜ {z | arg z = 0} ‚àß  -- Ray along positive real axis for simplicity
  (‚àÄ (n : ‚Ñï) (z : ‚ÑÇ), z ‚àà ùîÖ ‚Üí z ‚â† 0 ‚Üí ‚Äñderiv^[n] f 0‚Äñ > ‚Äñderiv^[n] f z‚Äñ)

/-- Part (a): Maclaurin series envelops f on the ray ùîÖ -/
theorem problem_150a (hf : Differentiable ‚ÑÇ f) (hmax : max_deriv_only_at_origin f ùîÖ) :
    ‚àÄ z ‚àà ùîÖ, HasSum (fun n : ‚Ñï => (deriv^[n] f 0 / (n.factorial : ‚ÑÇ)) * z ^ n) (f z) := by
  intro z hz;
  convert ( Complex.hasSum_taylorSeries_of_entire ( hf ) ) 0 z using 1;
  ext; simp +decide [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm, iteratedDeriv_eq_iterate ]

lemma integral_exp_neg_mul_pow_eq_factorial (n : ‚Ñï) :
    ‚à´ (t : ‚Ñù) in Set.Ioi 0, Complex.exp (-(t : ‚ÑÇ)) * (t : ‚ÑÇ) ^ n = (n.factorial : ‚ÑÇ) := by
  -- Recognize that the integral is the Gamma function evaluated at $n+1$, which is $n!$.
  have h_gamma : ‚à´ t in Set.Ioi (0 : ‚Ñù), (t : ‚Ñù) ^ n * Real.exp (-t) = Real.Gamma (n + 1) := by
    -- By definition of the Gamma function, we know that $\Gamma(n+1) = \int_{0}^{\infty} t^n e^{-t} dt$.
    rw [Real.Gamma_eq_integral (by linarith)];
    -- Since multiplication is commutative, we can rewrite the integrand as $t^n * \exp(-t) = \exp(-t) * t^n$.
    simp [mul_comm];
  -- Since the integrand is real, the integral over the complex numbers is the same as the integral over the real numbers.
  have h_real_complex : ‚à´ t in Set.Ioi (0 : ‚Ñù), (t : ‚ÑÇ) ^ n * Complex.exp (-t) = ‚à´ t in Set.Ioi (0 : ‚Ñù), (t : ‚Ñù) ^ n * Real.exp (-t) := by
    convert integral_ofReal using 3 ; norm_cast;
  simp_all +decide [ mul_comm ];
  exact_mod_cast Real.Gamma_nat_eq_factorial n

theorem problem_150b_corrected (hf : Differentiable ‚ÑÇ f)
    (hconv : ‚àÄ z : ‚ÑÇ, z.re > 0 ‚Üí IntegrableOn (fun t : ‚Ñù => Complex.exp (-t) * f (t / z)) (Set.Ioi 0)) :
    ‚àÄ z ‚àà ùîÖ, Summable (fun n : ‚Ñï => ‚Äñderiv^[n] f 0‚Äñ / ‚Äñz‚Äñ ^ n) ‚Üí
    HasSum (fun n : ‚Ñï => deriv^[n] f 0 / z ^ n) (F f z) := by
  intro z hz hsum
  have h_integral : ‚à´ t in Set.Ioi (0 : ‚Ñù), Complex.exp (-t) * f (t / z) = ‚àë' n, (‚à´ t in Set.Ioi (0 : ‚Ñù), Complex.exp (-t) * (deriv^[n] f 0 / (n.factorial : ‚ÑÇ)) * t ^ n / z ^ n) := by
    have h_integral : ‚àÄ t ‚àà Set.Ioi (0 : ‚Ñù), Complex.exp (-t) * f (t / z) = ‚àë' n, Complex.exp (-t) * (deriv^[n] f 0 / (n.factorial : ‚ÑÇ)) * t ^ n / z ^ n := by
      -- By definition of $f$, we know that $f(t/z) = \sum_{n=0}^\infty \frac{f^{(n)}(0)}{n!} (t/z)^n$.
      have h_series : ‚àÄ t ‚àà Set.Ioi (0 : ‚Ñù), f (t / z) = ‚àë' n, (deriv^[n] f 0 / (n.factorial : ‚ÑÇ)) * (t / z) ^ n := by
        have := @Complex.taylorSeries_eq_on_ball;
        intro t ht; specialize this ( show DifferentiableOn ‚ÑÇ f ( Metric.ball 0 ( ‚Äñ ( t : ‚ÑÇ ) / z‚Äñ + 1 ) ) from hf.differentiableOn ) ( show ( t : ‚ÑÇ ) / z ‚àà Metric.ball 0 ( ‚Äñ ( t : ‚ÑÇ ) / z‚Äñ + 1 ) from by simp ) ; simp_all +decide [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm, iteratedDeriv_eq_iterate ] ;
      intro t ht; rw [ h_series t ht ] ; rw [ ‚Üê tsum_mul_left ] ; congr; ext n; ring;
    rw [ MeasureTheory.setIntegral_congr_fun measurableSet_Ioi h_integral, ‚Üê MeasureTheory.integral_tsum ];
    ¬∑ exact fun n => Continuous.aestronglyMeasurable ( by continuity );
    ¬∑ refine' ne_of_lt ( lt_of_le_of_lt ( ENNReal.tsum_le_tsum fun n => _ ) _ );
      use fun n => ENNReal.ofReal ( ‚à´ t in Set.Ioi ( 0 : ‚Ñù ), Real.exp ( -t ) * ( ‚Äñderiv^[n] f 0‚Äñ / ( n.factorial : ‚Ñù ) ) * t ^ n / ‚Äñz‚Äñ ^ n );
      ¬∑ rw [ MeasureTheory.ofReal_integral_eq_lintegral_ofReal ];
        ¬∑ refine' MeasureTheory.setLIntegral_mono' measurableSet_Ioi fun x hx => _;
          rw [ ENNReal.le_ofReal_iff_toReal_le ] <;> norm_num [ Complex.norm_exp, abs_of_nonneg hx.out.le ];
          exact div_nonneg ( mul_nonneg ( mul_nonneg ( Real.exp_nonneg _ ) ( div_nonneg ( norm_nonneg _ ) ( Nat.cast_nonneg _ ) ) ) ( pow_nonneg hx.out.le _ ) ) ( pow_nonneg ( norm_nonneg _ ) _ );
        ¬∑ have h_gamma : ‚à´ t in Set.Ioi (0 : ‚Ñù), Real.exp (-t) * t ^ n = (n.factorial : ‚Ñù) := by
            rw [ ‚Üê Real.Gamma_nat_eq_factorial, Real.Gamma_eq_integral ( by positivity ) ] ; norm_num [ mul_comm ];
          contrapose! h_gamma;
          rw [ MeasureTheory.integral_undef ];
          ¬∑ positivity;
          ¬∑ exact fun h => h_gamma <| by simpa [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ] using h.mul_const ( ‚Äñderiv^[n] f 0‚Äñ / ( n.factorial : ‚Ñù ) / ‚Äñz‚Äñ ^ n ) ;
        ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with t ht using div_nonneg ( mul_nonneg ( mul_nonneg ( Real.exp_nonneg _ ) ( div_nonneg ( norm_nonneg _ ) ( Nat.cast_nonneg _ ) ) ) ( pow_nonneg ht.out.le _ ) ) ( pow_nonneg ( norm_nonneg _ ) _ );
      ¬∑ -- Evaluate the integral $\int_0^\infty e^{-t} t^n dt$.
        have h_gamma : ‚àÄ n : ‚Ñï, ‚à´ t in Set.Ioi (0 : ‚Ñù), Real.exp (-t) * t ^ n = (n.factorial : ‚Ñù) := by
          intro n; rw [ ‚Üê Real.Gamma_nat_eq_factorial ] ; rw [ Real.Gamma_eq_integral ( by positivity ) ] ; norm_num [ mul_comm ] ;
        simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, MeasureTheory.integral_const_mul, MeasureTheory.integral_mul_const ];
        field_simp;
        simp_all +decide [ MeasureTheory.integral_div, MeasureTheory.integral_mul_const ];
        rw [ ‚Üê ENNReal.ofReal_tsum_of_nonneg ] <;> norm_num [ mul_div_mul_left, Nat.factorial_ne_zero ];
        ¬∑ exact fun n => div_nonneg ( norm_nonneg _ ) ( pow_nonneg ( norm_nonneg _ ) _ );
        ¬∑ simpa only [ inv_mul_eq_div ] using hsum;
  -- Let's simplify the expression inside the sum.
  have h_simplify : ‚àÄ n : ‚Ñï, ‚à´ t in Set.Ioi (0 : ‚Ñù), Complex.exp (-t) * (deriv^[n] f 0 / (n.factorial : ‚ÑÇ)) * t ^ n / z ^ n = (deriv^[n] f 0 / z ^ n) * (n.factorial : ‚ÑÇ) / (n.factorial : ‚ÑÇ) := by
    -- Recognize that the integral is the Gamma function $\Gamma(n+1) = n!$.
    have h_gamma : ‚àÄ n : ‚Ñï, ‚à´ t in Set.Ioi (0 : ‚Ñù), Complex.exp (-t) * t ^ n = (n.factorial : ‚ÑÇ) := by
      exact?;
    intro n; rw [ ‚Üê h_gamma n ] ; rw [ ‚Üê MeasureTheory.integral_const_mul ] ; rw [ ‚Üê MeasureTheory.integral_div ] ; congr; ext; ring;
  simp_all +decide [ Nat.factorial_ne_zero ];
  convert h_integral ‚ñ∏ Summable.hasSum _ using 1;
  exact .of_norm <| by simpa using hsum;

lemma iteratedDeriv_pow_neg_p (p : ‚ÑÇ) (n : ‚Ñï) :
    ‚àÄ z : ‚ÑÇ, 0 ‚â§ z.re ‚Üí deriv^[n] (fun w => (1 + w) ^ (-p)) z = (-1) ^ n * (ascPochhammer ‚ÑÇ n).eval p * (1 + z) ^ (-p - n) := by
  induction' n with n ih <;> simp_all +decide [ Function.iterate_succ_apply' ];
  -- Apply the induction hypothesis to rewrite the nth derivative.
  intro z hz
  have h_ind : deriv (fun z => (-1 : ‚ÑÇ)^n * (ascPochhammer ‚ÑÇ n).eval p * (1 + z) ^ (-p - n : ‚ÑÇ)) z = (-1 : ‚ÑÇ)^(n + 1) * (ascPochhammer ‚ÑÇ (n + 1)).eval p * (1 + z) ^ (-p - (n + 1) : ‚ÑÇ) := by
    convert HasDerivAt.deriv ( HasDerivAt.const_mul _ <| HasDerivAt.cpow_const ( hasDerivAt_id' z |> HasDerivAt.const_add _ ) _ ) using 1 <;> norm_num;
    ¬∑ rw [ ascPochhammer_succ_right ] ; norm_num ; ring;
    ¬∑ exact Or.inl ( by norm_num; linarith );
  -- Substitute the induction hypothesis into the derivative expression.
  have h_subst : deriv (deriv^[n] (fun w => (1 + w) ^ (-p))) z = deriv (fun z => (-1 : ‚ÑÇ)^n * (ascPochhammer ‚ÑÇ n).eval p * (1 + z) ^ (-p - n : ‚ÑÇ)) z := by
    have h_subst : ‚àÄ·∂† w in nhds z, deriv^[n] (fun w => (1 + w) ^ (-p)) w = (-1 : ‚ÑÇ)^n * (ascPochhammer ‚ÑÇ n).eval p * (1 + w) ^ (-p - n : ‚ÑÇ) := by
      -- The nth derivative of $(1 + w)^{-p}$ is given by the formula.
      have h_deriv_formula : ‚àÄ w : ‚ÑÇ, w.re > -1 ‚Üí deriv^[n] (fun w => (1 + w) ^ (-p)) w = (-1 : ‚ÑÇ)^n * (ascPochhammer ‚ÑÇ n).eval p * (1 + w) ^ (-p - n : ‚ÑÇ) := by
        intro w hw
        have h_deriv_formula : ‚àÄ k : ‚Ñï, ‚àÄ w : ‚ÑÇ, w.re > -1 ‚Üí deriv^[k] (fun w => (1 + w) ^ (-p)) w = (-1 : ‚ÑÇ)^k * (ascPochhammer ‚ÑÇ k).eval p * (1 + w) ^ (-p - k : ‚ÑÇ) := by
          intro k w hw; induction' k with k ih generalizing w <;> simp_all +decide [ Function.iterate_succ_apply' ] ; ring;
          convert HasDerivAt.deriv ( HasDerivAt.congr_of_eventuallyEq ( HasDerivAt.mul ( hasDerivAt_const _ _ ) ( HasDerivAt.cpow ( hasDerivAt_id' w |> HasDerivAt.const_add _ ) ( hasDerivAt_const _ _ ) _ ) ) ( Filter.eventuallyEq_of_mem ( IsOpen.mem_nhds ( isOpen_lt continuous_const Complex.continuous_re ) hw ) fun x hx => ih x hx ) ) using 1 <;> norm_num ; ring;
          ¬∑ rw [ add_comm 1 k, ascPochhammer_succ_eval ] ; ring;
          ¬∑ exact Or.inl ( by norm_num; linarith );
        exact h_deriv_formula n w hw;
      exact Filter.eventually_of_mem ( IsOpen.mem_nhds ( isOpen_lt continuous_const Complex.continuous_re ) ( show -1 < z.re by linarith ) ) fun w hw => h_deriv_formula w hw;
    exact Filter.EventuallyEq.deriv_eq h_subst;
  rw [h_subst, h_ind]

#check Complex.hasSum_taylorSeries_log

theorem log_one_plus_z_enveloped :
    ‚àÄ z : ‚ÑÇ, ‚Äñz‚Äñ < 1 ‚Üí HasSum (fun n : ‚Ñï => (-1 : ‚ÑÇ) ^ n / (n + 1) * z ^ (n + 1)) (Complex.log (1 + z)) := by
      field_simp;
      -- Apply the theorem that states the Taylor series for $\log(1 + z)$ converges to $\log(1 + z)$ for $|z| < 1$.
      have h_taylor : ‚àÄ z : ‚ÑÇ, ‚Äñz‚Äñ < 1 ‚Üí HasSum (fun n : ‚Ñï => (-1) ^ n * z ^ (n + 1) / (n + 1)) (Complex.log (1 + z)) := by
        intro z hz
        have := Complex.hasSum_taylorSeries_log (show 1 + z ‚àà {z : ‚ÑÇ | ‚Äñz - 1‚Äñ < 1} from by
                                                  -- Since ‚Äñz‚Äñ < 1, we have ‚Äñ(1 + z) - 1‚Äñ = ‚Äñz‚Äñ < 1.
                                                  simp [hz])
        convert hasSum_nat_add_iff' 1 |>.2 ( this ) using 1 <;> norm_num ; ring;
      assumption

theorem one_plus_z_pow_neg_p_enveloped (p : ‚ÑÇ) :
    ‚àÄ z : ‚ÑÇ, ‚Äñz‚Äñ < 1 ‚Üí HasSum (fun n : ‚Ñï => (-1 : ‚ÑÇ) ^ n * (ascPochhammer ‚ÑÇ n).eval p / (n.factorial : ‚ÑÇ) * z ^ n) ((1 + z) ^ (-p)) := by
      intro z hz;
      have := @Complex.taylorSeries_eq_on_ball;
      replace := @this ‚ÑÇ _ _ _ ( fun w => ( 1 + w ) ^ ( -p ) ) 0 1 ?_ z ?_ <;> norm_num at *;
      ¬∑ convert this ‚ñ∏ Summable.hasSum _ using 1;
        ¬∑ ext n; rw [ iteratedDeriv ] ; ring;
          -- By definition of iterated derivative, we have:
          have h_iter_deriv : iteratedDeriv n (fun w => (1 + w) ^ (-p)) 0 = (-1) ^ n * (ascPochhammer ‚ÑÇ n).eval p := by
            convert iteratedDeriv_pow_neg_p p n 0 using 1 ; norm_num [ add_comm ];
            rw [ iteratedDeriv_eq_iterate ];
          simp_all +decide [ iteratedFDeriv_eq_equiv_comp, Function.comp ];
          simp +decide [ mul_assoc, mul_comm, mul_left_comm, ContinuousMultilinearMap.piFieldEquiv ];
        ¬∑ contrapose! this;
          rw [ tsum_eq_zero_of_not_summable this ] ; norm_num;
          rw [ eq_comm, Complex.cpow_eq_zero_iff ] ; norm_num;
          exact fun h => False.elim <| hz.not_le <| by rw [ show z = -1 by linear_combination' h ] ; norm_num;
      ¬∑ refine' DifferentiableOn.cpow _ _ _ <;> norm_num;
        ¬∑ exact differentiableOn_id.const_add _;
        ¬∑ intro z hz; simp_all +decide [ Complex.slitPlane ];
          exact Or.inl ( by linarith [ abs_le.mp ( Complex.abs_re_le_norm z ) ] );
      ¬∑ exact hz