/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f040e60c-d9f2-4a84-bc6e-e427f71a9d66
-/

/-
We formalize Polya-Szego Problem 107 regarding the curvature of the curve w = z^n + a.
We define the curve parameterization γ(t) = r^n * exp(i * n * t) + a.
We define the signed curvature for a parameterized curve in the complex plane.
We prove that the signed curvature is given by (sgn n) / r^n for n ≠ 0 and r > 0.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Complex.norm_zpow
#check Complex.norm_pow
#check deriv
#check Complex.I

/-
The signed curvature of the curve $w = z^n + a$ (parameterized by $z = r e^{it}$) is given by $\kappa = (\text{sgn } n) / r^n$.
-/
noncomputable def gamma (n : ℤ) (a : ℂ) (r : ℝ) (t : ℝ) : ℂ :=
  (r : ℂ) ^ n * Complex.exp (Complex.I * n * t) + a

noncomputable def signed_curvature (γ : ℝ → ℂ) (t : ℝ) : ℝ :=
  let z' := deriv γ t
  let z'' := deriv (deriv γ) t
  (z'.re * z''.im - z'.im * z''.re) / (norm z') ^ 3

theorem problem_107_corrected (n : ℤ) (hn : n ≠ 0) (a : ℂ) (r : ℝ) (hr : r > 0) (t : ℝ) :
    signed_curvature (gamma n a r) t = (n.sign : ℝ) / r ^ n := by
  -- Calculate the first derivative $\gamma'(t)$.
  have h_deriv : deriv (gamma n a r) t = Complex.I * n * r ^ n * Complex.exp (Complex.I * n * t) := by
    unfold gamma; norm_num [ mul_assoc, mul_comm, mul_left_comm ] ; ring;
    convert congr_arg _ ( HasDerivAt.deriv ( HasDerivAt.comp t ( Complex.hasDerivAt_exp _ ) ( HasDerivAt.mul ( HasDerivAt.mul ( hasDerivAt_const _ _ ) ( hasDerivAt_id' t |> HasDerivAt.ofReal_comp ) ) ( hasDerivAt_const _ _ ) ) ) ) using 1 ; norm_num ; ring;
  -- Calculate the second derivative $\gamma''(t)$.
  have h_deriv2 : deriv (deriv (gamma n a r)) t = -n ^ 2 * r ^ n * Complex.exp (Complex.I * n * t) := by
    convert HasDerivAt.deriv ( HasDerivAt.congr_of_eventuallyEq _ <| Filter.eventuallyEq_of_mem ( Metric.ball_mem_nhds _ zero_lt_one ) fun x hx => show deriv ( gamma n a r ) x = Complex.I * ( n : ℂ ) * ( r : ℂ ) ^ n * Complex.exp ( Complex.I * ( n : ℂ ) * x ) from ?_ ) using 1;
    · convert HasDerivAt.const_mul _ ( HasDerivAt.comp t ( Complex.hasDerivAt_exp _ ) ( HasDerivAt.const_mul _ ( hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) ) ) using 1 ; norm_num ; ring;
      norm_num;
    · unfold gamma; norm_num [ mul_assoc, mul_comm, mul_left_comm ] ;
      convert congr_arg ( fun y => ( r : ℂ ) ^ n * y ) ( HasDerivAt.deriv ( HasDerivAt.comp x ( Complex.hasDerivAt_exp _ ) ( HasDerivAt.const_mul Complex.I ( HasDerivAt.mul ( hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) ( hasDerivAt_const _ _ ) ) ) ) ) using 1 ; norm_num ; ring;
  unfold signed_curvature;
  simp_all +decide [ Complex.norm_def, Complex.normSq ];
  norm_cast ; norm_num [ Complex.exp_re, Complex.exp_im, sq ] ; ring;
  cases' abs_cases ( n : ℝ ) with hn hn <;> simp +decide [ *, Real.sin_sq, Real.cos_sq ] <;> ring;
  · norm_num [ abs_of_pos hr, hn, zpow_neg, zpow_mul, mul_assoc, mul_comm, mul_left_comm, ‹¬n = 0› ];
    rw [ show ( n.sign : ℝ ) = 1 by norm_cast; exact Int.sign_eq_one_of_pos ( lt_of_le_of_ne ( mod_cast hn.2 ) ( Ne.symm ‹_› ) ) ] ; ring;
    by_cases h : r ^ n = 0 <;> simp_all +decide [ sq, pow_three, mul_assoc ];
  · norm_num [ abs_of_pos hr, hn, zpow_neg, zpow_mul, zpow_two, mul_assoc, mul_left_comm, mul_comm, hr.ne', ‹¬n = 0› ] ; ring;
    norm_num [ show n.sign = -1 by exact Int.sign_eq_neg_one_of_neg ( mod_cast hn.2 ) ] ; ring;
    by_cases h : r ^ n = 0 <;> simp +decide [ h, pow_three, sq, mul_assoc ]